<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>nansat.mosaic module &mdash; Nansat 0.6dev documentation</title>
    
    <link rel="stylesheet" type="text/css" href="_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="_static/css/spc-extend.css">
    <link rel="stylesheet" href="_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.6dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/js/copybutton.js"></script>
    <link rel="top" title="Nansat 0.6dev documentation" href="index.html" > 
  </head>
  <body>

<div class="container">
  <div class="top-scipy-org-logo-header">
    <a href="index.html">
      <img style="border: 0;" alt="SciPy" src="_static/img/nansat_logo.gif"></a>
    </div>
  </div>
</div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
        <li class="active"><a href="https://github.com/nansencenter/nansat/">GitHub</a></li>
	
        <li class="active"><a href="index.html">Nansat 0.6dev documentation</a></li>
	 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <div class="section" id="module-nansat.mosaic">
<span id="nansat-mosaic-module"></span><h1>nansat.mosaic module<a class="headerlink" href="#module-nansat.mosaic" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="nansat.mosaic.Mosaic">
<em class="property">class </em><tt class="descclassname">nansat.mosaic.</tt><tt class="descname">Mosaic</tt><big>(</big><em>fileName=''</em>, <em>mapperName=''</em>, <em>domain=None</em>, <em>array=None</em>, <em>parameters=None</em>, <em>logLevel=30</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.mosaic.Mosaic" title="Permalink to this definition">¶</a></dt>
<dd><p>Create Nansat object</p>
<dl class="docutils">
<dt>if &lt;fileName&gt; is given:</dt>
<dd>Open GDAL dataset,
Read metadata,
Generate GDAL VRT file with mapping of variables in memory
Create logger
Create Nansat object for perfroming high-level operations</dd>
<dt>if &lt;domain&gt; and &lt;array&gt; are given:</dt>
<dd>Create VRT object from data in &lt;array&gt;
Add geolocation from &lt;domain&gt;</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : string</p>
<blockquote>
<div><p>location of the file</p>
</div></blockquote>
<p><strong>mapperName</strong> : string, optional</p>
<blockquote>
<div><p>name of the mapper from nansat/mappers dir. E.g.
&#8216;ASAR&#8217;, &#8216;hirlam&#8217;, &#8216;merisL1&#8217;, &#8216;merisL2&#8217;, etc.</p>
</div></blockquote>
<p><strong>domain</strong> : Domain object</p>
<blockquote>
<div><p>Geo-reference of a new raster</p>
</div></blockquote>
<p><strong>array</strong> : numpy array</p>
<blockquote>
<div><p>Firts band of a new raster</p>
</div></blockquote>
<p><strong>parameters</strong> : dictionary</p>
<blockquote>
<div><p>Metadata for the 1st band of a new raster,e.g. name, wkv, units,...</p>
</div></blockquote>
<p><strong>logLevel</strong> : int, optional, default: logging.DEBUG (30)</p>
<blockquote>
<div><p>Level of logging. See: <a class="reference external" href="http://docs.python.org/howto/logging.html">http://docs.python.org/howto/logging.html</a></p>
</div></blockquote>
<p><strong>kwargs</strong> : additional arguments for mappers</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Creates:</th><td class="field-body"><p class="first"><strong>self.mapper</strong> : str</p>
<blockquote>
<div><p>name of the used mapper</p>
</div></blockquote>
<p><strong>self.fileName</strong> : file name</p>
<blockquote>
<div><p>set file name given by the argument</p>
</div></blockquote>
<p><strong>self.vrt</strong> : VRT object</p>
<blockquote>
<div><p>Wrapper around VRT file and GDAL dataset with satellite raster data</p>
</div></blockquote>
<p><strong>self.logger</strong> : logging.Logger</p>
<blockquote>
<div><p>logger for output debugging info</p>
</div></blockquote>
<p><strong>self.name</strong> : string</p>
<blockquote class="last">
<div><p>name of object (for writing KML)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>n = Nansat(filename)
# opens file for reading. Opening is lazy - no data is read at this
# point, only metadata that describes the dataset and bands</p>
<p>n = Nansat(domain=d)
# create an empty Nansat object. &lt;d&gt; is the Domain object which
# describes the grid (projection, resolution and extent)</p>
<p>n = Nansat(domain=d, array=a, parameters=p)
# create a Nansat object in memory with one band from input array &lt;a&gt;.
# &lt;p&gt; is a dictionary with metadata for the band</p>
<p>a = n[1]
# fetch data from Nansat object from the first band</p>
<p>a = n[&#8216;band_name&#8217;]
# fetch data from the band which has name &#8216;band_name&#8217;</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#nansat.mosaic.Mosaic.add_band" title="nansat.mosaic.Mosaic.add_band"><tt class="xref py py-obj docutils literal"><span class="pre">add_band</span></tt></a>(array[,&nbsp;parameters,&nbsp;nomem])</td>
<td>Add band from the array to self.vrt</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.mosaic.Mosaic.add_bands" title="nansat.mosaic.Mosaic.add_bands"><tt class="xref py py-obj docutils literal"><span class="pre">add_bands</span></tt></a>(arrays[,&nbsp;parameters,&nbsp;nomem])</td>
<td>Add band from the array to self.vrt</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.mosaic.Mosaic.average" title="nansat.mosaic.Mosaic.average"><tt class="xref py py-obj docutils literal"><span class="pre">average</span></tt></a>([files,&nbsp;bands,&nbsp;doReproject,&nbsp;...])</td>
<td>Memory-friendly, multithreaded mosaicing(averaging) of input files</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.mosaic.Mosaic.azimuth_y" title="nansat.mosaic.Mosaic.azimuth_y"><tt class="xref py py-obj docutils literal"><span class="pre">azimuth_y</span></tt></a>([reductionFactor])</td>
<td>Calculate the azimuth of &#8216;upward&#8217; direction in each pixel</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.mosaic.Mosaic.bands" title="nansat.mosaic.Mosaic.bands"><tt class="xref py py-obj docutils literal"><span class="pre">bands</span></tt></a>()</td>
<td>Make a dictionary with all metadata from all bands</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.mosaic.Mosaic.crop" title="nansat.mosaic.Mosaic.crop"><tt class="xref py py-obj docutils literal"><span class="pre">crop</span></tt></a>([xOff,&nbsp;yOff,&nbsp;xSize,&nbsp;ySize,&nbsp;lonlim,&nbsp;latlim])</td>
<td>Crop Nansat object</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.mosaic.Mosaic.export" title="nansat.mosaic.Mosaic.export"><tt class="xref py py-obj docutils literal"><span class="pre">export</span></tt></a>(fileName[,&nbsp;bands,&nbsp;rmMetadata,&nbsp;...])</td>
<td>Export Nansat object into netCDF or GTiff file</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.mosaic.Mosaic.export2thredds" title="nansat.mosaic.Mosaic.export2thredds"><tt class="xref py py-obj docutils literal"><span class="pre">export2thredds</span></tt></a>(fileName[,&nbsp;bands,&nbsp;metadata,&nbsp;...])</td>
<td>Export data into a netCDF formatted for THREDDS server</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.mosaic.Mosaic.get_GDALRasterBand" title="nansat.mosaic.Mosaic.get_GDALRasterBand"><tt class="xref py py-obj docutils literal"><span class="pre">get_GDALRasterBand</span></tt></a>([bandID])</td>
<td>Get a GDALRasterBand of a given Nansat object</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.mosaic.Mosaic.get_border" title="nansat.mosaic.Mosaic.get_border"><tt class="xref py py-obj docutils literal"><span class="pre">get_border</span></tt></a>([nPoints])</td>
<td>Generate two vectors with values of lat/lon for the border of domain</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.mosaic.Mosaic.get_border_geometry" title="nansat.mosaic.Mosaic.get_border_geometry"><tt class="xref py py-obj docutils literal"><span class="pre">get_border_geometry</span></tt></a>()</td>
<td>Get OGR Geometry of the border Polygon</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.mosaic.Mosaic.get_border_postgis" title="nansat.mosaic.Mosaic.get_border_postgis"><tt class="xref py py-obj docutils literal"><span class="pre">get_border_postgis</span></tt></a>()</td>
<td>Get PostGIS formatted string of the border Polygon</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.mosaic.Mosaic.get_border_wkt" title="nansat.mosaic.Mosaic.get_border_wkt"><tt class="xref py py-obj docutils literal"><span class="pre">get_border_wkt</span></tt></a>()</td>
<td>Creates string with WKT representation of the border polygon</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.mosaic.Mosaic.get_corners" title="nansat.mosaic.Mosaic.get_corners"><tt class="xref py py-obj docutils literal"><span class="pre">get_corners</span></tt></a>()</td>
<td>Get coordinates of corners of the Domain</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.mosaic.Mosaic.get_geolocation_grids" title="nansat.mosaic.Mosaic.get_geolocation_grids"><tt class="xref py py-obj docutils literal"><span class="pre">get_geolocation_grids</span></tt></a>([stepSize])</td>
<td>Get longitude and latitude grids representing the full data grid</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.mosaic.Mosaic.get_metadata" title="nansat.mosaic.Mosaic.get_metadata"><tt class="xref py py-obj docutils literal"><span class="pre">get_metadata</span></tt></a>([key,&nbsp;bandID])</td>
<td>Get metadata from self.vrt.dataset</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.mosaic.Mosaic.get_pixelsize_meters" title="nansat.mosaic.Mosaic.get_pixelsize_meters"><tt class="xref py py-obj docutils literal"><span class="pre">get_pixelsize_meters</span></tt></a>()</td>
<td>Returns the pixelsize (deltaX, deltaY) of the domain</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.mosaic.Mosaic.get_time" title="nansat.mosaic.Mosaic.get_time"><tt class="xref py py-obj docutils literal"><span class="pre">get_time</span></tt></a>([bandID])</td>
<td>Get time for dataset and/or its bands</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.mosaic.Mosaic.get_transect" title="nansat.mosaic.Mosaic.get_transect"><tt class="xref py py-obj docutils literal"><span class="pre">get_transect</span></tt></a>([points,&nbsp;bandList,&nbsp;latlon,&nbsp;...])</td>
<td>Get transect from two poins and retun the values by numpy array</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.mosaic.Mosaic.has_band" title="nansat.mosaic.Mosaic.has_band"><tt class="xref py py-obj docutils literal"><span class="pre">has_band</span></tt></a>(band)</td>
<td>Check if self has band with name &lt;band&gt;</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.mosaic.Mosaic.latest" title="nansat.mosaic.Mosaic.latest"><tt class="xref py py-obj docutils literal"><span class="pre">latest</span></tt></a>([files,&nbsp;bands,&nbsp;doReproject,&nbsp;maskName])</td>
<td>Mosaic by adding the latest image on top without averaging</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.mosaic.Mosaic.list_bands" title="nansat.mosaic.Mosaic.list_bands"><tt class="xref py py-obj docutils literal"><span class="pre">list_bands</span></tt></a>([doPrint])</td>
<td>Show band information of the given Nansat object</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.mosaic.Mosaic.median" title="nansat.mosaic.Mosaic.median"><tt class="xref py py-obj docutils literal"><span class="pre">median</span></tt></a>([files,&nbsp;bands,&nbsp;doReproject,&nbsp;maskName])</td>
<td>Calculate median of input bands</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.mosaic.Mosaic.nClass" title="nansat.mosaic.Mosaic.nClass"><tt class="xref py py-obj docutils literal"><span class="pre">nClass</span></tt></a></td>
<td>alias of <tt class="xref py py-class docutils literal"><span class="pre">Nansat</span></tt></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.mosaic.Mosaic.reproject" title="nansat.mosaic.Mosaic.reproject"><tt class="xref py py-obj docutils literal"><span class="pre">reproject</span></tt></a>([dstDomain,&nbsp;eResampleAlg,&nbsp;...])</td>
<td>Change projection of the object based on the given Domain</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.mosaic.Mosaic.reproject_GCPs" title="nansat.mosaic.Mosaic.reproject_GCPs"><tt class="xref py py-obj docutils literal"><span class="pre">reproject_GCPs</span></tt></a>(srsString)</td>
<td>Reproject all GCPs to a new spatial reference system</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.mosaic.Mosaic.resize" title="nansat.mosaic.Mosaic.resize"><tt class="xref py py-obj docutils literal"><span class="pre">resize</span></tt></a>([factor,&nbsp;width,&nbsp;height,&nbsp;pixelsize,&nbsp;...])</td>
<td>Proportional resize of the dataset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.mosaic.Mosaic.set_metadata" title="nansat.mosaic.Mosaic.set_metadata"><tt class="xref py py-obj docutils literal"><span class="pre">set_metadata</span></tt></a>([key,&nbsp;value,&nbsp;bandID])</td>
<td>Set metadata to self.vrt.dataset</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.mosaic.Mosaic.shape" title="nansat.mosaic.Mosaic.shape"><tt class="xref py py-obj docutils literal"><span class="pre">shape</span></tt></a>()</td>
<td>Return Numpy-like shape of Domain object (ySize, xSize)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.mosaic.Mosaic.transform_points" title="nansat.mosaic.Mosaic.transform_points"><tt class="xref py py-obj docutils literal"><span class="pre">transform_points</span></tt></a>(colVector,&nbsp;rowVector[,&nbsp;...])</td>
<td>Transform given lists of X,Y coordinates into lon/lat or inverse</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.mosaic.Mosaic.undo" title="nansat.mosaic.Mosaic.undo"><tt class="xref py py-obj docutils literal"><span class="pre">undo</span></tt></a>([steps])</td>
<td>Undo reproject, resize, add_band or crop of Nansat object</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.mosaic.Mosaic.watermask" title="nansat.mosaic.Mosaic.watermask"><tt class="xref py py-obj docutils literal"><span class="pre">watermask</span></tt></a>([mod44path,&nbsp;dstDomain])</td>
<td>Create numpy array with watermask (water=1, land=0)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.mosaic.Mosaic.write_figure" title="nansat.mosaic.Mosaic.write_figure"><tt class="xref py py-obj docutils literal"><span class="pre">write_figure</span></tt></a>([fileName,&nbsp;bands,&nbsp;clim,&nbsp;addDate])</td>
<td>Save a raster band to a figure in graphical format.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.mosaic.Mosaic.write_geotiffimage" title="nansat.mosaic.Mosaic.write_geotiffimage"><tt class="xref py py-obj docutils literal"><span class="pre">write_geotiffimage</span></tt></a>(fileName[,&nbsp;bandID])</td>
<td>Writes an 8-bit GeoTiff image for a given band.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.mosaic.Mosaic.write_kml" title="nansat.mosaic.Mosaic.write_kml"><tt class="xref py py-obj docutils literal"><span class="pre">write_kml</span></tt></a>([xmlFileName,&nbsp;kmlFileName])</td>
<td>Write KML file with domains</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.mosaic.Mosaic.write_kml_image" title="nansat.mosaic.Mosaic.write_kml_image"><tt class="xref py py-obj docutils literal"><span class="pre">write_kml_image</span></tt></a>([kmlFileName,&nbsp;kmlFigureName])</td>
<td>Create KML file for already projected image</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.mosaic.Mosaic.write_map" title="nansat.mosaic.Mosaic.write_map"><tt class="xref py py-obj docutils literal"><span class="pre">write_map</span></tt></a>(outputFileName[,&nbsp;lonVec,&nbsp;latVec,&nbsp;...])</td>
<td>Create an image with a map of the domain</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nansat.mosaic.Mosaic.add_band">
<tt class="descname">add_band</tt><big>(</big><em>array</em>, <em>parameters=None</em>, <em>nomem=False</em><big>)</big><a class="headerlink" href="#nansat.mosaic.Mosaic.add_band" title="Permalink to this definition">¶</a></dt>
<dd><p>Add band from the array to self.vrt</p>
<p>Create VRT object which contains VRT and RAW binary file and append it
to self.vrt.subVRTs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>array</strong> : ndarray</p>
<blockquote>
<div><p>band data</p>
</div></blockquote>
<p><strong>parameters</strong> : dictionary</p>
<blockquote>
<div><p>band metadata: wkv, name, etc. (or for several bands)</p>
</div></blockquote>
<p><strong>nomem</strong> : boolean, saves the vrt to a tempfile if nomem is True</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>Creates VRT object with VRT-file and RAW-file</strong></p>
<p class="last"><strong>Adds band to the self.vrt</strong></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>n.add_band(a, p)
# add new band from numpy array &lt;a&gt; with metadata &lt;p&gt; in memory
# Shape of a should be equal to the shape of &lt;n&gt;</p>
<p>n.add_band(a, p, nomem=True)
# add new band from an array &lt;a&gt; with metadata &lt;p&gt; but keep it
# temporarli on disk intead of memory</p>
</dd></dl>

<dl class="method">
<dt id="nansat.mosaic.Mosaic.add_bands">
<tt class="descname">add_bands</tt><big>(</big><em>arrays</em>, <em>parameters=None</em>, <em>nomem=False</em><big>)</big><a class="headerlink" href="#nansat.mosaic.Mosaic.add_bands" title="Permalink to this definition">¶</a></dt>
<dd><p>Add band from the array to self.vrt</p>
<p>Create VRT object which contains VRT and RAW binary file and append it
to self.vrt.subVRTs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>array</strong> : ndarray or list</p>
<blockquote>
<div><p>band data (or data for several bands)</p>
</div></blockquote>
<p><strong>parameters</strong> : dictionary or list</p>
<blockquote>
<div><p>band metadata: wkv, name, etc. (or for several bands)</p>
</div></blockquote>
<p><strong>nomem</strong> : boolean, saves the vrt to a tempfile if nomem is True</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>Creates VRT object with VRT-file and RAW-file</strong></p>
<p class="last"><strong>Adds band to the self.vrt</strong></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>n.add_bands([a1, a2], [p1, p2])
# add two new bands from numpy arrays &lt;a1&gt; and &lt;a2&gt; with metadata in
# &lt;p1&gt; and &lt;p2&gt;</p>
</dd></dl>

<dl class="method">
<dt id="nansat.mosaic.Mosaic.average">
<tt class="descname">average</tt><big>(</big><em>files=[], bands=[1], doReproject=True, maskName='mask', threads=1, **kwargs</em><big>)</big><a class="headerlink" href="#nansat.mosaic.Mosaic.average" title="Permalink to this definition">¶</a></dt>
<dd><p>Memory-friendly, multithreaded mosaicing(averaging) of input files</p>
<p>Convert all input files into Nansat objects, reproject onto the
Domain of the current object, get bands, from each object,
calculate average and STD, add averaged bands (and STD) to the current
object.</p>
<p>average() tries to get band &#8216;mask&#8217; from the input files. The mask
should have the following coding:</p>
<blockquote>
<div>0 : nodata
1 : clouds
2 : land
64 : valid pixel</div></blockquote>
<p>If it gets that band (which can be provided by some mappers or Nansat
childs, e.g.  ModisL2Image) it uses it to select averagable pixels
(i.e. where mask == 64).
If it cannot locate the band &#8216;mask&#8217; is assumes that all pixels are
averagebale except for thouse out of swath after reprojection.</p>
<p>average() adds bands to the object, so it works only with empty, or
non-projected objects</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>files</strong> : list</p>
<blockquote>
<div><p>list of input files</p>
</div></blockquote>
<p><strong>bands</strong> : list</p>
<blockquote>
<div><p>list of names/band_numbers to be processed</p>
</div></blockquote>
<p><strong>doReproject</strong> : boolean, [True]</p>
<blockquote>
<div><p>reproject input files?</p>
</div></blockquote>
<p><strong>maskName</strong> : str, [&#8216;mask&#8217;]</p>
<blockquote>
<div><p>name of the mask in input files</p>
</div></blockquote>
<p><strong>nClass</strong> : child of Nansat, [Nansat]</p>
<blockquote>
<div><p>This class is used to read input files</p>
</div></blockquote>
<p><strong>threads</strong> : int</p>
<blockquote>
<div><p>number of parallel processes to use</p>
</div></blockquote>
<p><strong>eResampleAlg</strong> : int, [0]</p>
<blockquote>
<div><p>agorithm for reprojection, see Nansat.reproject()</p>
</div></blockquote>
<p><strong>period</strong> : [datetime0, datetime1]</p>
<blockquote class="last">
<div><p>Start and stop datetime objects from pyhon datetime.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.mosaic.Mosaic.azimuth_y">
<tt class="descname">azimuth_y</tt><big>(</big><em>reductionFactor=1</em><big>)</big><a class="headerlink" href="#nansat.mosaic.Mosaic.azimuth_y" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the azimuth of &#8216;upward&#8217; direction in each pixel</p>
<p>Generaly speaking, azimuth is angle from the reference vector
(direction to North) to the chosen direction. Azimuth increases
clockwise from direction to North. <a class="reference external" href="http://en.wikipedia.org/wiki/Azimuth">http://en.wikipedia.org/wiki/Azimuth</a></p>
<p>Here we calcluate azimuth of &#8216;upward&#8217; direction.
&#8216;Upward&#8217; direction coincides with Y-axis direction (and hence is
opposite to the ROW-axis direction). For lon-lat (cylindrical,
Plate Caree) and Mercator projections &#8216;upward&#8217; direction coincides with
direction to North, hence azimuth is 0.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reductionFactor</strong> : integer</p>
<blockquote>
<div><p>factor by which the size of the output array is reduced</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>azimuth</strong> : numpy array</p>
<blockquote class="last">
<div><p>Values of azimuth in degrees in range 0 - 360</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.mosaic.Mosaic.bands">
<tt class="descname">bands</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.mosaic.Mosaic.bands" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a dictionary with all metadata from all bands</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>b</strong> : dictionary</p>
<blockquote class="last">
<div><p>key = N, value = dict with all band metadata</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.mosaic.Mosaic.crop">
<tt class="descname">crop</tt><big>(</big><em>xOff=0</em>, <em>yOff=0</em>, <em>xSize=None</em>, <em>ySize=None</em>, <em>lonlim=None</em>, <em>latlim=None</em><big>)</big><a class="headerlink" href="#nansat.mosaic.Mosaic.crop" title="Permalink to this definition">¶</a></dt>
<dd><p>Crop Nansat object</p>
<p>Create superVRT, modify the Source Rectangle (SrcRect) and Destination
Rectangle (DstRect) tags in the VRT file for each band in order
to take only part of the original image,
create new GCPs or new GeoTransform for the cropped object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xOff</strong> : int</p>
<blockquote>
<div><p>pixel offset of subimage</p>
</div></blockquote>
<p><strong>yOff</strong> : int</p>
<blockquote>
<div><p>line offset of subimage</p>
</div></blockquote>
<p><strong>xSize</strong> : int</p>
<blockquote>
<div><p>width in pixels of subimage</p>
</div></blockquote>
<p><strong>ySize</strong> : int</p>
<blockquote>
<div><p>height in pizels of subimage</p>
</div></blockquote>
<p><strong>lonlim</strong> : [float, float]</p>
<blockquote>
<div><p>longitdal limits</p>
</div></blockquote>
<p><strong>latlim</strong> : [float, float]</p>
<blockquote>
<div><p>latitudal limits</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.vrt</strong> : VRT</p>
<blockquote>
<div><p>superVRT is created with modified SrcRect and DstRect</p>
</div></blockquote>
<p><strong>Returns</strong></p>
<p><strong>&#8212;&#8212;-</strong></p>
<blockquote class="last">
<div><dl class="docutils">
<dt>status <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">0 - everyhting is OK, image is cropped
1 - if crop is totally outside, image is NOT cropped
2 - crop area is too large and crop is not needed</p>
</dd>
<dt>extent <span class="classifier-delimiter">:</span> <span class="classifier">(xOff, yOff, xSize, ySize)</span></dt>
<dd><p class="first last">xOff  - X offset in the original dataset
yOff  - Y offset in the original dataset
xSize - width of the new dataset
ySize - height of the new dataset</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p># crop a subimage of size 100x200 pix from X/Y offset 10, 20 pix
status, extent = n.crop(10, 20, 100, 200)</p>
<p># crop a subimage within the lon/lat limits
status, extent = n.crop(lonlim=[-20, 20], latlim=[50, 60])</p>
<p># crop a subimage interactively
status, extent = n.crop()</p>
</dd></dl>

<dl class="method">
<dt id="nansat.mosaic.Mosaic.export">
<tt class="descname">export</tt><big>(</big><em>fileName</em>, <em>bands=None</em>, <em>rmMetadata=[]</em>, <em>addGeolocArray=True</em>, <em>addGCPs=True</em>, <em>driver='netCDF'</em>, <em>bottomup=False</em>, <em>options=None</em><big>)</big><a class="headerlink" href="#nansat.mosaic.Mosaic.export" title="Permalink to this definition">¶</a></dt>
<dd><p>Export Nansat object into netCDF or GTiff file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : str</p>
<blockquote>
<div><p>output file name</p>
</div></blockquote>
<p><strong>bands: list (default=None)</strong></p>
<blockquote>
<div><p>Specify band numbers to export.
If None, all bands are exported.</p>
</div></blockquote>
<p><strong>rmMetadata</strong> : list</p>
<blockquote>
<div><p>metadata names for removal before export.
e.g. [&#8216;name&#8217;, &#8216;colormap&#8217;, &#8216;source&#8217;, &#8216;sourceBands&#8217;]</p>
</div></blockquote>
<p><strong>addGeolocArray</strong> : bool</p>
<blockquote>
<div><p>add geolocation array datasets to exported file?</p>
</div></blockquote>
<p><strong>addGCPs</strong> : bool</p>
<blockquote>
<div><p>add GCPs to exported file?</p>
</div></blockquote>
<p><strong>driver</strong> : str</p>
<blockquote>
<div><p>Name of GDAL driver (format)</p>
</div></blockquote>
<p><strong>bottomup</strong> : bool</p>
<blockquote>
<div><dl class="docutils">
<dt>False: Write swath-projected data with rows and columns organized</dt>
<dd><p class="first last">as in the original product.</p>
</dd>
</dl>
<p>True:  Use the default behaviour of GDAL, which is to flip the rows</p>
</div></blockquote>
<p><strong>options</strong> : str or list</p>
<blockquote>
<div><p>GDAL export options in format of: &#8216;OPT=VAL&#8217;, or
[&#8216;OPT1=VAL1&#8217;, &#8216;OP2=&#8217;VAL2&#8217;]
See also <a class="reference external" href="http://www.gdal.org/frmt_netcdf.html">http://www.gdal.org/frmt_netcdf.html</a></p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>Create a netCDF file</strong></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>n.export(netcdfile)
# export all the bands into a netDCF 3 file</p>
<p>n.export(driver=&#8217;GTiff&#8217;)
# export all bands into a GeoTiff</p>
</dd></dl>

<dl class="method">
<dt id="nansat.mosaic.Mosaic.export2thredds">
<tt class="descname">export2thredds</tt><big>(</big><em>fileName</em>, <em>bands=None</em>, <em>metadata=None</em>, <em>maskName=None</em>, <em>rmMetadata=[]</em>, <em>time=None</em>, <em>createdTime=None</em><big>)</big><a class="headerlink" href="#nansat.mosaic.Mosaic.export2thredds" title="Permalink to this definition">¶</a></dt>
<dd><p>Export data into a netCDF formatted for THREDDS server</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : str</p>
<blockquote>
<div><p>output file name</p>
</div></blockquote>
<p><strong>bands</strong> : dict</p>
<blockquote>
<div><dl class="docutils">
<dt>{&#8216;band_name&#8217;: {&#8216;type&#8217; <span class="classifier-delimiter">:</span> <span class="classifier">&#8216;&gt;i1&#8217;,</span></dt>
<dd><p class="first last">&#8216;scale&#8217;    : 0.1,
&#8216;offset&#8217;   : 1000,
&#8216;metaKey1&#8217; : &#8216;meta value 1&#8217;,
&#8216;metaKey2&#8217; : &#8216;meta value 2&#8217;}}</p>
</dd>
</dl>
<p>dictionary sets parameters for band creation
&#8216;type&#8217; - string representation of data type in the output band
&#8216;scale&#8217; - sets scale_factor and applies scaling
&#8216;offset&#8217; - sets &#8216;scale_offset and applies offsetting
other entries (e.g. &#8216;units&#8217;: &#8216;K&#8217;) set other metadata</p>
</div></blockquote>
<p><strong>metadata</strong> : dict</p>
<blockquote>
<div><p>Glbal metadata to add</p>
</div></blockquote>
<p><strong>maskName: string;</strong></p>
<blockquote>
<div><p>if data include a mask band: give the mask name.
Non-masked value is 64.
if None: no mask is added</p>
</div></blockquote>
<p><strong>rmMetadata</strong> : list</p>
<blockquote>
<div><p>unwanted metadata names which will be removed</p>
</div></blockquote>
<p><strong>time</strong> : list with datetime objects</p>
<blockquote>
<div><p>aqcuisition time of original data. That value will be in time dim</p>
</div></blockquote>
<p><strong>createdTime</strong> : datetime</p>
<blockquote class="last">
<div><p>date of creation. Will be in metadata &#8216;created&#8217;</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>n.export2thredds(filename)
# create THREDDS formatted netcdf file with all bands and time variable</p>
<p>n.export2thredds(filename, [1], {&#8216;description&#8217;: &#8216;example&#8217;})
# export only the first band and add global metadata</p>
</dd></dl>

<dl class="method">
<dt id="nansat.mosaic.Mosaic.get_GDALRasterBand">
<tt class="descname">get_GDALRasterBand</tt><big>(</big><em>bandID=1</em><big>)</big><a class="headerlink" href="#nansat.mosaic.Mosaic.get_GDALRasterBand" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a GDALRasterBand of a given Nansat object</p>
<p>If str is given find corresponding band number
If int is given check if band with this number exists.
Get a GDALRasterBand from vrt.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>bandID</strong> : serial number or string, optional (default is 1)</p>
<blockquote>
<div><p>if number - a band number of the band to fetch
if string bandID = {&#8216;name&#8217;: bandID}</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">GDAL RasterBand</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.mosaic.Mosaic.get_border">
<tt class="descname">get_border</tt><big>(</big><em>nPoints=10</em><big>)</big><a class="headerlink" href="#nansat.mosaic.Mosaic.get_border" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate two vectors with values of lat/lon for the border of domain</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>nPoints</strong> : int, optional</p>
<blockquote>
<div><p>Number of points on each border</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>lonVec, latVec</strong> : lists</p>
<blockquote class="last">
<div><p>vectors with lon/lat values for each point at the border</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.mosaic.Mosaic.get_border_geometry">
<tt class="descname">get_border_geometry</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.mosaic.Mosaic.get_border_geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Get OGR Geometry of the border Polygon</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">OGR Geometry, type Polygon</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.mosaic.Mosaic.get_border_postgis">
<tt class="descname">get_border_postgis</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.mosaic.Mosaic.get_border_postgis" title="Permalink to this definition">¶</a></dt>
<dd><p>Get PostGIS formatted string of the border Polygon</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>str</strong> : &#8216;PolygonFromText(PolygonWKT)&#8217;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.mosaic.Mosaic.get_border_wkt">
<tt class="descname">get_border_wkt</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.mosaic.Mosaic.get_border_wkt" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates string with WKT representation of the border polygon</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>WKTPolygon</strong> : string</p>
<blockquote class="last">
<div><p>string with WKT representation of the border polygon</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.mosaic.Mosaic.get_corners">
<tt class="descname">get_corners</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.mosaic.Mosaic.get_corners" title="Permalink to this definition">¶</a></dt>
<dd><p>Get coordinates of corners of the Domain</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>lonVec, latVec</strong> : lists</p>
<blockquote class="last">
<div><p>vectors with lon/lat values for each corner</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.mosaic.Mosaic.get_geolocation_grids">
<tt class="descname">get_geolocation_grids</tt><big>(</big><em>stepSize=1</em><big>)</big><a class="headerlink" href="#nansat.mosaic.Mosaic.get_geolocation_grids" title="Permalink to this definition">¶</a></dt>
<dd><p>Get longitude and latitude grids representing the full data grid</p>
<p>If GEOLOCATION is not present in the self.vrt.dataset then grids
are generated by converting pixel/line of each pixel into lat/lon
If GEOLOCATION is present in the self.vrt.dataset then grids are read
from the geolocation bands.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>stepSize</strong> : int</p>
<blockquote>
<div><p>Reduction factor if output is desired on a reduced grid size</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>longitude</strong> : numpy array</p>
<blockquote>
<div><p>grid with longitudes</p>
</div></blockquote>
<p><strong>latitude</strong> : numpy array</p>
<blockquote class="last">
<div><p>grid with latitudes</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.mosaic.Mosaic.get_metadata">
<tt class="descname">get_metadata</tt><big>(</big><em>key=None</em>, <em>bandID=None</em><big>)</big><a class="headerlink" href="#nansat.mosaic.Mosaic.get_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Get metadata from self.vrt.dataset</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>key</strong> : string, optional</p>
<blockquote>
<div><p>name of the metadata key. If not givem all metadata is returned</p>
</div></blockquote>
<p><strong>bandID</strong> : int or str, optional</p>
<blockquote>
<div><p>number or name of band to get metadata from.
If not given, global metadata is returned</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">a string with metadata if key is given and found</p>
<p>an empty string if key is given and not found</p>
<p class="last">a dictionary with all metadata if key is not given</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.mosaic.Mosaic.get_pixelsize_meters">
<tt class="descname">get_pixelsize_meters</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.mosaic.Mosaic.get_pixelsize_meters" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pixelsize (deltaX, deltaY) of the domain</p>
<p>For projected domains, the exact result which is constant
over the domain is returned.
For geographic (lon-lat) projections, or domains with no geotransform,
the haversine formula is used to calculate the pixel size
in the center of the domain.
Returns
&#8212;&#8212;&#8211;
deltaX, deltaY : float
pixel size in X and Y directions given in meters</p>
</dd></dl>

<dl class="method">
<dt id="nansat.mosaic.Mosaic.get_time">
<tt class="descname">get_time</tt><big>(</big><em>bandID=None</em><big>)</big><a class="headerlink" href="#nansat.mosaic.Mosaic.get_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Get time for dataset and/or its bands</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>bandID</strong> : int or str (default = None)</p>
<blockquote>
<div><p>band number or name</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>time</strong> : list with datetime objects for each band.</p>
<blockquote class="last">
<div><p>If time is the same for all bands, the list contains 1 item</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.mosaic.Mosaic.get_transect">
<tt class="descname">get_transect</tt><big>(</big><em>points=None, bandList=[1], latlon=True, returnOGR=False, layerNum=0, smoothRadius=0, smoothAlg=0, transect=True, onlypixline=False, **kwargs</em><big>)</big><a class="headerlink" href="#nansat.mosaic.Mosaic.get_transect" title="Permalink to this definition">¶</a></dt>
<dd><p>Get transect from two poins and retun the values by numpy array</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>points</strong> : list with one or more points or shape file name</p>
<blockquote>
<div><dl class="docutils">
<dt>i.e. [</dt>
<dd><blockquote class="first">
<div><p># get all transect values
[(lon_T1, lat_T1), (lon_T2, lat_T2), (lon_T3, lat_T3), ...]
# get point values
(lon_P1, lat_P1), (lon_P2, lat_P2), ...</p>
</div></blockquote>
<p>]
or
[</p>
<blockquote>
<div><p># get all transect values
[(col_T1, row_T1), (col_T2, row_T2), (col_T3, row_T3), ...],
# get point values
(col_P1, row_P1), (col_P2, row_P2), ...</p>
</div></blockquote>
<p class="last">]</p>
</dd>
</dl>
</div></blockquote>
<p><strong>bandList</strong> : list of int or string</p>
<blockquote>
<div><p>elements of the list are band number or band Name</p>
</div></blockquote>
<p><strong>latlon</strong> : bool</p>
<blockquote>
<div><p>If the points in lat/lon, then True.
If the points in pixel/line, then False.</p>
</div></blockquote>
<p><strong>returnOGR: bool</strong></p>
<blockquote>
<div><p>If True, then return numpy array
If False, return OGR object</p>
</div></blockquote>
<p><strong>layerNum: int</strong></p>
<blockquote>
<div><p>If shapefile is given as points, it is the number of the layer</p>
</div></blockquote>
<p><strong>smoothRadius: int</strong></p>
<blockquote>
<div><p>If smootRadius is greater than 0, smooth every transect
pixel as the median or mean value in a circule with radius
equal to the given number.</p>
</div></blockquote>
<p><strong>smoothAlg: 0 or 1 for median or mean</strong></p>
<p><strong>transect</strong> : bool</p>
<blockquote>
<div><p>used if a shape file name is given as the input.
If True, return the transect. If False, return the points.</p>
</div></blockquote>
<p><strong>vmin, vmax</strong> : int (optional)</p>
<blockquote>
<div><p>minimum and maximum pixel values of an image shown
in case points is None.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">if returnOGR:</p>
<blockquote>
<div><p>transect : OGR object with points coordinates and values</p>
</div></blockquote>
<p>else:</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>transectDict: dictionary</dt>
<dd><p class="first last">key is band name.
Value is a dictionary of the transect values of each shape.</p>
</dd>
<dt>vectorsDict: dictionary</dt>
<dd><p class="first last">keys are shape ID. values are dictionaries
with longitude and latitude lists of each shape.</p>
</dd>
<dt>pixlinCoordDic: dictionary</dt>
<dd><p class="first last">keys are shape ID. values are numpy array
with pixels and lines coordinates</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.mosaic.Mosaic.has_band">
<tt class="descname">has_band</tt><big>(</big><em>band</em><big>)</big><a class="headerlink" href="#nansat.mosaic.Mosaic.has_band" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if self has band with name &lt;band&gt;
Parameters
&#8212;&#8212;&#8212;-</p>
<blockquote>
<div><dl class="docutils">
<dt>band <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>name of the band to check</dd>
</dl>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">True/False if band exists or not</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.mosaic.Mosaic.latest">
<tt class="descname">latest</tt><big>(</big><em>files=[], bands=[1], doReproject=True, maskName='mask', **kwargs</em><big>)</big><a class="headerlink" href="#nansat.mosaic.Mosaic.latest" title="Permalink to this definition">¶</a></dt>
<dd><p>Mosaic by adding the latest image on top without averaging</p>
<p>Uses Nansat.get_time() to estimate time of each input file;
Sorts images by aquisition time;
Creates date_index band - with mask of coverage of each frame;
Uses date_index to fill bands of self only with the latest data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>files</strong> : list</p>
<blockquote>
<div><p>list of input files</p>
</div></blockquote>
<p><strong>bands</strong> : list</p>
<blockquote>
<div><p>list of names/band_numbers to be processed</p>
</div></blockquote>
<p><strong>doReproject</strong> : boolean, [True]</p>
<blockquote>
<div><p>reproject input files?</p>
</div></blockquote>
<p><strong>maskName</strong> : str, [&#8216;mask&#8217;]</p>
<blockquote>
<div><p>name of the mask in input files</p>
</div></blockquote>
<p><strong>nClass</strong> : child of Nansat, [Nansat]</p>
<blockquote>
<div><p>This class is used to read input files</p>
</div></blockquote>
<p><strong>eResampleAlg</strong> : int, [0]</p>
<blockquote>
<div><p>agorithm for reprojection, see Nansat.reproject()</p>
</div></blockquote>
<p><strong>period</strong> : [datetime0, datetime1]</p>
<blockquote class="last">
<div><p>Start and stop datetime objects from pyhon datetime.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.mosaic.Mosaic.list_bands">
<tt class="descname">list_bands</tt><big>(</big><em>doPrint=True</em><big>)</big><a class="headerlink" href="#nansat.mosaic.Mosaic.list_bands" title="Permalink to this definition">¶</a></dt>
<dd><p>Show band information of the given Nansat object</p>
<p>Show serial number, longName, name and all parameters
for each band in the metadata of the given Nansat object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>doPrint</strong> : boolean, optional, default=True</p>
<blockquote>
<div><p>do print, otherwise it is returned as string</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>outString</strong> : String</p>
<blockquote class="last">
<div><p>formatted string with bands info</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.mosaic.Mosaic.median">
<tt class="descname">median</tt><big>(</big><em>files=[], bands=[1], doReproject=True, maskName='mask', **kwargs</em><big>)</big><a class="headerlink" href="#nansat.mosaic.Mosaic.median" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate median of input bands</p>
<p>Memory and CPU greedy method. Generates 3D cube from bands of
all input images and calculates median. Adds median bands to self</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>files</strong> : list</p>
<blockquote>
<div><p>list of input files</p>
</div></blockquote>
<p><strong>bands</strong> : list</p>
<blockquote>
<div><p>list of names/band_numbers to be processed</p>
</div></blockquote>
<p><strong>doReproject</strong> : boolean, [True]</p>
<blockquote>
<div><p>reproject input files?</p>
</div></blockquote>
<p><strong>maskName</strong> : str, [&#8216;mask&#8217;]</p>
<blockquote>
<div><p>name of the mask in input files</p>
</div></blockquote>
<p><strong>nClass</strong> : child of Nansat, [Nansat]</p>
<blockquote>
<div><p>This class is used to read input files</p>
</div></blockquote>
<p><strong>eResampleAlg</strong> : int, [0]</p>
<blockquote>
<div><p>agorithm for reprojection, see Nansat.reproject()</p>
</div></blockquote>
<p><strong>period</strong> : [datetime0, datetime1]</p>
<blockquote class="last">
<div><p>Start and stop datetime objects from pyhon datetime.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="nansat.mosaic.Mosaic.nClass">
<tt class="descname">nClass</tt><a class="headerlink" href="#nansat.mosaic.Mosaic.nClass" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">Nansat</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="nansat.mosaic.Mosaic.reproject">
<tt class="descname">reproject</tt><big>(</big><em>dstDomain=None</em>, <em>eResampleAlg=0</em>, <em>blockSize=None</em>, <em>WorkingDataType=None</em>, <em>tps=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.mosaic.Mosaic.reproject" title="Permalink to this definition">¶</a></dt>
<dd><p>Change projection of the object based on the given Domain</p>
<p>Create superVRT from self.vrt with AutoCreateWarpedVRT() using
projection from the dstDomain.
Modify XML content of the warped vrt using the Domain parameters.
Generate warpedVRT and replace self.vrt with warpedVRT.
If current object spans from 0 to 360 and dstDomain is west of 0,
the object is shifted by 180 westwards.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dstDomain</strong> : domain</p>
<blockquote>
<div><p>destination Domain where projection and resolution are set</p>
</div></blockquote>
<p><strong>eResampleAlg</strong> : int (GDALResampleAlg)</p>
<blockquote>
<div><p>0 : NearestNeighbour
1 : Bilinear
2 : Cubic,
3 : CubicSpline
4 : Lancoz</p>
</div></blockquote>
<p><strong>blockSize</strong> : int</p>
<blockquote>
<div><p>size of blocks for resampling. Large value decrease speed
but increase accuracy at the edge</p>
</div></blockquote>
<p><strong>WorkingDataType</strong> : int (GDT_int, ...)</p>
<blockquote>
<div><p>type of data in bands. Shuold be integer for int32 bands</p>
</div></blockquote>
<p><strong>tps</strong> : bool</p>
<blockquote>
<div><p>Apply Thin Spline Transformation if source or destination has GCPs
Usage of TPS can also be triggered by setting self.vrt.tps=True
before calling to reproject.
This options has priority over self.vrt.tps</p>
</div></blockquote>
<p><strong>skip_gcps</strong> : int</p>
<blockquote>
<div><p>Using TPS can be very slow if the number of GCPs are large.
If this parameter is given, only every [skip_gcp] GCP is used,
improving calculation time at the cost of accuracy.
If not given explicitly, &#8216;skip_gcps&#8217; is fetched from the
metadata of self, or from dstDomain (as set by mapper or user).
[defaults to 1 if not specified, i.e. using all GCPs]</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.vrt</strong> : VRT object with dataset replaced to warpedVRT dataset</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.mosaic.Mosaic.reproject_GCPs">
<tt class="descname">reproject_GCPs</tt><big>(</big><em>srsString</em><big>)</big><a class="headerlink" href="#nansat.mosaic.Mosaic.reproject_GCPs" title="Permalink to this definition">¶</a></dt>
<dd><p>Reproject all GCPs to a new spatial reference system</p>
<p>Necessary before warping an image if the given GCPs
are in a coordinate system which has a singularity
in (or near) the destination area (e.g. poles for lonlat GCPs)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>srsString</strong> : string</p>
<blockquote>
<div><p>SRS given as Proj4 string</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>Reprojects all GCPs to new SRS and updates GCPProjection</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.mosaic.Mosaic.resize">
<tt class="descname">resize</tt><big>(</big><em>factor=1</em>, <em>width=None</em>, <em>height=None</em>, <em>pixelsize=None</em>, <em>eResampleAlg=-1</em><big>)</big><a class="headerlink" href="#nansat.mosaic.Mosaic.resize" title="Permalink to this definition">¶</a></dt>
<dd><p>Proportional resize of the dataset.</p>
<p>The dataset is resized as (xSize*factor, ySize*factor)
If desired width, height or pixelsize is specified,
the scaling factor is calculated accordingly.
If GCPs are given in a dataset, they are also rewritten.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>factor</strong> : float, optional, default=1</p>
<blockquote>
<div><p>Scaling factor for width and height
&gt; 1 means increasing domain size
&lt; 1 means decreasing domain size</p>
</div></blockquote>
<p><strong>width</strong> : int, optional</p>
<blockquote>
<div><p>Desired new width in pixels</p>
</div></blockquote>
<p><strong>height</strong> : int, optional</p>
<blockquote>
<div><p>Desired new height in pixels</p>
</div></blockquote>
<p><strong>pixelsize</strong> : float, optional</p>
<blockquote>
<div><p>Desired new pixelsize in meters (approximate).
A factor is calculated from ratio of the
current pixelsize to the desired pixelsize.</p>
</div></blockquote>
<p><strong>eResampleAlg</strong> : int (GDALResampleAlg), optional</p>
<blockquote>
<div><dl class="docutils">
<dt>-1 <span class="classifier-delimiter">:</span> <span class="classifier">Average (default),</span></dt>
<dd><p class="first last">0 : NearestNeighbour
1 : Bilinear,
2 : Cubic,
3 : CubicSpline,
4 : Lancoz</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.vrt.dataset</strong> : VRT dataset of VRT object</p>
<blockquote class="last">
<div><p>raster size are modified to downscaled size.
If GCPs are given in the dataset, they are also overwritten.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.mosaic.Mosaic.set_metadata">
<tt class="descname">set_metadata</tt><big>(</big><em>key=''</em>, <em>value=''</em>, <em>bandID=None</em><big>)</big><a class="headerlink" href="#nansat.mosaic.Mosaic.set_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Set metadata to self.vrt.dataset</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>key</strong> : string or dictionary with strings</p>
<blockquote>
<div><p>name of the metadata, or dictionary with metadata names, values</p>
</div></blockquote>
<p><strong>value</strong> : string</p>
<blockquote>
<div><p>value of metadata</p>
</div></blockquote>
<p><strong>bandID</strong> : int or str</p>
<blockquote>
<div><p>number or name of band
Without : global metadata is set</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.vrt.dataset</strong> : sets metadata in GDAL current dataset</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.mosaic.Mosaic.shape">
<tt class="descname">shape</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.mosaic.Mosaic.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Numpy-like shape of Domain object (ySize, xSize)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>shape</strong> : tuple of two INT</p>
<blockquote class="last">
<div><p>Numpy-like shape of Domain object (ySize, xSize)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.mosaic.Mosaic.transform_points">
<tt class="descname">transform_points</tt><big>(</big><em>colVector</em>, <em>rowVector</em>, <em>DstToSrc=0</em><big>)</big><a class="headerlink" href="#nansat.mosaic.Mosaic.transform_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform given lists of X,Y coordinates into lon/lat or inverse</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>colVector</strong> : lists</p>
<blockquote>
<div><p>X and Y coordinates in pixel/line or lon/lat  coordinate system</p>
</div></blockquote>
<p><strong>DstToSrc</strong> : 0 or 1</p>
<blockquote>
<div><p>0 - forward transform (pix/line =&gt; lon/lat)
1 - inverse transformation</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>X, Y</strong> : lists</p>
<blockquote class="last">
<div><p>X and Y coordinates in lon/lat or pixel/line coordinate system</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.mosaic.Mosaic.undo">
<tt class="descname">undo</tt><big>(</big><em>steps=1</em><big>)</big><a class="headerlink" href="#nansat.mosaic.Mosaic.undo" title="Permalink to this definition">¶</a></dt>
<dd><p>Undo reproject, resize, add_band or crop of Nansat object</p>
<p>Restore the self.vrt from self.vrt.vrt</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>steps</strong> : int</p>
<blockquote>
<div><p>How many steps back to undo</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.vrt</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.mosaic.Mosaic.watermask">
<tt class="descname">watermask</tt><big>(</big><em>mod44path=None</em>, <em>dstDomain=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.mosaic.Mosaic.watermask" title="Permalink to this definition">¶</a></dt>
<dd><p>Create numpy array with watermask (water=1, land=0)</p>
<p>250 meters resolution watermask from MODIS 44W Product:
<a class="reference external" href="http://www.glcf.umd.edu/data/watermask/">http://www.glcf.umd.edu/data/watermask/</a></p>
<p>Watermask is stored as tiles in TIF(LZW) format and a VRT file
All files are stored in one directory.
A tarball with compressed TIF and VRT files should be additionally
downloaded from the Nansat wiki:
<a class="reference external" href="https://svn.nersc.no/nansat/wiki/Nansat/Data/Watermask">https://svn.nersc.no/nansat/wiki/Nansat/Data/Watermask</a></p>
<dl class="docutils">
<dt>The method :</dt>
<dd>Gets the directory either from input parameter or from environment
variable MOD44WPATH
Open Nansat object from the VRT file
Reprojects the watermask onto the current object using reproject()
or reproject_on_jcps()
Returns the reprojected Nansat object</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mod44path</strong> : string, optional, default=None</p>
<blockquote>
<div><p>path with MOD44W Products and a VRT file</p>
</div></blockquote>
<p><strong>dstDomain</strong> : Domain</p>
<blockquote>
<div><p>destination domain other than self</p>
</div></blockquote>
<p><strong>tps</strong> : Bool</p>
<blockquote>
<div><p>Use Thin Spline Transformation in reprojection of watermask?
See also Nansat.reproject()</p>
</div></blockquote>
<p><strong>skip_gcps</strong> : int</p>
<blockquote>
<div><p>Factor to reduce the number of GCPs by and increase speed
See also Nansat.reproject()</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>watermask</strong> : Nansat object with water mask in current projection</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.mosaic.Mosaic.write_figure">
<tt class="descname">write_figure</tt><big>(</big><em>fileName=None</em>, <em>bands=1</em>, <em>clim=None</em>, <em>addDate=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.mosaic.Mosaic.write_figure" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a raster band to a figure in graphical format.</p>
<p>Get numpy array from the band(s) and band information specified
either by given band number or band id.
&#8211; If three bands are given, merge them and create PIL image.
&#8211; If one band is given, create indexed image
Create Figure object and:
Adjust the array brightness and contrast using the given min/max or
histogram.
Apply logarithmic scaling of color tone.
Generate and append legend.
Save the PIL output image in PNG or any other graphical format.
If the filename extension is &#8216;tif&#8217;, the figure file is converted
to GeoTiff</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : string, optional</p>
<blockquote>
<div><p>Output file name. if one of extensions &#8216;png&#8217;, &#8216;PNG&#8217;, &#8216;tif&#8217;,
&#8216;TIF&#8217;, &#8216;bmp&#8217;, &#8216;BMP&#8217;, &#8216;jpg&#8217;, &#8216;JPG&#8217;, &#8216;jpeg&#8217;, &#8216;JPEG&#8217; is included,
specified file is crated. otherwise, &#8216;png&#8217; file is created.
if None, the figure object is returned.
if True, the figure is shown</p>
</div></blockquote>
<p><strong>bands</strong> : integer or string or list (elements are integer or string),</p>
<blockquote>
<div><p>default = 1
the size of the list has to be 1 or 3.
if the size is 3, RGB image is created based on the three bands.
Then the first element is Red, the second is Green,
and the third is Blue.</p>
</div></blockquote>
<p><strong>clim</strong> : list with two elements or &#8216;hist&#8217; to specify range of colormap</p>
<blockquote>
<div><p>None (default) : min/max values are fetched from WKV,
fallback-&#8216;hist&#8217;
[min, max] : min and max are numbers, or
[[min, min, min], [max, max, max]]: three bands used
&#8216;hist&#8217; : a histogram is used to calculate min and max values</p>
</div></blockquote>
<p><strong>addDate</strong> : boolean</p>
<blockquote>
<div><p>False (default) : no date will be aded to the caption
True : the first time of the object will be added to the caption</p>
</div></blockquote>
<p><strong>**kwargs</strong> : parameters for Figure().</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>if fileName is specified, creates image file</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Figure object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.mosaic.Mosaic.write_geotiffimage">
<tt class="descname">write_geotiffimage</tt><big>(</big><em>fileName</em>, <em>bandID=1</em><big>)</big><a class="headerlink" href="#nansat.mosaic.Mosaic.write_geotiffimage" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes an 8-bit GeoTiff image for a given band.</p>
<p>The output GeoTiff image is convenient e.g. for display in a GIS tool.
Colormap is fetched from the metadata item &#8216;colormap&#8217;.</p>
<blockquote>
<div>Fallback colormap is &#8216;jet&#8217;.</div></blockquote>
<dl class="docutils">
<dt>Color limits are fetched from the metadata item &#8216;minmax&#8217;.</dt>
<dd>If &#8216;minmax&#8217; is not specified, min and max of raster is used.</dd>
</dl>
<p>The method can be replaced by using nansat.write_figure(),
however, write_figure uses PIL which does not allow
Tiff compression, giving much larger files</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : string</p>
<p class="last"><strong>bandID</strong> : integer or string(default = 1)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.mosaic.Mosaic.write_kml">
<tt class="descname">write_kml</tt><big>(</big><em>xmlFileName=None</em>, <em>kmlFileName=None</em><big>)</big><a class="headerlink" href="#nansat.mosaic.Mosaic.write_kml" title="Permalink to this definition">¶</a></dt>
<dd><p>Write KML file with domains</p>
<p>Convert XML-file with domains into KML-file for GoogleEarth
or write KML-file with the current Domain</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xmlFileName</strong> : string, optional</p>
<blockquote>
<div><p>Name of the XML-file to convert. If only this value is given
- kmlFileName=xmlFileName+&#8217;.kml&#8217;</p>
</div></blockquote>
<p><strong>kmlFileName</strong> : string, optional</p>
<blockquote class="last">
<div><p>Name of the KML-file to generate from the current Domain</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.mosaic.Mosaic.write_kml_image">
<tt class="descname">write_kml_image</tt><big>(</big><em>kmlFileName=None</em>, <em>kmlFigureName=None</em><big>)</big><a class="headerlink" href="#nansat.mosaic.Mosaic.write_kml_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Create KML file for already projected image</p>
<p>Write Domain Image into KML-file for GoogleEarth</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>kmlFileName</strong> : string, optional</p>
<blockquote>
<div><p>Name of the KML-file to generate from the current Domain</p>
</div></blockquote>
<p><strong>kmlFigureName</strong> : string, optional</p>
<blockquote class="last">
<div><p>Name of the projected image stored in .png format</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<dl class="docutils">
<dt># First of all, reproject an image into Lat/Lon WGS84</dt>
<dd>(Simple Cylindrical) projection</dd>
</dl>
<p># 1. Cancel previous reprojection
# 2. Get corners of the image and the pixel resolution
# 3. Create Domain with stereographic projection,
#    corner coordinates and resolution 1000m
# 4. Reproject
# 5. Write image
# 6. Write KML for the image
n.reproject() # 1.
lons, lats = n.get_corners() # 2.
srsString = &#8216;+proj=latlong +datum=WGS84 +ellps=WGS84 +no_defs&#8217;
extentString = &#8216;-lle %f %f %f %f -ts 3000 3000&#8217;
% (min(lons), min(lats), max(lons), max(lats))
d = Domain(srs=srsString, ext=extentString) # 3.
n.reproject(d) # 4.
n.write_figure(fileName=figureName, bands=[3], clim=[0,0.15],</p>
<blockquote>
<div>cmapName=&#8217;gray&#8217;, transparency=0) # 5.</div></blockquote>
<dl class="docutils">
<dt>n.write_kml_image(kmlFileName=oPath + fileName + &#8216;.kml&#8217;,</dt>
<dd>kmlFigureName=figureName) # 6.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nansat.mosaic.Mosaic.write_map">
<tt class="descname">write_map</tt><big>(</big><em>outputFileName, lonVec=None, latVec=None, lonBorder=10.0, latBorder=10.0, figureSize=(6, 6), dpi=50, projection='cyl', resolution='c', continetsColor='coral', meridians=10, parallels=10, pColor='r', pLine='k', pAlpha=0.5, padding=0.0, merLabels=[False, False, False, False], parLabels=[False, False, False, False], pltshow=False</em><big>)</big><a class="headerlink" href="#nansat.mosaic.Mosaic.write_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an image with a map of the domain</p>
<p>Uses Basemap to create a World Map
Adds a semitransparent patch with outline of the Domain
Writes to an image file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>outputFileName</strong> : string</p>
<blockquote>
<div><p>name of the output file name</p>
</div></blockquote>
<p><strong>lonBorder</strong> : float</p>
<blockquote>
<div><p>10, horisontal border around patch (degrees of longitude)</p>
</div></blockquote>
<p><strong>latBorder</strong> : float</p>
<blockquote>
<div><p>10, vertical border around patch (degrees of latitude)</p>
</div></blockquote>
<p><strong>figureSize</strong> : tuple of two integers</p>
<blockquote>
<div><p>(6, 6), size of the generated figure in inches</p>
</div></blockquote>
<p><strong>dpi: int</strong></p>
<blockquote>
<div><p>50, resolution of the output figure (size 6,6 and dpi 50
produces 300 x 300 figure)</p>
</div></blockquote>
<p><strong>projection</strong> : string, one of Basemap projections</p>
<blockquote>
<div><p>&#8216;cyl&#8217;, projection of the map</p>
</div></blockquote>
<p><strong>resolution</strong> : string, resolution of the map</p>
<blockquote>
<div><p>&#8216;c&#8217;, crude
&#8216;l&#8217;, low
&#8216;i&#8217;, intermediate
&#8216;h&#8217;, high
&#8216;f&#8217;, full</p>
</div></blockquote>
<p><strong>continetsColor</strong> : string or any matplotlib color representation</p>
<blockquote>
<div><p>&#8216;coral&#8217;, color of continets</p>
</div></blockquote>
<p><strong>meridians</strong> : int</p>
<blockquote>
<div><p>10, number of meridians to draw</p>
</div></blockquote>
<p><strong>parallels</strong> : int</p>
<blockquote>
<div><p>10, number of parallels to draw</p>
</div></blockquote>
<p><strong>pColor</strong> : string or any matplotlib color representation</p>
<blockquote>
<div><p>&#8216;r&#8217;, color of the Domain patch</p>
</div></blockquote>
<p><strong>pLine</strong> : string or any matplotlib color representation</p>
<blockquote>
<div><p>&#8216;k&#8217;, color of the Domain outline</p>
</div></blockquote>
<p><strong>pAlpha</strong> : float 0 - 1</p>
<blockquote>
<div><p>0.5, transparency of Domain patch</p>
</div></blockquote>
<p><strong>padding</strong> : float</p>
<blockquote>
<div><p>0., width of white padding around the map</p>
</div></blockquote>
<p><strong>merLabels</strong> : list of 4 booleans</p>
<blockquote>
<div><p>where to put meridian labels, see also Basemap.drawmeridians()</p>
</div></blockquote>
<p><strong>parLables</strong> : list of 4 booleans</p>
<blockquote class="last">
<div><p>where to put parallel labels, see also Basemap.drawparallels()</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>

    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2013, Nansen Center.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.3.
      </li>
    </ul>
    </div>
    </div>
    </div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-43252602-1', 'nansencenter.github.io');
  ga('send', 'pageview');

</script>

  </body>
</html>