<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>nansat package &mdash; Nansat 0.1 documentation</title>
    
    <link rel="stylesheet" type="text/css" href="_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="_static/css/spc-extend.css">
    <link rel="stylesheet" href="_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" >
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-43252602-1', 'nansencenter.github.io');
  ga('send', 'pageview');

</script>    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/js/copybutton.js"></script>
    <link rel="top" title="Nansat 0.1 documentation" href="index.html" > 
  </head>
  <body>

<div class="container">
  <div class="top-scipy-org-logo-header">
    <a href="index.html">
      <img style="border: 0;" alt="SciPy" src="_static/img/nansat_logo.gif"></a>
    </div>
  </div>
</div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
	
        <li class="active"><a href="index.html">Nansat 0.1 documentation</a></li>
	 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <div class="section" id="nansat-package">
<h1>nansat package<a class="headerlink" href="#nansat-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="nansat.domain.html">nansat.domain module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="nansat.figure.html">nansat.figure module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="nansat.geolocationarray.html">nansat.geolocationarray module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="nansat.mosaic.html">nansat.mosaic module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="nansat.nansat.html">nansat.nansat module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="nansat.nansatmap.html">nansat.nansatmap module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="nansat.nansatshape.html">nansat.nansatshape module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="nansat.vrt.html">nansat.vrt module</a><ul class="simple">
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="module-nansat">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-nansat" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nansat.Nansat">
<em class="property">class </em><tt class="descclassname">nansat.</tt><tt class="descname">Nansat</tt><big>(</big><em>fileName=''</em>, <em>mapperName=''</em>, <em>domain=None</em>, <em>array=None</em>, <em>parameters=None</em>, <em>logLevel=30</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansat" title="Permalink to this definition">¶</a></dt>
<dd><p>Create Nansat object</p>
<div class="line-block">
<div class="line">if &lt;fileName&gt; is given:</div>
<div class="line-block">
<div class="line">Open GDAL dataset,</div>
<div class="line">Read metadata,</div>
<div class="line">Generate GDAL VRT file with mapping of variables in memory</div>
<div class="line">Create logger</div>
<div class="line">Create Nansat object for perfroming high-level operations</div>
</div>
<div class="line">if &lt;domain&gt; and &lt;array&gt; are given:</div>
<div class="line-block">
<div class="line">Create VRT object from data in &lt;array&gt;</div>
<div class="line">Add geolocation from &lt;domain&gt;</div>
</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : string</p>
<blockquote>
<div><p>location of the file</p>
</div></blockquote>
<p><strong>mapperName</strong> : string, optional</p>
<blockquote>
<div><p>name of the mapper from nansat/mappers dir. E.g.
&#8216;ASAR&#8217;, &#8216;hirlam&#8217;, &#8216;merisL1&#8217;, &#8216;merisL2&#8217;, etc.</p>
</div></blockquote>
<p><strong>domain</strong> : Domain object</p>
<blockquote>
<div><p>Geo-reference of a new raster</p>
</div></blockquote>
<p><strong>array</strong> : numpy array</p>
<blockquote>
<div><p>Firts band of a new raster</p>
</div></blockquote>
<p><strong>parameters</strong> : dictionary</p>
<blockquote>
<div><p>Metadata for the 1st band of a new raster,e.g. name, wkv, units,...</p>
</div></blockquote>
<p><strong>logLevel</strong> : int, optional, default: logging.DEBUG (30)</p>
<blockquote>
<div><p>Level of logging. See: <a class="reference external" href="http://docs.python.org/howto/logging.html">http://docs.python.org/howto/logging.html</a></p>
</div></blockquote>
<p class="last"><strong>kwargs</strong> : additional arguments for mappers</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="89%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>mapperList</td>
<td>(list of file names) list of available working mappers</td>
</tr>
<tr class="row-even"><td>fileName</td>
<td>(file name) set file name given by the argument</td>
</tr>
<tr class="row-odd"><td>vrt</td>
<td>(VRT object) Wrapper around VRT file and GDAL dataset with satellite raster data</td>
</tr>
<tr class="row-even"><td>logger</td>
<td>(logging.Logger) logger for output debugging info</td>
</tr>
<tr class="row-odd"><td>name</td>
<td>(string) name of object (for writing KML)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansat.add_band" title="nansat.Nansat.add_band"><tt class="xref py py-obj docutils literal"><span class="pre">add_band</span></tt></a>(array[,&nbsp;parameters,&nbsp;nomem])</td>
<td>Add band from the array to self.vrt  Create VRT object which contains VRT and RAW binary file and append it to self.vrt.subVRTs  :Parameters:      <strong>array</strong> : Numpy array with band data                <strong>parameters</strong> : dictionary, band metadata: wkv, name, etc.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansat.azimuth_up" title="nansat.Nansat.azimuth_up"><tt class="xref py py-obj docutils literal"><span class="pre">azimuth_up</span></tt></a>([reductionFactor])</td>
<td>Calculate the azimuth of &#8216;upward&#8217; direction in each pixel  | Generaly speaking, azimuth is angle from the reference vector   (direction to North) to the chosen direction.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansat.bands" title="nansat.Nansat.bands"><tt class="xref py py-obj docutils literal"><span class="pre">bands</span></tt></a>()</td>
<td>Make a dictionary with all bands metadata</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansat.crop" title="nansat.Nansat.crop"><tt class="xref py py-obj docutils literal"><span class="pre">crop</span></tt></a>([xOff,&nbsp;yOff,&nbsp;xSize,&nbsp;ySize,&nbsp;lonlim,&nbsp;latlim])</td>
<td>Crop Nansat object  | Create superVRT, modify the Source Rectangle (SrcRect) and   Destination.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansat.export" title="nansat.Nansat.export"><tt class="xref py py-obj docutils literal"><span class="pre">export</span></tt></a>(fileName[,&nbsp;rmMetadata,&nbsp;...])</td>
<td>Export Nansat object into netCDF or GTiff file   :Parameters:      <strong>fileName</strong> : str          output file name      <strong>rmMetadata</strong> : list          | metadata names for removal before export.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansat.export_band" title="nansat.Nansat.export_band"><tt class="xref py py-obj docutils literal"><span class="pre">export_band</span></tt></a>(fileName[,&nbsp;bandID,&nbsp;driver])</td>
<td>Export only one band of the Nansat object</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansat.get_GDALRasterBand" title="nansat.Nansat.get_GDALRasterBand"><tt class="xref py py-obj docutils literal"><span class="pre">get_GDALRasterBand</span></tt></a>([bandID])</td>
<td>Get a GDALRasterBand of a given Nansat object  | If str is given find corresponding band number.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansat.get_border" title="nansat.Nansat.get_border"><tt class="xref py py-obj docutils literal"><span class="pre">get_border</span></tt></a>([nPoints])</td>
<td>Generate two vectors with values of lat/lon for the border of domain</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansat.get_border_geometry" title="nansat.Nansat.get_border_geometry"><tt class="xref py py-obj docutils literal"><span class="pre">get_border_geometry</span></tt></a>()</td>
<td>Get OGR Geometry of the border Polygon</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansat.get_border_postgis" title="nansat.Nansat.get_border_postgis"><tt class="xref py py-obj docutils literal"><span class="pre">get_border_postgis</span></tt></a>()</td>
<td>Get PostGIS formatted string of the border Polygon</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansat.get_border_wkt" title="nansat.Nansat.get_border_wkt"><tt class="xref py py-obj docutils literal"><span class="pre">get_border_wkt</span></tt></a>()</td>
<td>Creates string with WKT representation of the border polygon</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansat.get_corners" title="nansat.Nansat.get_corners"><tt class="xref py py-obj docutils literal"><span class="pre">get_corners</span></tt></a>()</td>
<td>Get coordinates of corners of the Domain</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansat.get_geolocation_grids" title="nansat.Nansat.get_geolocation_grids"><tt class="xref py py-obj docutils literal"><span class="pre">get_geolocation_grids</span></tt></a>([stepSize])</td>
<td>Get longitude and latitude grids representing the full data grid  | If GEOLOCATION is not present in the self.vrt.dataset then grids   are generated by converting pixel/line of each pixel into lat/lon | If GEOLOCATION is present in the self.vrt.dataset then grids are   read from the geolocation bands.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansat.get_metadata" title="nansat.Nansat.get_metadata"><tt class="xref py py-obj docutils literal"><span class="pre">get_metadata</span></tt></a>([key,&nbsp;bandID])</td>
<td>Get metadata from self.vrt.dataset   :Parameters:      <strong>key</strong> : string, optional          name of the metadata key.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansat.get_pixelsize_meters" title="nansat.Nansat.get_pixelsize_meters"><tt class="xref py py-obj docutils literal"><span class="pre">get_pixelsize_meters</span></tt></a>()</td>
<td>Returns the pixelsize (deltaX, deltaY) of the domain  | For projected domains, the exact result which is constant   over the domain is returned.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansat.get_time" title="nansat.Nansat.get_time"><tt class="xref py py-obj docutils literal"><span class="pre">get_time</span></tt></a>([bandID])</td>
<td>Get time for dataset and/or its bands   :Parameters:      <strong>bandID</strong> : int or str (default = None)          band number or name  :Returns:      <strong>time</strong> : list with datetime objects for each band.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansat.get_transect" title="nansat.Nansat.get_transect"><tt class="xref py py-obj docutils literal"><span class="pre">get_transect</span></tt></a>([points,&nbsp;bandList,&nbsp;latlon,&nbsp;...])</td>
<td>Get transect from two poins and retun the values by numpy array   :Parameters:      <strong>points</strong> : tuple with one or more points or shape file name          | i.e.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansat.has_band" title="nansat.Nansat.has_band"><tt class="xref py py-obj docutils literal"><span class="pre">has_band</span></tt></a>(band)</td>
<td>Check if self has band with name &lt;band&gt;</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansat.list_bands" title="nansat.Nansat.list_bands"><tt class="xref py py-obj docutils literal"><span class="pre">list_bands</span></tt></a>([doPrint])</td>
<td>Show band information of the given Nansat object  Show serial number, longName, name and all parameters for each band in the metadata of the given Nansat object.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansat.process" title="nansat.Nansat.process"><tt class="xref py py-obj docutils literal"><span class="pre">process</span></tt></a>([opts])</td>
<td>Default L2 processing of Nansat object.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansat.reproject" title="nansat.Nansat.reproject"><tt class="xref py py-obj docutils literal"><span class="pre">reproject</span></tt></a>([dstDomain,&nbsp;eResampleAlg,&nbsp;...])</td>
<td>Change projection of the object based on the given Domain  | Create superVRT from self.vrt with AutoCreateWarpedVRT() using   projection from the dstDomain.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansat.reproject_GCPs" title="nansat.Nansat.reproject_GCPs"><tt class="xref py py-obj docutils literal"><span class="pre">reproject_GCPs</span></tt></a>(srsString)</td>
<td>Reproject all GCPs to a new spatial reference system  | Necessary before warping an image if the given GCPs   are in a coordinate system which has a singularity   in (or near) the destination area (e.g.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansat.resize" title="nansat.Nansat.resize"><tt class="xref py py-obj docutils literal"><span class="pre">resize</span></tt></a>([factor,&nbsp;width,&nbsp;height,&nbsp;pixelsize,&nbsp;...])</td>
<td>Proportional resize of the dataset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansat.set_metadata" title="nansat.Nansat.set_metadata"><tt class="xref py py-obj docutils literal"><span class="pre">set_metadata</span></tt></a>([key,&nbsp;value,&nbsp;bandID])</td>
<td>Set metadata to self.vrt.dataset</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansat.shape" title="nansat.Nansat.shape"><tt class="xref py py-obj docutils literal"><span class="pre">shape</span></tt></a>()</td>
<td>Return Numpy-like shape of Domain object (ySize, xSize)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansat.transform_points" title="nansat.Nansat.transform_points"><tt class="xref py py-obj docutils literal"><span class="pre">transform_points</span></tt></a>(colVector,&nbsp;rowVector[,&nbsp;...])</td>
<td>Transform given lists of X,Y coordinates into lon/lat or inverse</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansat.undo" title="nansat.Nansat.undo"><tt class="xref py py-obj docutils literal"><span class="pre">undo</span></tt></a>([steps])</td>
<td>Undo reproject, resize, add_band or crop of Nansat object</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansat.upwards_azimuth_direction" title="nansat.Nansat.upwards_azimuth_direction"><tt class="xref py py-obj docutils literal"><span class="pre">upwards_azimuth_direction</span></tt></a>([orbit_direction])</td>
<td>Caluculate and return upwards azimuth direction of domain.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansat.watermask" title="nansat.Nansat.watermask"><tt class="xref py py-obj docutils literal"><span class="pre">watermask</span></tt></a>([mod44path,&nbsp;dstDomain])</td>
<td>Create numpy array with watermask (water=1, land=0)  | 250 meters resolution watermask from MODIS 44W Product: | <a class="reference external" href="http://www.glcf.umd.edu/data/watermask/">http://www.glcf.umd.edu/data/watermask/</a> | Watermask is stored as tiles in TIF(LZW) format and a VRT file.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansat.write_figure" title="nansat.Nansat.write_figure"><tt class="xref py py-obj docutils literal"><span class="pre">write_figure</span></tt></a>([fileName,&nbsp;bands,&nbsp;clim,&nbsp;addDate])</td>
<td>Save a raster band to a figure in graphical format.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansat.write_geotiffimage" title="nansat.Nansat.write_geotiffimage"><tt class="xref py py-obj docutils literal"><span class="pre">write_geotiffimage</span></tt></a>(fileName[,&nbsp;bandID])</td>
<td>Writes an 8-bit GeoTiff image for a given band.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansat.write_kml" title="nansat.Nansat.write_kml"><tt class="xref py py-obj docutils literal"><span class="pre">write_kml</span></tt></a>([xmlFileName,&nbsp;kmlFileName])</td>
<td>Write KML file with domains  Convert XML-file with domains into KML-file for GoogleEarth or write KML-file with the current Domain  :Parameters:      <strong>xmlFileName</strong> : string, optional          Name of the XML-file to convert.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansat.write_kml_image" title="nansat.Nansat.write_kml_image"><tt class="xref py py-obj docutils literal"><span class="pre">write_kml_image</span></tt></a>([kmlFileName,&nbsp;kmlFigureName])</td>
<td>Create KML file for already projected image  Write Domain Image into KML-file for GoogleEarth  :Parameters:      <strong>kmlFileName</strong> : string, optional          Name of the KML-file to generate from the current Domain      <strong>kmlFigureName</strong> : string, optional          Name of the projected image stored in .png format  ..</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansat.write_map" title="nansat.Nansat.write_map"><tt class="xref py py-obj docutils literal"><span class="pre">write_map</span></tt></a>(outputFileName[,&nbsp;lonVec,&nbsp;latVec,&nbsp;...])</td>
<td>Create an image with a map of the domain  | Uses Basemap to create a World Map.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nansat.Nansat.add_band">
<tt class="descname">add_band</tt><big>(</big><em>array</em>, <em>parameters=None</em>, <em>nomem=False</em><big>)</big><a class="headerlink" href="#nansat.Nansat.add_band" title="Permalink to this definition">¶</a></dt>
<dd><p>Add band from the array to self.vrt</p>
<p>Create VRT object which contains VRT and RAW binary file and append
it to self.vrt.subVRTs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>array</strong> : Numpy array with band data</p>
<p><strong>parameters</strong> : dictionary, band metadata: wkv, name, etc.</p>
<p><strong>nomem</strong> : boolean, saves the vrt to a tempfile if nomem is True</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Creates:</th><td class="field-body"><p class="first"><strong>VRT object</strong> : VRT object with VRT-file and RAW-file</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.vrt</strong> : Add a band</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.azimuth_up">
<tt class="descname">azimuth_up</tt><big>(</big><em>reductionFactor=1</em><big>)</big><a class="headerlink" href="#nansat.Nansat.azimuth_up" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the azimuth of &#8216;upward&#8217; direction in each pixel</p>
<div class="line-block">
<div class="line">Generaly speaking, azimuth is angle from the reference vector
(direction to North) to the chosen direction. Azimuth increases
clockwise from direction to North.
<a class="reference external" href="http://en.wikipedia.org/wiki/Azimuth">http://en.wikipedia.org/wiki/Azimuth</a></div>
<div class="line">Here we calcluate azimuth of &#8216;upward&#8217; direction.
&#8216;Upward&#8217; direction coincides with Y-axis direction (and hence is
opposite to the ROW-axis direction). For lon-lat (cylindrical,
Plate Caree) and Mercator projections &#8216;upward&#8217; direction coincides
with direction to North, hence azimuth is 0.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reductionFactor</strong> : integer</p>
<blockquote>
<div><p>factor by which the size of the output array is reduced</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>azimuth</strong> : numpy array</p>
<blockquote class="last">
<div><p>Values of azimuth in degrees in range 0 - 360</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.bands">
<tt class="descname">bands</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Nansat.bands" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a dictionary with all bands metadata</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>b</strong> : dictionary</p>
<blockquote class="last">
<div><p>key = N, value = dict with all band metadata</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.crop">
<tt class="descname">crop</tt><big>(</big><em>xOff=0</em>, <em>yOff=0</em>, <em>xSize=None</em>, <em>ySize=None</em>, <em>lonlim=None</em>, <em>latlim=None</em><big>)</big><a class="headerlink" href="#nansat.Nansat.crop" title="Permalink to this definition">¶</a></dt>
<dd><p>Crop Nansat object</p>
<div class="line-block">
<div class="line">Create superVRT, modify the Source Rectangle (SrcRect) and
Destination.</div>
<div class="line">Rectangle (DstRect) tags in the VRT file for each band in order
to take only part of the original image, create new GCPs or
new GeoTransform for the cropped object.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xOff</strong> : int</p>
<blockquote>
<div><p>pixel offset of subimage</p>
</div></blockquote>
<p><strong>yOff</strong> : int</p>
<blockquote>
<div><p>line offset of subimage</p>
</div></blockquote>
<p><strong>xSize</strong> : int</p>
<blockquote>
<div><p>width in pixels of subimage</p>
</div></blockquote>
<p><strong>ySize</strong> : int</p>
<blockquote>
<div><p>height in pizels of subimage</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Creates:</th><td class="field-body"><p class="first"><strong>superVRT</strong> : VRT with modified SrcRect and DstRect</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.vrt</strong> : VRT</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>status</strong> : int</p>
<blockquote class="last">
<div><div class="line-block">
<div class="line">0 - everyhting is OK, image is cropped</div>
<div class="line">1 - if crop is totally outside, image is NOT cropped</div>
<div class="line">2 - crop area is too large and crop is not needed</div>
</div>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.export">
<tt class="descname">export</tt><big>(</big><em>fileName</em>, <em>rmMetadata=</em>, <span class="optional">[</span><span class="optional">]</span><em>addGeolocArray=True</em>, <em>addGCPs=True</em>, <em>driver='netCDF'</em>, <em>bottomup=False</em><big>)</big><a class="headerlink" href="#nansat.Nansat.export" title="Permalink to this definition">¶</a></dt>
<dd><p>Export Nansat object into netCDF or GTiff file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : str</p>
<blockquote>
<div><p>output file name</p>
</div></blockquote>
<p><strong>rmMetadata</strong> : list</p>
<blockquote>
<div><div class="line-block">
<div class="line">metadata names for removal before export.</div>
<div class="line">e.g. [&#8216;name&#8217;, &#8216;colormap&#8217;, &#8216;source&#8217;, &#8216;sourceBands&#8217;]</div>
</div>
</div></blockquote>
<p><strong>addGeolocArray</strong> : bool</p>
<blockquote>
<div><p>add geolocation array datasets to exported file?</p>
</div></blockquote>
<p><strong>addGCPs</strong> : bool</p>
<blockquote>
<div><p>add GCPs?  to exported file?</p>
</div></blockquote>
<p><strong>driver</strong> : str</p>
<blockquote>
<div><p>Name of GDAL driver (format)</p>
</div></blockquote>
<p><strong>bottomup</strong> : bool</p>
<blockquote>
<div><div class="line-block">
<div class="line">False : Write swath-projected data with rows and columns
organized as in the original product.</div>
<div class="line">True : Use the default behaviour of GDAL, which is to flip
the rows</div>
</div>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Creates:</th><td class="field-body"><p class="first last"><strong>a netCDF file</strong></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="line-block">
<div class="line">If number of bands is more than one, serial numbers are
added at the end of each band name.</div>
<div class="line">It is possible to fix it by changing
line.4605 in GDAL/frmts/netcdf/netcdfdataset.cpp :</div>
<div class="line">&#8216;if( nBands &gt; 1 ) sprintf(szBandName,&#8221;%s%d&#8221;,tmpMetadata,iBand);&#8217;</div>
<div class="line">&#8211;&gt; &#8216;if( nBands &gt; 1 ) sprintf(szBandName,&#8221;%s&#8221;,tmpMetadata);&#8217;</div>
<div class="line">CreateCopy fails in case the band name has special characters,</div>
<div class="line">e.g. the slash in &#8216;HH/VV&#8217;.</div>
</div>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.export_band">
<tt class="descname">export_band</tt><big>(</big><em>fileName</em>, <em>bandID=1</em>, <em>driver='netCDF'</em><big>)</big><a class="headerlink" href="#nansat.Nansat.export_band" title="Permalink to this definition">¶</a></dt>
<dd><p>Export only one band of the Nansat object</p>
<div class="line-block">
<div class="line">Get array from the required band</div>
<div class="line">Create temporary Nansat from the array</div>
<div class="line">Export temporary Nansat to file</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : str</p>
<blockquote>
<div><p>name of the output file</p>
</div></blockquote>
<p><strong>bandID</strong> : int or str, [1]</p>
<blockquote>
<div><p>number of name of the band</p>
</div></blockquote>
<p><strong>driver</strong> : str, [&#8216;netCDF&#8217;]</p>
<blockquote class="last">
<div><p>name of the GDAL Driver (format) to use</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.get_GDALRasterBand">
<tt class="descname">get_GDALRasterBand</tt><big>(</big><em>bandID=1</em><big>)</big><a class="headerlink" href="#nansat.Nansat.get_GDALRasterBand" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a GDALRasterBand of a given Nansat object</p>
<div class="line-block">
<div class="line">If str is given find corresponding band number.</div>
<div class="line">If int is given check if band with this number exists.</div>
<div class="line">Get a GDALRasterBand from vrt.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>bandID</strong> : serial number or string, optional (default is 1)</p>
<blockquote>
<div><div class="line-block">
<div class="line">if number - a band number of the band to fetch</div>
<div class="line">if string - bandID = {&#8216;name&#8217;: bandID}</div>
</div>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">GDAL RasterBand</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Get a raster band</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># get a band from the band number</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">get_GDALRasterBand</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="c"># get a band from the name</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">get_GDALRasterBand</span><span class="p">(</span><span class="s">&#39;sigma0&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.get_border">
<tt class="descname">get_border</tt><big>(</big><em>nPoints=10</em><big>)</big><a class="headerlink" href="#nansat.Nansat.get_border" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate two vectors with values of lat/lon for the border of domain</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>nPoints</strong> : int, optional</p>
<blockquote>
<div><p>Number of points on each border</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>lonVec, latVec</strong> : lists</p>
<blockquote class="last">
<div><p>vectors with lon/lat values for each point at the border</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.get_border_geometry">
<tt class="descname">get_border_geometry</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Nansat.get_border_geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Get OGR Geometry of the border Polygon</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>OGR Geometry</strong> : type Polygon</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.get_border_postgis">
<tt class="descname">get_border_postgis</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Nansat.get_border_postgis" title="Permalink to this definition">¶</a></dt>
<dd><p>Get PostGIS formatted string of the border Polygon</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>str</strong> : &#8216;PolygonFromText(PolygonWKT)&#8217;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.get_border_wkt">
<tt class="descname">get_border_wkt</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Nansat.get_border_wkt" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates string with WKT representation of the border polygon</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>WKTPolygon</strong> : string</p>
<blockquote class="last">
<div><p>string with WKT representation of the border polygon</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.get_corners">
<tt class="descname">get_corners</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Nansat.get_corners" title="Permalink to this definition">¶</a></dt>
<dd><p>Get coordinates of corners of the Domain</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>lonVec, latVec</strong> : lists</p>
<blockquote class="last">
<div><p>vectors with lon/lat values for each corner</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.get_geolocation_grids">
<tt class="descname">get_geolocation_grids</tt><big>(</big><em>stepSize=1</em><big>)</big><a class="headerlink" href="#nansat.Nansat.get_geolocation_grids" title="Permalink to this definition">¶</a></dt>
<dd><p>Get longitude and latitude grids representing the full data grid</p>
<div class="line-block">
<div class="line">If GEOLOCATION is not present in the self.vrt.dataset then grids
are generated by converting pixel/line of each pixel into lat/lon</div>
<div class="line">If GEOLOCATION is present in the self.vrt.dataset then grids are
read from the geolocation bands.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>stepSize</strong> : int</p>
<blockquote>
<div><p>Reduction factor if output is desired on a reduced grid size</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>longitude</strong> : numpy array</p>
<blockquote>
<div><p>grid with longitudes</p>
</div></blockquote>
<p><strong>latitude</strong> : numpy array</p>
<blockquote class="last">
<div><p>grid with latitudes</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.get_metadata">
<tt class="descname">get_metadata</tt><big>(</big><em>key=None</em>, <em>bandID=None</em><big>)</big><a class="headerlink" href="#nansat.Nansat.get_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Get metadata from self.vrt.dataset</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>key</strong> : string, optional</p>
<blockquote>
<div><p>name of the metadata key. If not givem all metadata is returned</p>
</div></blockquote>
<p><strong>bandID</strong> : int or str, optional</p>
<blockquote>
<div><p>number or name of band to get metadata from.
If not given, global metadata is returned</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>string</strong> : a string with metadata</p>
<blockquote>
<div><div class="line-block">
<div class="line">if key is given and found an empty string</div>
<div class="line">if key is given and not found</div>
</div>
</div></blockquote>
<p><strong>dictionary</strong> : a dictionary with all metadata</p>
<blockquote class="last">
<div><p>if key is not given</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.get_pixelsize_meters">
<tt class="descname">get_pixelsize_meters</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Nansat.get_pixelsize_meters" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pixelsize (deltaX, deltaY) of the domain</p>
<div class="line-block">
<div class="line">For projected domains, the exact result which is constant
over the domain is returned.</div>
<div class="line">For geographic (lon-lat) projections,
or domains with no geotransform,
the haversine formula is used to calculate the pixel size
in the center of the domain.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>deltaX, deltaY</strong> : float</p>
<blockquote class="last">
<div><p>pixel size in X and Y directions given in meters</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.get_time">
<tt class="descname">get_time</tt><big>(</big><em>bandID=None</em><big>)</big><a class="headerlink" href="#nansat.Nansat.get_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Get time for dataset and/or its bands</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>bandID</strong> : int or str (default = None)</p>
<blockquote>
<div><p>band number or name</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>time</strong> : list with datetime objects for each band.</p>
<blockquote class="last">
<div><p>If time is the same for all bands, the list contains 1 item</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.get_transect">
<tt class="descname">get_transect</tt><big>(</big><em>points=None, bandList=[1], latlon=True, transect=True, returnOGR=False, layerNum=0, smoothRadius=0, smoothAlg=0, **kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansat.get_transect" title="Permalink to this definition">¶</a></dt>
<dd><p>Get transect from two poins and retun the values by numpy array</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>points</strong> : tuple with one or more points or shape file name</p>
<blockquote>
<div><div class="line-block">
<div class="line">i.e. ((lon1, lat1),(lon2, lat2),(lon3, lat3), ...) or</div>
<div class="line-block">
<div class="line">((col1, row1),(col2, row2),(col3, row3), ...)</div>
</div>
</div>
</div></blockquote>
<p><strong>bandList</strong> : list of int or string</p>
<blockquote>
<div><p>elements of the list are band number or band Name</p>
</div></blockquote>
<p><strong>latlon</strong> : bool</p>
<blockquote>
<div><p>If the points in lat/lon, then True.
If the points in pixel/line, then False.</p>
</div></blockquote>
<p><strong>transect</strong> : bool</p>
<blockquote>
<div><p>If True, get all transact values
If False, get values of points</p>
</div></blockquote>
<p><strong>returnOGR: bool</strong></p>
<blockquote>
<div><p>If True, then return numpy array
If False, return OGR object</p>
</div></blockquote>
<p><strong>layerNum: int</strong></p>
<blockquote>
<div><p>If shapefile is given as points, it is the number of the layer</p>
</div></blockquote>
<p><strong>smoothRadius: int</strong></p>
<blockquote>
<div><p>If smootRadius is greater than 0, smooth every transect
pixel as the median or mean value in a circule with radius
equal to the given number.</p>
</div></blockquote>
<p><strong>smoothAlg: 0 or 1 for median or mean</strong></p>
<p><strong>vmin, vmax</strong> : int (optional)</p>
<blockquote>
<div><p>minimum and maximum pixel values of an image shown
in case points is None.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>if returnOGR = True</strong></p>
<blockquote>
<div><p><strong>transect</strong> : OGR object with points coordinates and values</p>
</div></blockquote>
<p><strong>if returnOGR = False</strong></p>
<blockquote>
<div><p><strong>transect</strong> : list or values of the transect or
OGR object with the transect values</p>
</div></blockquote>
<p><strong>[lonVector, latVector]</strong> : list with longitudes, latitudes</p>
<p class="last"><strong>pixlinCoord</strong> : numpy array with pixels and lines coordinates</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.has_band">
<tt class="descname">has_band</tt><big>(</big><em>band</em><big>)</big><a class="headerlink" href="#nansat.Nansat.has_band" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if self has band with name &lt;band&gt;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>band</strong> : str</p>
<blockquote>
<div><p>name of the band to check</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>bool</strong> : True/False if band exists or not</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.list_bands">
<tt class="descname">list_bands</tt><big>(</big><em>doPrint=True</em><big>)</big><a class="headerlink" href="#nansat.Nansat.list_bands" title="Permalink to this definition">¶</a></dt>
<dd><p>Show band information of the given Nansat object</p>
<p>Show serial number, longName, name and all parameters
for each band in the metadata of the given Nansat object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>doPrint</strong> : boolean, optional, default=True</p>
<blockquote>
<div><p>do print, otherwise it is returned as string</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>outString</strong> : String</p>
<blockquote class="last">
<div><p>formatted string with bands info</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.process">
<tt class="descname">process</tt><big>(</big><em>opts=None</em><big>)</big><a class="headerlink" href="#nansat.Nansat.process" title="Permalink to this definition">¶</a></dt>
<dd><p>Default L2 processing of Nansat object. Overloaded in childs.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.reproject">
<tt class="descname">reproject</tt><big>(</big><em>dstDomain=None</em>, <em>eResampleAlg=0</em>, <em>blockSize=None</em>, <em>WorkingDataType=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansat.reproject" title="Permalink to this definition">¶</a></dt>
<dd><p>Change projection of the object based on the given Domain</p>
<div class="line-block">
<div class="line">Create superVRT from self.vrt with AutoCreateWarpedVRT() using
projection from the dstDomain.</div>
<div class="line">Modify XML content of the warped vrt using the Domain parameters.</div>
<div class="line">Generate warpedVRT and replace self.vrt with warpedVRT.</div>
<div class="line">If current object spans from 0 to 360 and dstDomain is west of 0,
the object is shifted by 180 westwards.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dstDomain</strong> : domain</p>
<blockquote>
<div><p>destination Domain where projection and resolution are set</p>
</div></blockquote>
<p><strong>eResampleAlg</strong> : int (GDALResampleAlg)</p>
<blockquote>
<div><div class="line-block">
<div class="line">0 : NearestNeighbour</div>
<div class="line">1 : Bilinear</div>
<div class="line">2 : Cubic,</div>
<div class="line">3 : CubicSpline</div>
<div class="line">4 : Lancoz</div>
</div>
</div></blockquote>
<p><strong>blockSize</strong> : int</p>
<blockquote>
<div><p>size of blocks for resampling. Large value decrease speed
but increase accuracy at the edge</p>
</div></blockquote>
<p><strong>WorkingDataType</strong> : int (GDT_int, ...)</p>
<blockquote>
<div><p>type of data in bands. Shuold be integer for int32 bands</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.vrt</strong> : VRT object with dataset replaced to warpedVRT dataset</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>gdalwarp : <a class="reference external" href="http://www.gdal.org/gdalwarp.html">http://www.gdal.org/gdalwarp.html</a></p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.reproject_GCPs">
<tt class="descname">reproject_GCPs</tt><big>(</big><em>srsString</em><big>)</big><a class="headerlink" href="#nansat.Nansat.reproject_GCPs" title="Permalink to this definition">¶</a></dt>
<dd><p>Reproject all GCPs to a new spatial reference system</p>
<div class="line-block">
<div class="line">Necessary before warping an image if the given GCPs
are in a coordinate system which has a singularity
in (or near) the destination area (e.g. poles for lonlat GCPs)</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>srsString</strong> : string</p>
<blockquote>
<div><p>SRS given as Proj4 string</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>Reprojects all GCPs to new SRS and updates GCPProjection</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.resize">
<tt class="descname">resize</tt><big>(</big><em>factor=1</em>, <em>width=None</em>, <em>height=None</em>, <em>pixelsize=None</em>, <em>eResampleAlg=-1</em><big>)</big><a class="headerlink" href="#nansat.Nansat.resize" title="Permalink to this definition">¶</a></dt>
<dd><p>Proportional resize of the dataset.</p>
<div class="line-block">
<div class="line">The dataset is resized as (xSize*factor, ySize*factor)</div>
<div class="line">If desired width, height or pixelsize is specified,
the scaling factor is calculated accordingly.</div>
<div class="line">If GCPs are given in a dataset, they are also rewritten.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>factor</strong> : float, optional, default=1</p>
<blockquote>
<div><div class="line-block">
<div class="line">scaling factor for width and height</div>
<div class="line">&gt;1 : increasing domain size</div>
<div class="line">&lt;1 : decreasing domain size</div>
</div>
</div></blockquote>
<p><strong>width</strong> : int, optional</p>
<blockquote>
<div><p>Desired new width in pixels</p>
</div></blockquote>
<p><strong>height</strong> : int, optional</p>
<blockquote>
<div><p>Desired new height in pixels</p>
</div></blockquote>
<p><strong>pixelsize</strong> : float, optional</p>
<blockquote>
<div><p>Desired new pixelsize in meters (approximate).
A factor is calculated from ratio of the
current pixelsize to the desired pixelsize.</p>
</div></blockquote>
<p><strong>eResampleAlg</strong> : int (GDALResampleAlg), optional</p>
<blockquote>
<div><div class="line-block">
<div class="line">-1 : Average</div>
<div class="line">0 : NearestNeighbour</div>
<div class="line">1 : Bilinear</div>
<div class="line">2 : Cubic</div>
<div class="line">3 : CubicSpline</div>
<div class="line">4 : Lancoz</div>
</div>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.vrt.dataset</strong> : raster size are modified to downscaled size.</p>
<blockquote class="last">
<div><p>If GCPs are given in the dataset, they are also overwritten.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.set_metadata">
<tt class="descname">set_metadata</tt><big>(</big><em>key=''</em>, <em>value=''</em>, <em>bandID=None</em><big>)</big><a class="headerlink" href="#nansat.Nansat.set_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Set metadata to self.vrt.dataset</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>key</strong> : string or dictionary with strings</p>
<blockquote>
<div><p>name of the metadata, or dictionary with metadata names, values</p>
</div></blockquote>
<p><strong>value</strong> : string</p>
<blockquote>
<div><p>value of metadata</p>
</div></blockquote>
<p><strong>bandID</strong> : int or str</p>
<blockquote>
<div><div class="line-block">
<div class="line">number or name of band</div>
<div class="line">Without bandID (None), global metadata is set</div>
</div>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.vrt.dataset</strong> : sets metadata in GDAL current dataset</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.shape">
<tt class="descname">shape</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Nansat.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Numpy-like shape of Domain object (ySize, xSize)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>shape</strong> : tuple of two INT</p>
<blockquote class="last">
<div><p>Numpy-like shape of Domain object (ySize, xSize)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.transform_points">
<tt class="descname">transform_points</tt><big>(</big><em>colVector</em>, <em>rowVector</em>, <em>DstToSrc=0</em><big>)</big><a class="headerlink" href="#nansat.Nansat.transform_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform given lists of X,Y coordinates into lon/lat or inverse</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>colVector</strong> : lists</p>
<blockquote>
<div><p>X and Y coordinates in pixel/line or lon/lat  coordinate system</p>
</div></blockquote>
<p><strong>DstToSrc</strong> : 0 or 1</p>
<blockquote>
<div><ul class="simple">
<li>0 - forward transform (pix/line =&gt; lon/lat)</li>
<li>1 - inverse transformation</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>X, Y</strong> : lists</p>
<blockquote class="last">
<div><p>X and Y coordinates in lon/lat or pixel/line coordinate system</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.undo">
<tt class="descname">undo</tt><big>(</big><em>steps=1</em><big>)</big><a class="headerlink" href="#nansat.Nansat.undo" title="Permalink to this definition">¶</a></dt>
<dd><p>Undo reproject, resize, add_band or crop of Nansat object</p>
<p>Restore the self.vrt from self.vrt.vrt</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>steps</strong> : int</p>
<blockquote>
<div><p>How many steps back to undo</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.vrt</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.upwards_azimuth_direction">
<tt class="descname">upwards_azimuth_direction</tt><big>(</big><em>orbit_direction=None</em><big>)</big><a class="headerlink" href="#nansat.Nansat.upwards_azimuth_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Caluculate and return upwards azimuth direction of domain.</p>
<p>The upward azimuth direction will be the satellite flight
direction (bearing) for unprojected satellite images.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>bearing_center</strong> : float</p>
<blockquote class="last">
<div><p>The upwards azimuth direction (bearing) in the center of
the domain.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="line-block">
<div class="line">For longer domains especially at high latitudes
the azimuth direction may vary a lot over the domain,
and using the center angle will be a coarse approximation.</div>
<div class="line">This function should be updated to return a matrix
of bearings interpolated to each pixel of the domain.
This method should probably also get a better name.</div>
</div>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.watermask">
<tt class="descname">watermask</tt><big>(</big><em>mod44path=None</em>, <em>dstDomain=None</em><big>)</big><a class="headerlink" href="#nansat.Nansat.watermask" title="Permalink to this definition">¶</a></dt>
<dd><p>Create numpy array with watermask (water=1, land=0)</p>
<div class="line-block">
<div class="line">250 meters resolution watermask from MODIS 44W Product:</div>
<div class="line"><a class="reference external" href="http://www.glcf.umd.edu/data/watermask/">http://www.glcf.umd.edu/data/watermask/</a></div>
<div class="line">Watermask is stored as tiles in TIF(LZW) format and a VRT file.</div>
<div class="line">All files are stored in one directory.</div>
<div class="line">A tarball with compressed TIF and VRT files should be additionally
downloaded from the Nansat wiki:</div>
<div class="line"><a class="reference external" href="https://github.com/nansencenter/nansat/wiki/Install-Nansat">https://github.com/nansencenter/nansat/wiki/Install-Nansat</a></div>
<div class="line"><br /></div>
<div class="line">1. Gets the directory either from input parameter or from
environment variable MOD44WPATH</div>
<div class="line">2. Open Nansat object from the VRT file</div>
<div class="line">3. Reprojects the watermask onto the current object using
reproject() or reproject_on_jcps()</div>
<div class="line">4. Returns the reprojected Nansat object</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mod44path</strong> : string, optional, default=None</p>
<blockquote>
<div><p>path with MOD44W Products and a VRT file</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>watermask</strong> : Nansat object with water mask in current projection</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>250 meters resolution watermask from MODIS 44W Product :
<a class="reference external" href="http://www.glcf.umd.edu/data/watermask/">http://www.glcf.umd.edu/data/watermask/</a></p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.write_figure">
<tt class="descname">write_figure</tt><big>(</big><em>fileName=None</em>, <em>bands=1</em>, <em>clim=None</em>, <em>addDate=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansat.write_figure" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a raster band to a figure in graphical format.</p>
<div class="line-block">
<div class="line">Get numpy array from the band(s) and band information specified
either by given band number or band id.</div>
<div class="line-block">
<div class="line">If three bands are given, merge them and create PIL image.</div>
<div class="line">If one band is given, create indexed image</div>
</div>
<div class="line">Create Figure object.</div>
<div class="line">Adjust the array brightness and contrast using the given min/max or
histogram.</div>
<div class="line">Apply logarithmic scaling of color tone.</div>
<div class="line">Generate and append legend.</div>
<div class="line">Save the PIL output image in PNG or any other graphical format.</div>
<div class="line">If the filename extension is &#8216;tif&#8217;, the figure file is converted
to GeoTiff</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : string, optional</p>
<blockquote>
<div><p>Output file name. if one of extensions &#8216;png&#8217;, &#8216;PNG&#8217;, &#8216;tif&#8217;,
&#8216;TIF&#8217;, &#8216;bmp&#8217;, &#8216;BMP&#8217;, &#8216;jpg&#8217;, &#8216;JPG&#8217;, &#8216;jpeg&#8217;, &#8216;JPEG&#8217; is included,
specified file is crated. otherwise, &#8216;png&#8217; file is created.
if None, the figure object is returned.
if True, the figure is shown</p>
</div></blockquote>
<p><strong>bands</strong> : integer or string or list (elements are integer or string),</p>
<blockquote>
<div><p>default = 1
the size of the list has to be 1 or 3.
if the size is 3, RGB image is created based on the three bands.
Then the first element is Red, the second is Green,
and the third is Blue.</p>
</div></blockquote>
<p><strong>clim</strong> : list with two elements or &#8216;hist&#8217; to specify range of colormap</p>
<blockquote>
<div><p>None (default) : min/max values are fetched from WKV,
fallback-&#8216;hist&#8217;
[min, max] : min and max are numbers, or
[[min, min, min], [max, max, max]]: three bands used
&#8216;hist&#8217; : a histogram is used to calculate min and max values</p>
</div></blockquote>
<p><strong>addDate</strong> : boolean</p>
<blockquote>
<div><p>False (default) : no date will be aded to the caption
True : the first time of the object will be added to the caption</p>
</div></blockquote>
<p><strong>**kwargs</strong> : parameters for Figure().</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Creates:</th><td class="field-body"><p class="first"><strong>image file</strong> : if fileName is specified</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Figure object</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<div class="line-block">
<div class="line">Figure() class</div>
<div class="line">colormaps : <a class="reference external" href="http://www.scipy.org/Cookbook/Matplotlib/Show_colormaps">http://www.scipy.org/Cookbook/Matplotlib/Show_colormaps</a></div>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># 1. write only indexed image, color limits from WKV or</span>
<span class="c"># rom histogram</span>
<span class="n">n</span><span class="o">.</span><span class="n">write_figure</span><span class="p">(</span><span class="s">&#39;test.jpg&#39;</span><span class="p">)</span>
<span class="c"># 2. write only RGB image, color limits from histogram</span>
<span class="n">n</span><span class="o">.</span><span class="n">write_figure</span><span class="p">(</span><span class="s">&#39;test_rgb_hist.jpg&#39;</span><span class="p">,</span> <span class="n">clim</span><span class="o">=</span><span class="s">&#39;hist&#39;</span><span class="p">,</span>
                <span class="n">bands</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="c"># 3. write indexed image, apply log scaling and gamma correction,</span>
<span class="c"># add legend and type in title &#39;Title&#39;,</span>
<span class="c"># increase font size and put 15 tics</span>
<span class="n">n</span><span class="o">.</span><span class="n">write_figure</span><span class="p">(</span><span class="s">&#39;r09_log3_leg.jpg&#39;</span><span class="p">,</span> <span class="n">logarithm</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
               <span class="n">legend</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">titleString</span><span class="o">=</span><span class="s">&#39;Title&#39;</span><span class="p">,</span>
               <span class="n">fontSize</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">numOfTicks</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="c"># 4. write an image to png with transparent Mask set to color</span>
<span class="c"># transparency=[0, 0, 0], following PIL alpha mask</span>
<span class="n">n</span><span class="o">.</span><span class="n">write_figure</span><span class="p">(</span><span class="n">fileName</span><span class="o">=</span><span class="s">&#39;transparent.png&#39;</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
               <span class="n">mask_array</span><span class="o">=</span><span class="n">wmArray</span><span class="p">,</span> <span class="n">mask_lut</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]},</span>
               <span class="n">clim</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.15</span><span class="p">],</span> <span class="n">cmapName</span><span class="o">=</span><span class="s">&#39;gray&#39;</span><span class="p">,</span>
               <span class="n">transparency</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.write_geotiffimage">
<tt class="descname">write_geotiffimage</tt><big>(</big><em>fileName</em>, <em>bandID=1</em><big>)</big><a class="headerlink" href="#nansat.Nansat.write_geotiffimage" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes an 8-bit GeoTiff image for a given band.</p>
<div class="line-block">
<div class="line">The output GeoTiff image is convenient</div>
<div class="line-block">
<div class="line">e.g. for display in a GIS tool.</div>
</div>
<div class="line">Colormap is fetched from the metadata item &#8216;colormap&#8217;.</div>
<div class="line-block">
<div class="line">Fallback colormap is &#8216;jet&#8217;.</div>
</div>
<div class="line">Color limits are fetched from the metadata item &#8216;minmax&#8217;.</div>
<div class="line-block">
<div class="line">If &#8216;minmax&#8217; is not specified, min and max of raster is used.</div>
</div>
<div class="line">The method can be replaced by using nansat.write_figure(),
however, write_figure uses PIL which does not allow
Tiff compression, giving much larger files</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : string</p>
<p class="last"><strong>bandID</strong> : integer or string (default = 1)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.write_kml">
<tt class="descname">write_kml</tt><big>(</big><em>xmlFileName=None</em>, <em>kmlFileName=None</em><big>)</big><a class="headerlink" href="#nansat.Nansat.write_kml" title="Permalink to this definition">¶</a></dt>
<dd><p>Write KML file with domains</p>
<p>Convert XML-file with domains into KML-file for GoogleEarth
or write KML-file with the current Domain</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xmlFileName</strong> : string, optional</p>
<blockquote>
<div><p>Name of the XML-file to convert. If only this value is given
- kmlFileName=xmlFileName+&#8217;.kml&#8217;</p>
</div></blockquote>
<p><strong>kmlFileName</strong> : string, optional</p>
<blockquote class="last">
<div><p>Name of the KML-file to generate from the current Domain</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.write_kml_image">
<tt class="descname">write_kml_image</tt><big>(</big><em>kmlFileName=None</em>, <em>kmlFigureName=None</em><big>)</big><a class="headerlink" href="#nansat.Nansat.write_kml_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Create KML file for already projected image</p>
<p>Write Domain Image into KML-file for GoogleEarth</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>kmlFileName</strong> : string, optional</p>
<blockquote>
<div><p>Name of the KML-file to generate from the current Domain</p>
</div></blockquote>
<p><strong>kmlFigureName</strong> : string, optional</p>
<blockquote class="last">
<div><p>Name of the projected image stored in .png format</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Create projected a KML image</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># 1. First of all, reproject an image into Lat/Lon WGS84</span>
<span class="c"># (Simple Cylindrical) projection.</span>
<span class="c"># Cancel previous reprojection</span>
<span class="n">n</span><span class="o">.</span><span class="n">reproject</span><span class="p">()</span>
<span class="c"># 2. Get corners of the image and the pixel resolution</span>
<span class="c"># lons, lats = n.get_corners()</span>
<span class="c"># 3. Create Domain with stereographic projection,</span>
<span class="c">#    corner coordinates and resolution 1000m</span>
<span class="n">srsString</span> <span class="o">=</span> <span class="s">&#39;+proj=latlong +datum=WGS84 +ellps=WGS84 +no_defs&#39;</span>
<span class="n">extentString</span> <span class="o">=</span> <span class="s">&#39;-lle </span><span class="si">%f</span><span class="s"> </span><span class="si">%f</span><span class="s"> </span><span class="si">%f</span><span class="s"> </span><span class="si">%f</span><span class="s"> -ts 3000 3000&#39;</span> <span class="o">%</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">lons</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">lats</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">lons</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">lats</span><span class="p">))</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">Domain</span><span class="p">(</span><span class="n">srs</span><span class="o">=</span><span class="n">srsString</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">extentString</span><span class="p">)</span>
<span class="c"># 4. Reproject</span>
<span class="n">n</span><span class="o">.</span><span class="n">reproject</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="c"># 5. Write image</span>
<span class="n">n</span><span class="o">.</span><span class="n">write_figure</span><span class="p">(</span><span class="n">fileName</span><span class="o">=</span><span class="n">figureName</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">clim</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.15</span><span class="p">],</span>
               <span class="n">cmapName</span><span class="o">=</span><span class="s">&#39;gray&#39;</span><span class="p">,</span> <span class="n">transparency</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="c"># 6. Write KML for the image</span>
<span class="n">n</span><span class="o">.</span><span class="n">write_kml_image</span><span class="p">(</span><span class="n">kmlFileName</span><span class="o">=</span><span class="n">oPath</span> <span class="o">+</span> <span class="n">fileName</span> <span class="o">+</span> <span class="s">&#39;.kml&#39;</span><span class="p">,</span>
                  <span class="n">kmlFigureName</span><span class="o">=</span><span class="n">figureName</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.write_map">
<tt class="descname">write_map</tt><big>(</big><em>outputFileName</em>, <em>lonVec=None</em>, <em>latVec=None</em>, <em>lonBorder=10.0</em>, <em>latBorder=10.0</em>, <em>figureSize=(6</em>, <em>6)</em>, <em>dpi=50</em>, <em>projection='cyl'</em>, <em>resolution='c'</em>, <em>continetsColor='coral'</em>, <em>meridians=10</em>, <em>parallels=10</em>, <em>pColor='r'</em>, <em>pLine='k'</em>, <em>pAlpha=0.5</em>, <em>padding=0.0</em><big>)</big><a class="headerlink" href="#nansat.Nansat.write_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an image with a map of the domain</p>
<div class="line-block">
<div class="line">Uses Basemap to create a World Map.</div>
<div class="line">Adds a semitransparent patch with outline of the Domain</div>
<div class="line">Writes to an image file.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>outputFileName</strong> : string</p>
<blockquote>
<div><p>name of the output file name</p>
</div></blockquote>
<p><strong>lonBorder</strong> : float</p>
<blockquote>
<div><p>10, horisontal border around patch (degrees of longitude)</p>
</div></blockquote>
<p><strong>latBorder</strong> : float</p>
<blockquote>
<div><p>10, vertical border around patch (degrees of latitude)</p>
</div></blockquote>
<p><strong>figureSize</strong> : tuple of two integers</p>
<blockquote>
<div><p>(6, 6), size of the generated figure in inches</p>
</div></blockquote>
<p><strong>dpi: int</strong></p>
<blockquote>
<div><p>50, resolution of the output figure (size 6,6 and dpi 50
produces 300 x 300 figure)</p>
</div></blockquote>
<p><strong>projection</strong> : string, one of Basemap projections</p>
<blockquote>
<div><p>&#8216;cyl&#8217;, projection of the map</p>
</div></blockquote>
<p><strong>resolution</strong> : string, resolution of the map</p>
<blockquote>
<div><div class="line-block">
<div class="line">&#8216;c&#8217;, crude</div>
<div class="line">&#8216;l&#8217;, low</div>
<div class="line">&#8216;i&#8217;, intermediate</div>
<div class="line">&#8216;h&#8217;, high</div>
<div class="line">&#8216;f&#8217;, full</div>
</div>
</div></blockquote>
<p><strong>continetsColor</strong> : string or any matplotlib color representation</p>
<blockquote>
<div><p>&#8216;coral&#8217;, color of continets</p>
</div></blockquote>
<p><strong>meridians</strong> : int</p>
<blockquote>
<div><p>10, number of meridians to draw</p>
</div></blockquote>
<p><strong>parallels</strong> : int</p>
<blockquote>
<div><p>10, number of parallels to draw</p>
</div></blockquote>
<p><strong>pColor</strong> : string or any matplotlib color representation</p>
<blockquote>
<div><p>&#8216;r&#8217;, color of the Domain patch</p>
</div></blockquote>
<p><strong>pLine</strong> : string or any matplotlib color representation</p>
<blockquote>
<div><p>&#8216;k&#8217;, color of the Domain outline</p>
</div></blockquote>
<p><strong>pAlpha</strong> : float 0 - 1</p>
<blockquote>
<div><p>0.5, transparency of Domain patch</p>
</div></blockquote>
<p><strong>padding</strong> : float</p>
<blockquote class="last">
<div><p>0., width of white padding around the map</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nansat.Nansatshape">
<em class="property">class </em><tt class="descclassname">nansat.</tt><tt class="descname">Nansatshape</tt><big>(</big><em>fileName=None</em>, <em>layer=0</em>, <em>srs=None</em>, <em>wkbStyle=1</em><big>)</big><a class="headerlink" href="#nansat.Nansatshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Create Nansatshape object</p>
<dl class="docutils">
<dt>if &lt;fileName&gt; is given:</dt>
<dd>Open OGR datasource and copy to self.datasource in memory
Read a layer from self.datasource and add it to self.layer</dd>
<dt>if &lt;fileName&gt; is not given:</dt>
<dd>Create empty OGR datasource in memory
Add empty layer to self.layer</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : string</p>
<blockquote>
<div><p>location of a shape file</p>
</div></blockquote>
<p><strong>layer</strong> : int or string</p>
<blockquote>
<div><p>if int and a shapefile is given, it is a layer number to read
if string, it is layer name to created or open</p>
</div></blockquote>
<p><strong>srs</strong> : SpatialReference object</p>
<p><strong>wkbStyle</strong> : ogr.wkbPoint, ogr.wkbPoint25D</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Creates:</th><td class="field-body"><p class="first"><strong>self.datasource</strong> : ogr data source in memory</p>
<p class="last"><strong>self.layer</strong> : ogr layer</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatshape.add_features" title="nansat.Nansatshape.add_features"><tt class="xref py py-obj docutils literal"><span class="pre">add_features</span></tt></a>(values,&nbsp;coordinates)</td>
<td>Set field values and / or geometry to each feature  Loop over given arrays of coordinates and values and create corresponding points with data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatshape.export" title="nansat.Nansatshape.export"><tt class="xref py py-obj docutils literal"><span class="pre">export</span></tt></a>(fileName)</td>
<td>Save as ESRI shape-file</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatshape.get_points" title="nansat.Nansatshape.get_points"><tt class="xref py py-obj docutils literal"><span class="pre">get_points</span></tt></a>([latlon])</td>
<td>Get points (geometries of featuers) in the layer</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nansat.Nansatshape.add_features">
<tt class="descname">add_features</tt><big>(</big><em>values</em>, <em>coordinates</em><big>)</big><a class="headerlink" href="#nansat.Nansatshape.add_features" title="Permalink to this definition">¶</a></dt>
<dd><p>Set field values and / or geometry to each feature</p>
<p>Loop over given arrays of coordinates and values and create
corresponding points with data. Only ogr.wkbPoint is supported.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>values</strong> :  2-D structured numpy array (aka record array)</p>
<blockquote>
<div><p>data to be stored in the vector layer. Names of the fields
in the array will become fields in the layer.</p>
</div></blockquote>
<p><strong>coordinates</strong> : np.array (n x 2)</p>
<blockquote>
<div><p>n rows with x and y coordinates of points. Length of
coordinates should be equal to length of values.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.layer</strong> : Set the values and geometry.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatshape.export">
<tt class="descname">export</tt><big>(</big><em>fileName</em><big>)</big><a class="headerlink" href="#nansat.Nansatshape.export" title="Permalink to this definition">¶</a></dt>
<dd><p>Save as ESRI shape-file</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatshape.get_points">
<tt class="descname">get_points</tt><big>(</big><em>latlon=True</em><big>)</big><a class="headerlink" href="#nansat.Nansatshape.get_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Get points (geometries of featuers) in the layer</p>
<p>!!NB!!
if shapefile has SRS, assume that geometry is lon/lat
if not, assume that the geometry is given in pix/lin
only ogr.wkbPoint or ogr.wkbPoint25D is supported</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>latlon</strong> : bool</p>
<blockquote>
<div><p>if True, coordinates in lon/lat</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>points</strong> : tuple or None</p>
<blockquote>
<div><p>elements of tuple are X-Y coordinates</p>
</div></blockquote>
<p class="last"><strong>latlon</strong> : bool</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nansat.Domain">
<em class="property">class </em><tt class="descclassname">nansat.</tt><tt class="descname">Domain</tt><big>(</big><em>srs=None</em>, <em>ext=None</em>, <em>ds=None</em>, <em>lon=None</em>, <em>lat=None</em>, <em>name=''</em>, <em>logLevel=None</em><big>)</big><a class="headerlink" href="#nansat.Domain" title="Permalink to this definition">¶</a></dt>
<dd><p>Create Domain from GDALDataset or string options or lat/lon grids</p>
<p>Size, extent and spatial reference is given by strings</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">Domain</span><span class="p">(</span><span class="n">srs</span><span class="p">,</span> <span class="n">ext</span><span class="p">)</span>
</pre></div>
</div>
<p>Size, extent and spatial reference is copied from input
GDAL dataset</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">Domain</span><span class="p">(</span><span class="n">ds</span><span class="o">=</span><span class="n">GDALDataset</span><span class="p">)</span>
</pre></div>
</div>
<p>Spatial reference is given by srs, but size and extent is
determined from input GDAL dataset</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">Domain</span><span class="p">(</span><span class="n">srs</span><span class="p">,</span> <span class="n">ds</span><span class="o">=</span><span class="n">GDALDataset</span><span class="p">)</span>
</pre></div>
</div>
<p>Size, extent and spatial reference is given by two grids</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">Domain</span><span class="p">(</span><span class="n">lon</span><span class="o">=</span><span class="n">lonGrid</span><span class="p">,</span> <span class="n">lat</span><span class="o">=</span><span class="n">latGrid</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>srs</strong> : PROJ4 or EPSG or WKT</p>
<blockquote>
<div><div class="line-block">
<div class="line">Specifies spatial reference system (SRS)</div>
<div class="line">PROJ4:</div>
<div class="line">string with proj4 options [<a class="reference external" href="http://trac.osgeo.org/proj/">http://trac.osgeo.org/proj/</a>] e.g.:</div>
<div class="line">&#8216;+proj=latlong +datum=WGS84 +ellps=WGS84 +no_defs&#8217;</div>
<div class="line">&#8216;+proj=stere +datum=WGS84 +ellps=WGS84 +lat_0=75 +lon_0=10
+no_defs&#8217;</div>
<div class="line">EPSG:</div>
<div class="line">integer with EPSG number, [<a class="reference external" href="http://spatialreference.org/">http://spatialreference.org/</a>],</div>
<div class="line">e.g. 4326</div>
<div class="line">WKT:</div>
<div class="line">string with Well Know Text of SRS. E.g.:</div>
<div class="line">&#8216;GEOGCS[&#8220;WGS 84&#8221;,</div>
<div class="line-block">
<div class="line">DATUM[&#8220;WGS_1984&#8221;,</div>
<div class="line-block">
<div class="line">SPHEROID[&#8220;WGS 84&#8221;,6378137,298.257223563,</div>
<div class="line-block">
<div class="line">AUTHORITY[&#8220;EPSG&#8221;,&#8221;7030&#8221;]],</div>
</div>
<div class="line">TOWGS84[0,0,0,0,0,0,0],</div>
<div class="line">AUTHORITY[&#8220;EPSG&#8221;,&#8221;6326&#8221;]],</div>
</div>
<div class="line">PRIMEM[&#8220;Greenwich&#8221;,0,</div>
<div class="line-block">
<div class="line">AUTHORITY[&#8220;EPSG&#8221;,&#8221;8901&#8221;]],</div>
</div>
<div class="line">UNIT[&#8220;degree&#8221;,0.0174532925199433,</div>
<div class="line-block">
<div class="line">AUTHORITY[&#8220;EPSG&#8221;,&#8221;9108&#8221;]],</div>
</div>
<div class="line">AUTHORITY[&#8220;EPSG&#8221;,&#8221;4326&#8221;]]&#8217;</div>
</div>
</div>
</div></blockquote>
<p><strong>ext</strong> : string</p>
<blockquote>
<div><div class="line-block">
<div class="line">some gdalwarp options + additional options</div>
<div class="line"><a class="reference external" href="http://www.gdal.org/gdalwarp.html">http://www.gdal.org/gdalwarp.html</a></div>
<div class="line">Specifies extent, resolution / size</div>
<div class="line">Available options: ((&#8216;-te&#8217; or &#8216;-lle&#8217;) and (&#8216;-tr&#8217; or &#8216;-ts&#8217;))</div>
<div class="line">(e.g. &#8216;-lle -10 30 55 60 -ts 1000 1000&#8217; or
&#8216;-te 100 2000 300 10000 -tr 300 200&#8217;)</div>
<div class="line">-tr resolutionx resolutiony</div>
<div class="line">-ts sizex sizey</div>
<div class="line">-te xmin ymin xmax ymax</div>
<div class="line">-lle lonmin latmin lonmax latmax</div>
</div>
</div></blockquote>
<p><strong>ds</strong> : GDAL dataset</p>
<p><strong>lat</strong> : Numpy array</p>
<blockquote>
<div><p>Grid with latitudes</p>
</div></blockquote>
<p><strong>lon</strong> : Numpy array</p>
<blockquote>
<div><p>Grid with longitudes</p>
</div></blockquote>
<p><strong>name</strong> : string, optional</p>
<blockquote>
<div><p>Name to be added to the Domain object</p>
</div></blockquote>
<p><strong>logLevel</strong> : int, optional, default=30</p>
<blockquote>
<div><p>level of logging</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.vrt.datasetset</strong> : dataset in memory dataset is created</p>
<p><strong>based on the input arguments</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ProjectionError</strong> : occurs when Projection() is empty despite</p>
<blockquote>
<div><p>it is required for creating extentDic.</p>
</div></blockquote>
<p class="last"><strong>OptionError</strong> : occures when the arguments are not proper.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<div class="line-block">
<div class="line">Nansat.reproject()</div>
<div class="line"><a class="reference external" href="http://www.gdal.org/gdalwarp.html">http://www.gdal.org/gdalwarp.html</a></div>
<div class="line"><a class="reference external" href="http://trac.osgeo.org/proj/">http://trac.osgeo.org/proj/</a></div>
<div class="line"><a class="reference external" href="http://spatialreference.org/">http://spatialreference.org/</a></div>
<div class="line"><a class="reference external" href="http://www.gdal.org/ogr/osr_tutorial.html">http://www.gdal.org/ogr/osr_tutorial.html</a></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Domain.azimuth_up" title="nansat.Domain.azimuth_up"><tt class="xref py py-obj docutils literal"><span class="pre">azimuth_up</span></tt></a>([reductionFactor])</td>
<td>Calculate the azimuth of &#8216;upward&#8217; direction in each pixel  | Generaly speaking, azimuth is angle from the reference vector   (direction to North) to the chosen direction.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Domain.get_border" title="nansat.Domain.get_border"><tt class="xref py py-obj docutils literal"><span class="pre">get_border</span></tt></a>([nPoints])</td>
<td>Generate two vectors with values of lat/lon for the border of domain</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Domain.get_border_geometry" title="nansat.Domain.get_border_geometry"><tt class="xref py py-obj docutils literal"><span class="pre">get_border_geometry</span></tt></a>()</td>
<td>Get OGR Geometry of the border Polygon</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Domain.get_border_postgis" title="nansat.Domain.get_border_postgis"><tt class="xref py py-obj docutils literal"><span class="pre">get_border_postgis</span></tt></a>()</td>
<td>Get PostGIS formatted string of the border Polygon</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Domain.get_border_wkt" title="nansat.Domain.get_border_wkt"><tt class="xref py py-obj docutils literal"><span class="pre">get_border_wkt</span></tt></a>()</td>
<td>Creates string with WKT representation of the border polygon</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Domain.get_corners" title="nansat.Domain.get_corners"><tt class="xref py py-obj docutils literal"><span class="pre">get_corners</span></tt></a>()</td>
<td>Get coordinates of corners of the Domain</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Domain.get_geolocation_grids" title="nansat.Domain.get_geolocation_grids"><tt class="xref py py-obj docutils literal"><span class="pre">get_geolocation_grids</span></tt></a>([stepSize])</td>
<td>Get longitude and latitude grids representing the full data grid  | If GEOLOCATION is not present in the self.vrt.dataset then grids   are generated by converting pixel/line of each pixel into lat/lon | If GEOLOCATION is present in the self.vrt.dataset then grids are   read from the geolocation bands.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Domain.get_pixelsize_meters" title="nansat.Domain.get_pixelsize_meters"><tt class="xref py py-obj docutils literal"><span class="pre">get_pixelsize_meters</span></tt></a>()</td>
<td>Returns the pixelsize (deltaX, deltaY) of the domain  | For projected domains, the exact result which is constant   over the domain is returned.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Domain.reproject_GCPs" title="nansat.Domain.reproject_GCPs"><tt class="xref py py-obj docutils literal"><span class="pre">reproject_GCPs</span></tt></a>(srsString)</td>
<td>Reproject all GCPs to a new spatial reference system  | Necessary before warping an image if the given GCPs   are in a coordinate system which has a singularity   in (or near) the destination area (e.g.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Domain.shape" title="nansat.Domain.shape"><tt class="xref py py-obj docutils literal"><span class="pre">shape</span></tt></a>()</td>
<td>Return Numpy-like shape of Domain object (ySize, xSize)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Domain.transform_points" title="nansat.Domain.transform_points"><tt class="xref py py-obj docutils literal"><span class="pre">transform_points</span></tt></a>(colVector,&nbsp;rowVector[,&nbsp;...])</td>
<td>Transform given lists of X,Y coordinates into lon/lat or inverse</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Domain.upwards_azimuth_direction" title="nansat.Domain.upwards_azimuth_direction"><tt class="xref py py-obj docutils literal"><span class="pre">upwards_azimuth_direction</span></tt></a>([orbit_direction])</td>
<td>Caluculate and return upwards azimuth direction of domain.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Domain.write_kml" title="nansat.Domain.write_kml"><tt class="xref py py-obj docutils literal"><span class="pre">write_kml</span></tt></a>([xmlFileName,&nbsp;kmlFileName])</td>
<td>Write KML file with domains  Convert XML-file with domains into KML-file for GoogleEarth or write KML-file with the current Domain  :Parameters:      <strong>xmlFileName</strong> : string, optional          Name of the XML-file to convert.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Domain.write_kml_image" title="nansat.Domain.write_kml_image"><tt class="xref py py-obj docutils literal"><span class="pre">write_kml_image</span></tt></a>([kmlFileName,&nbsp;kmlFigureName])</td>
<td>Create KML file for already projected image  Write Domain Image into KML-file for GoogleEarth  :Parameters:      <strong>kmlFileName</strong> : string, optional          Name of the KML-file to generate from the current Domain      <strong>kmlFigureName</strong> : string, optional          Name of the projected image stored in .png format  ..</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Domain.write_map" title="nansat.Domain.write_map"><tt class="xref py py-obj docutils literal"><span class="pre">write_map</span></tt></a>(outputFileName[,&nbsp;lonVec,&nbsp;latVec,&nbsp;...])</td>
<td>Create an image with a map of the domain  | Uses Basemap to create a World Map.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nansat.Domain.azimuth_up">
<tt class="descname">azimuth_up</tt><big>(</big><em>reductionFactor=1</em><big>)</big><a class="headerlink" href="#nansat.Domain.azimuth_up" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the azimuth of &#8216;upward&#8217; direction in each pixel</p>
<div class="line-block">
<div class="line">Generaly speaking, azimuth is angle from the reference vector
(direction to North) to the chosen direction. Azimuth increases
clockwise from direction to North.
<a class="reference external" href="http://en.wikipedia.org/wiki/Azimuth">http://en.wikipedia.org/wiki/Azimuth</a></div>
<div class="line">Here we calcluate azimuth of &#8216;upward&#8217; direction.
&#8216;Upward&#8217; direction coincides with Y-axis direction (and hence is
opposite to the ROW-axis direction). For lon-lat (cylindrical,
Plate Caree) and Mercator projections &#8216;upward&#8217; direction coincides
with direction to North, hence azimuth is 0.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reductionFactor</strong> : integer</p>
<blockquote>
<div><p>factor by which the size of the output array is reduced</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>azimuth</strong> : numpy array</p>
<blockquote class="last">
<div><p>Values of azimuth in degrees in range 0 - 360</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.get_border">
<tt class="descname">get_border</tt><big>(</big><em>nPoints=10</em><big>)</big><a class="headerlink" href="#nansat.Domain.get_border" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate two vectors with values of lat/lon for the border of domain</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>nPoints</strong> : int, optional</p>
<blockquote>
<div><p>Number of points on each border</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>lonVec, latVec</strong> : lists</p>
<blockquote class="last">
<div><p>vectors with lon/lat values for each point at the border</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.get_border_geometry">
<tt class="descname">get_border_geometry</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Domain.get_border_geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Get OGR Geometry of the border Polygon</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>OGR Geometry</strong> : type Polygon</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.get_border_postgis">
<tt class="descname">get_border_postgis</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Domain.get_border_postgis" title="Permalink to this definition">¶</a></dt>
<dd><p>Get PostGIS formatted string of the border Polygon</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>str</strong> : &#8216;PolygonFromText(PolygonWKT)&#8217;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.get_border_wkt">
<tt class="descname">get_border_wkt</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Domain.get_border_wkt" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates string with WKT representation of the border polygon</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>WKTPolygon</strong> : string</p>
<blockquote class="last">
<div><p>string with WKT representation of the border polygon</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.get_corners">
<tt class="descname">get_corners</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Domain.get_corners" title="Permalink to this definition">¶</a></dt>
<dd><p>Get coordinates of corners of the Domain</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>lonVec, latVec</strong> : lists</p>
<blockquote class="last">
<div><p>vectors with lon/lat values for each corner</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.get_geolocation_grids">
<tt class="descname">get_geolocation_grids</tt><big>(</big><em>stepSize=1</em><big>)</big><a class="headerlink" href="#nansat.Domain.get_geolocation_grids" title="Permalink to this definition">¶</a></dt>
<dd><p>Get longitude and latitude grids representing the full data grid</p>
<div class="line-block">
<div class="line">If GEOLOCATION is not present in the self.vrt.dataset then grids
are generated by converting pixel/line of each pixel into lat/lon</div>
<div class="line">If GEOLOCATION is present in the self.vrt.dataset then grids are
read from the geolocation bands.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>stepSize</strong> : int</p>
<blockquote>
<div><p>Reduction factor if output is desired on a reduced grid size</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>longitude</strong> : numpy array</p>
<blockquote>
<div><p>grid with longitudes</p>
</div></blockquote>
<p><strong>latitude</strong> : numpy array</p>
<blockquote class="last">
<div><p>grid with latitudes</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.get_pixelsize_meters">
<tt class="descname">get_pixelsize_meters</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Domain.get_pixelsize_meters" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pixelsize (deltaX, deltaY) of the domain</p>
<div class="line-block">
<div class="line">For projected domains, the exact result which is constant
over the domain is returned.</div>
<div class="line">For geographic (lon-lat) projections,
or domains with no geotransform,
the haversine formula is used to calculate the pixel size
in the center of the domain.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>deltaX, deltaY</strong> : float</p>
<blockquote class="last">
<div><p>pixel size in X and Y directions given in meters</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.reproject_GCPs">
<tt class="descname">reproject_GCPs</tt><big>(</big><em>srsString</em><big>)</big><a class="headerlink" href="#nansat.Domain.reproject_GCPs" title="Permalink to this definition">¶</a></dt>
<dd><p>Reproject all GCPs to a new spatial reference system</p>
<div class="line-block">
<div class="line">Necessary before warping an image if the given GCPs
are in a coordinate system which has a singularity
in (or near) the destination area (e.g. poles for lonlat GCPs)</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>srsString</strong> : string</p>
<blockquote>
<div><p>SRS given as Proj4 string</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>Reprojects all GCPs to new SRS and updates GCPProjection</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.shape">
<tt class="descname">shape</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Domain.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Numpy-like shape of Domain object (ySize, xSize)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>shape</strong> : tuple of two INT</p>
<blockquote class="last">
<div><p>Numpy-like shape of Domain object (ySize, xSize)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.transform_points">
<tt class="descname">transform_points</tt><big>(</big><em>colVector</em>, <em>rowVector</em>, <em>DstToSrc=0</em><big>)</big><a class="headerlink" href="#nansat.Domain.transform_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform given lists of X,Y coordinates into lon/lat or inverse</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>colVector</strong> : lists</p>
<blockquote>
<div><p>X and Y coordinates in pixel/line or lon/lat  coordinate system</p>
</div></blockquote>
<p><strong>DstToSrc</strong> : 0 or 1</p>
<blockquote>
<div><ul class="simple">
<li>0 - forward transform (pix/line =&gt; lon/lat)</li>
<li>1 - inverse transformation</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>X, Y</strong> : lists</p>
<blockquote class="last">
<div><p>X and Y coordinates in lon/lat or pixel/line coordinate system</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.upwards_azimuth_direction">
<tt class="descname">upwards_azimuth_direction</tt><big>(</big><em>orbit_direction=None</em><big>)</big><a class="headerlink" href="#nansat.Domain.upwards_azimuth_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Caluculate and return upwards azimuth direction of domain.</p>
<p>The upward azimuth direction will be the satellite flight
direction (bearing) for unprojected satellite images.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>bearing_center</strong> : float</p>
<blockquote class="last">
<div><p>The upwards azimuth direction (bearing) in the center of
the domain.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="line-block">
<div class="line">For longer domains especially at high latitudes
the azimuth direction may vary a lot over the domain,
and using the center angle will be a coarse approximation.</div>
<div class="line">This function should be updated to return a matrix
of bearings interpolated to each pixel of the domain.
This method should probably also get a better name.</div>
</div>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.write_kml">
<tt class="descname">write_kml</tt><big>(</big><em>xmlFileName=None</em>, <em>kmlFileName=None</em><big>)</big><a class="headerlink" href="#nansat.Domain.write_kml" title="Permalink to this definition">¶</a></dt>
<dd><p>Write KML file with domains</p>
<p>Convert XML-file with domains into KML-file for GoogleEarth
or write KML-file with the current Domain</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xmlFileName</strong> : string, optional</p>
<blockquote>
<div><p>Name of the XML-file to convert. If only this value is given
- kmlFileName=xmlFileName+&#8217;.kml&#8217;</p>
</div></blockquote>
<p><strong>kmlFileName</strong> : string, optional</p>
<blockquote class="last">
<div><p>Name of the KML-file to generate from the current Domain</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.write_kml_image">
<tt class="descname">write_kml_image</tt><big>(</big><em>kmlFileName=None</em>, <em>kmlFigureName=None</em><big>)</big><a class="headerlink" href="#nansat.Domain.write_kml_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Create KML file for already projected image</p>
<p>Write Domain Image into KML-file for GoogleEarth</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>kmlFileName</strong> : string, optional</p>
<blockquote>
<div><p>Name of the KML-file to generate from the current Domain</p>
</div></blockquote>
<p><strong>kmlFigureName</strong> : string, optional</p>
<blockquote class="last">
<div><p>Name of the projected image stored in .png format</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Create projected a KML image</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># 1. First of all, reproject an image into Lat/Lon WGS84</span>
<span class="c"># (Simple Cylindrical) projection.</span>
<span class="c"># Cancel previous reprojection</span>
<span class="n">n</span><span class="o">.</span><span class="n">reproject</span><span class="p">()</span>
<span class="c"># 2. Get corners of the image and the pixel resolution</span>
<span class="c"># lons, lats = n.get_corners()</span>
<span class="c"># 3. Create Domain with stereographic projection,</span>
<span class="c">#    corner coordinates and resolution 1000m</span>
<span class="n">srsString</span> <span class="o">=</span> <span class="s">&#39;+proj=latlong +datum=WGS84 +ellps=WGS84 +no_defs&#39;</span>
<span class="n">extentString</span> <span class="o">=</span> <span class="s">&#39;-lle </span><span class="si">%f</span><span class="s"> </span><span class="si">%f</span><span class="s"> </span><span class="si">%f</span><span class="s"> </span><span class="si">%f</span><span class="s"> -ts 3000 3000&#39;</span> <span class="o">%</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">lons</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">lats</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">lons</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">lats</span><span class="p">))</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">Domain</span><span class="p">(</span><span class="n">srs</span><span class="o">=</span><span class="n">srsString</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">extentString</span><span class="p">)</span>
<span class="c"># 4. Reproject</span>
<span class="n">n</span><span class="o">.</span><span class="n">reproject</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="c"># 5. Write image</span>
<span class="n">n</span><span class="o">.</span><span class="n">write_figure</span><span class="p">(</span><span class="n">fileName</span><span class="o">=</span><span class="n">figureName</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">clim</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.15</span><span class="p">],</span>
               <span class="n">cmapName</span><span class="o">=</span><span class="s">&#39;gray&#39;</span><span class="p">,</span> <span class="n">transparency</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="c"># 6. Write KML for the image</span>
<span class="n">n</span><span class="o">.</span><span class="n">write_kml_image</span><span class="p">(</span><span class="n">kmlFileName</span><span class="o">=</span><span class="n">oPath</span> <span class="o">+</span> <span class="n">fileName</span> <span class="o">+</span> <span class="s">&#39;.kml&#39;</span><span class="p">,</span>
                  <span class="n">kmlFigureName</span><span class="o">=</span><span class="n">figureName</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.write_map">
<tt class="descname">write_map</tt><big>(</big><em>outputFileName</em>, <em>lonVec=None</em>, <em>latVec=None</em>, <em>lonBorder=10.0</em>, <em>latBorder=10.0</em>, <em>figureSize=(6</em>, <em>6)</em>, <em>dpi=50</em>, <em>projection='cyl'</em>, <em>resolution='c'</em>, <em>continetsColor='coral'</em>, <em>meridians=10</em>, <em>parallels=10</em>, <em>pColor='r'</em>, <em>pLine='k'</em>, <em>pAlpha=0.5</em>, <em>padding=0.0</em><big>)</big><a class="headerlink" href="#nansat.Domain.write_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an image with a map of the domain</p>
<div class="line-block">
<div class="line">Uses Basemap to create a World Map.</div>
<div class="line">Adds a semitransparent patch with outline of the Domain</div>
<div class="line">Writes to an image file.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>outputFileName</strong> : string</p>
<blockquote>
<div><p>name of the output file name</p>
</div></blockquote>
<p><strong>lonBorder</strong> : float</p>
<blockquote>
<div><p>10, horisontal border around patch (degrees of longitude)</p>
</div></blockquote>
<p><strong>latBorder</strong> : float</p>
<blockquote>
<div><p>10, vertical border around patch (degrees of latitude)</p>
</div></blockquote>
<p><strong>figureSize</strong> : tuple of two integers</p>
<blockquote>
<div><p>(6, 6), size of the generated figure in inches</p>
</div></blockquote>
<p><strong>dpi: int</strong></p>
<blockquote>
<div><p>50, resolution of the output figure (size 6,6 and dpi 50
produces 300 x 300 figure)</p>
</div></blockquote>
<p><strong>projection</strong> : string, one of Basemap projections</p>
<blockquote>
<div><p>&#8216;cyl&#8217;, projection of the map</p>
</div></blockquote>
<p><strong>resolution</strong> : string, resolution of the map</p>
<blockquote>
<div><div class="line-block">
<div class="line">&#8216;c&#8217;, crude</div>
<div class="line">&#8216;l&#8217;, low</div>
<div class="line">&#8216;i&#8217;, intermediate</div>
<div class="line">&#8216;h&#8217;, high</div>
<div class="line">&#8216;f&#8217;, full</div>
</div>
</div></blockquote>
<p><strong>continetsColor</strong> : string or any matplotlib color representation</p>
<blockquote>
<div><p>&#8216;coral&#8217;, color of continets</p>
</div></blockquote>
<p><strong>meridians</strong> : int</p>
<blockquote>
<div><p>10, number of meridians to draw</p>
</div></blockquote>
<p><strong>parallels</strong> : int</p>
<blockquote>
<div><p>10, number of parallels to draw</p>
</div></blockquote>
<p><strong>pColor</strong> : string or any matplotlib color representation</p>
<blockquote>
<div><p>&#8216;r&#8217;, color of the Domain patch</p>
</div></blockquote>
<p><strong>pLine</strong> : string or any matplotlib color representation</p>
<blockquote>
<div><p>&#8216;k&#8217;, color of the Domain outline</p>
</div></blockquote>
<p><strong>pAlpha</strong> : float 0 - 1</p>
<blockquote>
<div><p>0.5, transparency of Domain patch</p>
</div></blockquote>
<p><strong>padding</strong> : float</p>
<blockquote class="last">
<div><p>0., width of white padding around the map</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nansat.Figure">
<em class="property">class </em><tt class="descclassname">nansat.</tt><tt class="descname">Figure</tt><big>(</big><em>nparray</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure" title="Permalink to this definition">¶</a></dt>
<dd><p>Set attributes</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>array</strong> : numpy array (2D or 3D)</p>
<blockquote>
<div><p>dataset from Nansat</p>
</div></blockquote>
<p><strong>cmin</strong> : number (int ot float) or [number, number, number]</p>
<blockquote>
<div><p>0, minimum value of varibale in the matrix to be shown</p>
</div></blockquote>
<p><strong>cmax</strong> : number (int ot float) or [number, number, number]</p>
<blockquote>
<div><p>1, minimum value of varibale in the matrix to be shown</p>
</div></blockquote>
<p><strong>gamma</strong> : float, &gt;0</p>
<blockquote>
<div><p>2, coefficient for tone curve udjustment</p>
</div></blockquote>
<p><strong>subsetArraySize</strong> : int</p>
<blockquote>
<div><p>100000, size of the subset array which is used to get histogram</p>
</div></blockquote>
<p><strong>numOfColor</strong> : int</p>
<blockquote>
<div><p>250, number of colors for use of the palette.
254th is black and 255th is white.</p>
</div></blockquote>
<p><strong>cmapName</strong> : string</p>
<blockquote>
<div><p>&#8216;jet&#8217;, name of Matplotlib colormaps
see &#8211;&gt; <a class="reference external" href="http://www.scipy.org/Cookbook/Matplotlib/Show_colormaps">http://www.scipy.org/Cookbook/Matplotlib/Show_colormaps</a></p>
</div></blockquote>
<p><strong>ratio</strong> : float, [0 1]</p>
<blockquote>
<div><p>1.0, ratio of pixels which are used to write the figure</p>
</div></blockquote>
<p><strong>numOfTicks</strong> : int</p>
<blockquote>
<div><p>5, number of ticks on a colorbar</p>
</div></blockquote>
<p><strong>titleString</strong> : string</p>
<blockquote>
<div><p>&#8216;&#8217;, title of legend (1st line)</p>
</div></blockquote>
<p><strong>caption</strong> : string</p>
<blockquote>
<div><p>&#8216;&#8217;, caption of the legend (2nd line, e.g. long name and units)</p>
</div></blockquote>
<p><strong>fontSize</strong> : int</p>
<blockquote>
<div><p>12, size of the font of title, caption and ticks</p>
</div></blockquote>
<p><strong>logarithm</strong> : boolean, defult = False</p>
<blockquote>
<div><p>If True, tone curve is used to convert pixel values.
If False, linear.</p>
</div></blockquote>
<p><strong>legend</strong> : boolean, default = False</p>
<blockquote>
<div><p>if True, information as textString, colorbar, longName and
units are added in the figure.</p>
</div></blockquote>
<p><strong>mask_array</strong> : 2D numpy array, int, the shape should be equal</p>
<blockquote>
<div><p>array.shape. If given this array is used for masking land,
clouds, etc on the output image. Value of the array are
indeces. LUT from mask_lut is used for coloring upon this
indeces.</p>
</div></blockquote>
<p><strong>mask_lut</strong> : dictionary</p>
<blockquote>
<div><p>Look-Up-Table with colors for masking land, clouds etc. Used
tgether with mask_array:
{0, [0,0,0], 1, [100,100,100], 2: [150,150,150], 3: [0,0,255]}
index 0 - will have black color</p>
<blockquote>
<div><p>1 - dark gray
2 - light gray
3 - blue</p>
</div></blockquote>
</div></blockquote>
<p><strong>logoFileName</strong> : string</p>
<blockquote>
<div><p>name of the file with logo</p>
</div></blockquote>
<p><strong>logoLocation</strong> : list of two int, default = [0,0]</p>
<blockquote>
<div><p>X and Y offset of the image
If positive - offset is from left, upper edge
If Negative - from right, lower edge
Offset is calculated from the entire image legend inclusive</p>
</div></blockquote>
<p><strong>logoSize</strong> : list of two int</p>
<blockquote>
<div><p>desired X,Y size of logo. If None - original size is used</p>
</div></blockquote>
<p><strong>latGrid</strong> : numpy array</p>
<blockquote>
<div><p>full size array with latitudes. For adding lat/lon grid lines</p>
</div></blockquote>
<p><strong>lonGrid</strong> : numpy array</p>
<blockquote>
<div><p>full size array with longitudes. For adding lat/lon grid lines</p>
</div></blockquote>
<p><strong>nGridLines</strong> : int</p>
<blockquote>
<div><p>number of lat/lon grid lines to show</p>
</div></blockquote>
<p><strong>latlonLabels</strong> : int</p>
<blockquote>
<div><p>number of lat/lon labels to show along each side.</p>
</div></blockquote>
<p><strong>transparency</strong> : int</p>
<blockquote>
<div><p>transparency of the image background(mask), set for PIL alpha
mask in Figure.save()</p>
</div></blockquote>
<p><strong>default</strong> : None</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first"><strong>LEGEND_HEIGHT</strong> : float, [0 1]</p>
<blockquote>
<div><p>0.1, legend height relative to image height</p>
</div></blockquote>
<p><strong>CBAR_HEIGHTMIN</strong> : int</p>
<blockquote>
<div><p>5, minimum colorbar height, pixels</p>
</div></blockquote>
<p><strong>CBAR_HEIGHT</strong> : float, [0 1]</p>
<blockquote>
<div><p>0.15,  colorbar height relative to image height</p>
</div></blockquote>
<p><strong>CBAR_WIDTH</strong> : float [0 1]</p>
<blockquote>
<div><p>0.8, colorbar width  relative to legend width</p>
</div></blockquote>
<p><strong>CBAR_LOCATION_X</strong> : float [0 1]</p>
<blockquote>
<div><p>0.1, colorbar offset X  relative to legend width</p>
</div></blockquote>
<p><strong>CBAR_LOCATION_Y</strong> : float [0 1]</p>
<blockquote>
<div><p>0.5,  colorbar offset Y  relative to legend height</p>
</div></blockquote>
<p><strong>CBTICK_LOC_ADJUST_X</strong> : int</p>
<blockquote>
<div><p>5,  colorbar tick label offset X, pixels</p>
</div></blockquote>
<p><strong>CBTICK_LOC_ADJUST_Y</strong> : int</p>
<blockquote>
<div><p>3,  colorbar tick label offset Y, pixels</p>
</div></blockquote>
<p><strong>CAPTION_LOCATION_X</strong> : float, [0 1]</p>
<blockquote>
<div><p>0.1, caption offset X relative to legend width</p>
</div></blockquote>
<p><strong>CAPTION_LOCATION_Y</strong> : float, [0 1]</p>
<blockquote>
<div><p>0.1, caption offset Y relative to legend height</p>
</div></blockquote>
<p><strong>TITLE_LOCATION_X</strong> : float, [0 1]</p>
<blockquote>
<div><p>0.1, title offset X relative to legend width</p>
</div></blockquote>
<p><strong>TITLE_LOCATION_Y :</strong></p>
<blockquote>
<div><p>0.3, title  offset Y relative to legend height</p>
</div></blockquote>
<p><strong>DEFAULT_EXTENSION</strong> : string</p>
<blockquote class="last">
<div><p>&#8216;.png&#8217;</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="89%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>sizeX, sizeY</td>
<td>(int) width and height of the image</td>
</tr>
<tr class="row-even"><td>pilImg</td>
<td>(PIL image) figure</td>
</tr>
<tr class="row-odd"><td>pilImgLegend</td>
<td>(PIL image) if pilImgLegend is None, legend is not added to the figure if it is replaced, pilImgLegend includes text string, color-bar,longName and units.</td>
</tr>
<tr class="row-even"><td>cmin</td>
<td>(default [0.])</td>
</tr>
<tr class="row-odd"><td>cmax</td>
<td>(default [1.])</td>
</tr>
<tr class="row-even"><td>gamma</td>
<td>(default 2.)</td>
</tr>
<tr class="row-odd"><td>subsetArraySize</td>
<td>(default 100000)</td>
</tr>
<tr class="row-even"><td>numOfColor</td>
<td>(default 250)</td>
</tr>
<tr class="row-odd"><td>cmapName</td>
<td>(default &#8216;jet&#8217;)</td>
</tr>
<tr class="row-even"><td>ratio</td>
<td>(default 1.0)</td>
</tr>
<tr class="row-odd"><td>numOfTicks</td>
<td>(default 5)</td>
</tr>
<tr class="row-even"><td>titleString</td>
<td>(default &#8216;&#8217;)</td>
</tr>
<tr class="row-odd"><td>caption</td>
<td>(default &#8216;&#8217;)</td>
</tr>
<tr class="row-even"><td>fontSize</td>
<td>(default 12)</td>
</tr>
<tr class="row-odd"><td>logarithm</td>
<td>(default False)</td>
</tr>
<tr class="row-even"><td>legend</td>
<td>(default False)</td>
</tr>
<tr class="row-odd"><td>mask_array</td>
<td>(default None)</td>
</tr>
<tr class="row-even"><td>mask_lut</td>
<td>(default None)</td>
</tr>
<tr class="row-odd"><td>logoFileName</td>
<td>(default  None)</td>
</tr>
<tr class="row-even"><td>logoLocation</td>
<td>(default  [0, 0])</td>
</tr>
<tr class="row-odd"><td>logoSize</td>
<td>(default None)</td>
</tr>
<tr class="row-even"><td>latGrid</td>
<td>(default None)</td>
</tr>
<tr class="row-odd"><td>lonGrid</td>
<td>(default None)</td>
</tr>
<tr class="row-even"><td>nGridLines</td>
<td>(default 10)</td>
</tr>
<tr class="row-odd"><td>latlonLabels</td>
<td>(default 0)</td>
</tr>
<tr class="row-even"><td>transparency</td>
<td>(default None)</td>
</tr>
<tr class="row-odd"><td>LEGEND_HEIGHT</td>
<td>(default 0.1)</td>
</tr>
<tr class="row-even"><td>CBAR_HEIGHTMIN</td>
<td>(default 5)</td>
</tr>
<tr class="row-odd"><td>CBAR_HEIGHT</td>
<td>(default 0.15)</td>
</tr>
<tr class="row-even"><td>CBAR_WIDTH</td>
<td>(default 0.8)</td>
</tr>
<tr class="row-odd"><td>CBAR_LOCATION_X</td>
<td>(default 0.1)</td>
</tr>
<tr class="row-even"><td>CBAR_LOCATION_Y</td>
<td>(default 0.5)</td>
</tr>
<tr class="row-odd"><td>CBTICK_LOC_ADJUST_X</td>
<td>(default 5)</td>
</tr>
<tr class="row-even"><td>CBTICK_LOC_ADJUST_Y</td>
<td>(default 3)</td>
</tr>
<tr class="row-odd"><td>CAPTION_LOCATION_X</td>
<td>(default 0.1)</td>
</tr>
<tr class="row-even"><td>CAPTION_LOCATION_Y</td>
<td>(default 0.3)</td>
</tr>
<tr class="row-odd"><td>TITLE_LOCATION_X</td>
<td>(default 0.1)</td>
</tr>
<tr class="row-even"><td>TITLE_LOCATION_Y</td>
<td>(default 0.1)</td>
</tr>
<tr class="row-odd"><td>DEFAULT_EXTENSION</td>
<td>(default &#8216;.png&#8217;)</td>
</tr>
<tr class="row-even"><td>palette</td>
<td>(default None)</td>
</tr>
<tr class="row-odd"><td>pilImg</td>
<td>(default None)</td>
</tr>
<tr class="row-even"><td>pilImgLegend</td>
<td>(default None)</td>
</tr>
<tr class="row-odd"><td>extensionList</td>
<td>(default [&#8216;png&#8217;, &#8216;PNG&#8217;, &#8216;tif&#8217;, &#8216;TIF&#8217;, &#8216;bmp&#8217;,) &#8216;BMP&#8217;, &#8216;jpg&#8217;, &#8216;JPG&#8217;, &#8216;jpeg&#8217;, &#8216;JPEG&#8217;]</td>
</tr>
<tr class="row-even"><td>_cmapName</td>
<td>(default &#8216;jet&#8217;)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Figure.add_latlon_grids" title="nansat.Figure.add_latlon_grids"><tt class="xref py py-obj docutils literal"><span class="pre">add_latlon_grids</span></tt></a>(**kwargs)</td>
<td>Add lat/lon grid lines into the PIL image</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Figure.add_latlon_labels" title="nansat.Figure.add_latlon_labels"><tt class="xref py py-obj docutils literal"><span class="pre">add_latlon_labels</span></tt></a>(**kwargs)</td>
<td>Add lat/lon labels along upper and left side</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Figure.add_logo" title="nansat.Figure.add_logo"><tt class="xref py py-obj docutils literal"><span class="pre">add_logo</span></tt></a>(**kwargs)</td>
<td>Insert logo into the PIL image</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Figure.apply_logarithm" title="nansat.Figure.apply_logarithm"><tt class="xref py py-obj docutils literal"><span class="pre">apply_logarithm</span></tt></a>(**kwargs)</td>
<td>Apply a tone curve to the array  | After the normalization of the values from 0 to 1,   logarithm is applied | Then the values are converted to the normal scale.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Figure.apply_mask" title="nansat.Figure.apply_mask"><tt class="xref py py-obj docutils literal"><span class="pre">apply_mask</span></tt></a>(**kwargs)</td>
<td>Apply mask for coloring land, clouds, etc  | If mask_array and mask_lut are provided as input parameters | The pixels in self.array which have index equal to mask_lut kay   in mask_array will have color equal to mask_lut value   apply_mask should be called only after convert_palettesize.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Figure.clim_from_histogram" title="nansat.Figure.clim_from_histogram"><tt class="xref py py-obj docutils literal"><span class="pre">clim_from_histogram</span></tt></a>(**kwargs)</td>
<td>Estimate min and max pixel values from histogram  | If ratio=1.0, simply the minimum and maximum values are returned.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Figure.clip" title="nansat.Figure.clip"><tt class="xref py py-obj docutils literal"><span class="pre">clip</span></tt></a>(**kwargs)</td>
<td>Convert self.array to values between cmin and cmax  | If pixel value &lt; cmin, replaced to cmin.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Figure.convert_palettesize" title="nansat.Figure.convert_palettesize"><tt class="xref py py-obj docutils literal"><span class="pre">convert_palettesize</span></tt></a>(**kwargs)</td>
<td>Convert self.array to palette color size in uint8</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Figure.create_legend" title="nansat.Figure.create_legend"><tt class="xref py py-obj docutils literal"><span class="pre">create_legend</span></tt></a>(**kwargs)</td>
<td>self.legend is replaced from None to PIL image</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Figure.create_pilImage" title="nansat.Figure.create_pilImage"><tt class="xref py py-obj docutils literal"><span class="pre">create_pilImage</span></tt></a>(**kwargs)</td>
<td>self.create_pilImage is replaced from None to PIL image</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Figure.process" title="nansat.Figure.process"><tt class="xref py py-obj docutils literal"><span class="pre">process</span></tt></a>(**kwargs)</td>
<td>Do all common operations for preparation of a figure for saving</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Figure.save" title="nansat.Figure.save"><tt class="xref py py-obj docutils literal"><span class="pre">save</span></tt></a>(fileName,&nbsp;**kwargs)</td>
<td>Save self.pilImg to a physical file</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nansat.Figure.add_latlon_grids">
<tt class="descname">add_latlon_grids</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure.add_latlon_grids" title="Permalink to this definition">¶</a></dt>
<dd><p>Add lat/lon grid lines into the PIL image</p>
<div class="line-block">
<div class="line">Compute step of the grid</div>
<div class="line">Make matrices with binarized lat/lon</div>
<div class="line">Find edge (make line)</div>
<div class="line">Convert to maks</div>
<div class="line">Add mask to PIL</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Any of Figure attributes</strong></p>
<p><strong>latGrid</strong> : numpy array</p>
<blockquote>
<div><p>array with values of latitudes</p>
</div></blockquote>
<p><strong>lonGrid</strong> : numpy array</p>
<blockquote>
<div><p>array with values of longitudes</p>
</div></blockquote>
<p><strong>nGridLines</strong> : int</p>
<blockquote>
<div><p>number of lines to draw</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.pilImg</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Figure.add_latlon_labels">
<tt class="descname">add_latlon_labels</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure.add_latlon_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Add lat/lon labels along upper and left side</p>
<div class="line-block">
<div class="line">Compute step of lables</div>
<div class="line">Get lat/lon for these labels from latGrid, lonGrid</div>
<div class="line">Print lables to PIL</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Any of Figure attributes</strong></p>
<p><strong>latGrid</strong> : numpy array</p>
<p><strong>lonGrid</strong> : numpy array</p>
<p><strong>latlonLabels</strong> : int</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.pilImg</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Figure.add_logo">
<tt class="descname">add_logo</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure.add_logo" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert logo into the PIL image</p>
<div class="line-block">
<div class="line">Read logo from file as PIL</div>
<div class="line">Resize to the given size</div>
<div class="line">Pan using the given location</div>
<div class="line">Paste into pilImg</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>Any of Figure attributes</strong></td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><strong>self.pilImg</strong></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Figure.apply_logarithm">
<tt class="descname">apply_logarithm</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure.apply_logarithm" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a tone curve to the array</p>
<div class="line-block">
<div class="line">After the normalization of the values from 0 to 1,
logarithm is applied</div>
<div class="line">Then the values are converted to the normal scale.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>Any of Figure attributes</strong></td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><strong>self.array</strong> : numpy array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Figure.apply_mask">
<tt class="descname">apply_mask</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure.apply_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply mask for coloring land, clouds, etc</p>
<div class="line-block">
<div class="line">If mask_array and mask_lut are provided as input parameters</div>
<div class="line">The pixels in self.array which have index equal to mask_lut kay
in mask_array will have color equal to mask_lut value
apply_mask should be called only after convert_palettesize.
(i.e. to uint8 data)</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>Any of Figure attributes</strong></td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><strong>self.array</strong> : numpy array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Figure.clim_from_histogram">
<tt class="descname">clim_from_histogram</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure.clim_from_histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate min and max pixel values from histogram</p>
<div class="line-block">
<div class="line">If ratio=1.0, simply the minimum and maximum values are returned.</div>
<div class="line">If 0 &lt; ratio &lt; 1.0, get the histogram of the pixel values.</div>
<div class="line">Then get rid of (1.0-ratio)/2 from the both sides and
return the minimum and maximum values.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Any of Figure attributes</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>clim</strong> : numpy array 2D ((3x2) or (1x2))</p>
<blockquote class="last">
<div><p>minimum and maximum pixel values for each band</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Figure.clip">
<tt class="descname">clip</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure.clip" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert self.array to values between cmin and cmax</p>
<div class="line-block">
<div class="line">If pixel value &lt; cmin, replaced to cmin.</div>
<div class="line">If pixel value &gt; cmax, replaced to cmax.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Any of Figure attributes</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.array</strong> : numpy array</p>
<p class="last"><strong>self.cmin, self.cmax</strong> : allowed min/max values</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Figure.convert_palettesize">
<tt class="descname">convert_palettesize</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure.convert_palettesize" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert self.array to palette color size in uint8</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>Any of Figure attributes</strong></td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><strong>self.array</strong> : numpy array (=&gt;uint8)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Figure.create_legend">
<tt class="descname">create_legend</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure.create_legend" title="Permalink to this definition">¶</a></dt>
<dd><p>self.legend is replaced from None to PIL image</p>
<p>PIL image includes colorbar, caption, and titleString.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>Any of Figure attributes</strong></td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><strong>self.legend</strong> : PIL image</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Figure.create_pilImage">
<tt class="descname">create_pilImage</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure.create_pilImage" title="Permalink to this definition">¶</a></dt>
<dd><p>self.create_pilImage is replaced from None to PIL image</p>
<div class="line-block">
<div class="line">If three images are given, create a image with RGB mode.
if self.pilImgLegend is not None, it is pasted.</div>
<div class="line">If one image is given, create a image with P(palette) mode.
if self.pilImgLegend is not None,
self.array is extended before create the pilImag and
then paste pilImgLegend onto it.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Any of Figure attributes</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.pilImg</strong> : PIL image with / without the legend</p>
<p class="last"><strong>self.array</strong> : replace to None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Figure.process">
<tt class="descname">process</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure.process" title="Permalink to this definition">¶</a></dt>
<dd><p>Do all common operations for preparation of a figure for saving</p>
<div class="line-block">
<div class="line">Modify default values of parameters by the provided ones (if any)</div>
<div class="line">Clip to min/max</div>
<div class="line">Apply logarithm if required</div>
<div class="line">Convert data to uint8</div>
<div class="line">Create palette</div>
<div class="line">Apply mask for colouring land, clouds, etc if required</div>
<div class="line">Create legend if required</div>
<div class="line">Create PIL image</div>
<div class="line">Add logo if required</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Any of Figure attributes</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.d</strong></p>
<p><strong>self.array</strong></p>
<p><strong>self.palette</strong></p>
<p><strong>self.pilImgLegend</strong></p>
<p class="last"><strong>self.pilImg.</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Figure.save">
<tt class="descname">save</tt><big>(</big><em>fileName</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save self.pilImg to a physical file</p>
<p>If given extension is JPG, convert the image mode from Palette to RGB</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : string</p>
<blockquote>
<div><p>name of outputfile</p>
</div></blockquote>
<p><strong>Any of Figure attributes</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.pilImg</strong> : None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nansat.Nansatmap">
<em class="property">class </em><tt class="descclassname">nansat.</tt><tt class="descname">Nansatmap</tt><big>(</big><em>domain</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Set attributes</p>
<p>Get proj4 from the given domain and convert the proj4 projection to
the basemap projection.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>domain</strong> : domain object</p>
<p><strong>kwargs</strong> : dictionary</p>
<blockquote class="last">
<div><p>parameters that are used for all operations.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>basemap() : <a class="reference external" href="http://matplotlib.org/basemap/api/basemap_api.html">http://matplotlib.org/basemap/api/basemap_api.html</a></p>
<p class="rubric">Attributes</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">cmap</span></tt></td>
<td>Colormap objects based on lookup tables using linear segments.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="88%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>fig</td>
<td>(figure) matplotlib.pyplot.figure</td>
</tr>
<tr class="row-even"><td>colorbar</td>
<td>(boolean) | if colorbar is True, it is possible to put colorbar. | e.g. contour_plots(contour_style=&#8217;fill&#8217;), put_color()</td>
</tr>
<tr class="row-odd"><td>mpl</td>
<td>(list) elements are matplotlib.contour.QuadContourSet instance, matplotlib.quiver.Quiver instance or matplotlib.collections.QuadMesh object</td>
</tr>
<tr class="row-even"><td>colorbar</td>
<td>(default None)</td>
</tr>
<tr class="row-odd"><td>mpl</td>
<td>(default [])</td>
</tr>
<tr class="row-even"><td>lon</td>
<td>(default None)</td>
</tr>
<tr class="row-odd"><td>lat</td>
<td>(default None)</td>
</tr>
<tr class="row-even"><td>x</td>
<td>(default None)</td>
</tr>
<tr class="row-odd"><td>y</td>
<td>(default None)</td>
</tr>
<tr class="row-even"><td>convolve_weightSize</td>
<td>(default 7)</td>
</tr>
<tr class="row-odd"><td>convolve_weights</td>
<td>(default None)</td>
</tr>
<tr class="row-even"><td>convolve_mode</td>
<td>(default &#8216;reflect&#8217;)</td>
</tr>
<tr class="row-odd"><td>convolve_cval</td>
<td>(default 0.0)</td>
</tr>
<tr class="row-even"><td>convolve_origin</td>
<td>(default 0)</td>
</tr>
<tr class="row-odd"><td>fourier_sigma</td>
<td>(default 1.0)</td>
</tr>
<tr class="row-even"><td>fourier_n</td>
<td>(default -1)</td>
</tr>
<tr class="row-odd"><td>fourier_axis</td>
<td>(default -1)</td>
</tr>
<tr class="row-even"><td>spline_order</td>
<td>(default 3)</td>
</tr>
<tr class="row-odd"><td>spline_axis</td>
<td>(default -1)</td>
</tr>
<tr class="row-even"><td>gaussian_sigma</td>
<td>(default 2.5)</td>
</tr>
<tr class="row-odd"><td>gaussian_order</td>
<td>(default 0)</td>
</tr>
<tr class="row-even"><td>gaussian_mode</td>
<td>(default &#8216;reflect&#8217;)</td>
</tr>
<tr class="row-odd"><td>gaussian_cval</td>
<td>(default 0.0)</td>
</tr>
<tr class="row-even"><td>DEFAULT_EXTENSION</td>
<td>(default &#8216;.png&#8217;)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">__call__</span></tt>(x,&nbsp;y[,&nbsp;inverse])</td>
<td>Calling a Basemap class instance with the arguments lon, lat will convert lon/lat (in degrees) to x/y map projection coordinates (in meters).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.add_colorbar" title="nansat.Nansatmap.add_colorbar"><tt class="xref py py-obj docutils literal"><span class="pre">add_colorbar</span></tt></a>([fontsize])</td>
<td>Add color bar</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.arcgisimage" title="nansat.Nansatmap.arcgisimage"><tt class="xref py py-obj docutils literal"><span class="pre">arcgisimage</span></tt></a>([server,&nbsp;service,&nbsp;xpixels,&nbsp;...])</td>
<td>Retrieve an image using the ArcGIS Server REST API and display it on the map.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.barbs" title="nansat.Nansatmap.barbs"><tt class="xref py py-obj docutils literal"><span class="pre">barbs</span></tt></a>(x,&nbsp;y,&nbsp;u,&nbsp;v,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Make a wind barb plot (u, v) with on the map.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.bluemarble" title="nansat.Nansatmap.bluemarble"><tt class="xref py py-obj docutils literal"><span class="pre">bluemarble</span></tt></a>([ax,&nbsp;scale])</td>
<td>display blue marble image (from <a class="reference external" href="http://visibleearth.nasa.gov">http://visibleearth.nasa.gov</a>)</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">cmap</span></tt></td>
<td>Colormap objects based on lookup tables using linear segments.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.contour" title="nansat.Nansatmap.contour"><tt class="xref py py-obj docutils literal"><span class="pre">contour</span></tt></a>(data[,&nbsp;v,&nbsp;smooth,&nbsp;mode,&nbsp;label])</td>
<td>Draw lined contour plots  If smooth is True, data is smoothed.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.contourf" title="nansat.Nansatmap.contourf"><tt class="xref py py-obj docutils literal"><span class="pre">contourf</span></tt></a>(data[,&nbsp;v,&nbsp;smooth,&nbsp;mode])</td>
<td>Draw filled contour plots  If smooth is True, data is smoothed.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.draw_continents" title="nansat.Nansatmap.draw_continents"><tt class="xref py py-obj docutils literal"><span class="pre">draw_continents</span></tt></a>(**kwargs)</td>
<td>Draw continents</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.drawcoastlines" title="nansat.Nansatmap.drawcoastlines"><tt class="xref py py-obj docutils literal"><span class="pre">drawcoastlines</span></tt></a>([linewidth,&nbsp;linestyle,&nbsp;...])</td>
<td>Draw coastlines.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.drawcounties" title="nansat.Nansatmap.drawcounties"><tt class="xref py py-obj docutils literal"><span class="pre">drawcounties</span></tt></a>([linewidth,&nbsp;linestyle,&nbsp;color,&nbsp;...])</td>
<td>Draw county boundaries in US.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.drawcountries" title="nansat.Nansatmap.drawcountries"><tt class="xref py py-obj docutils literal"><span class="pre">drawcountries</span></tt></a>([linewidth,&nbsp;linestyle,&nbsp;color,&nbsp;...])</td>
<td>Draw country boundaries.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.drawgreatcircle" title="nansat.Nansatmap.drawgreatcircle"><tt class="xref py py-obj docutils literal"><span class="pre">drawgreatcircle</span></tt></a>(lon1,&nbsp;lat1,&nbsp;lon2,&nbsp;lat2[,&nbsp;del_s])</td>
<td>Draw a great circle on the map from the longitude-latitude pair <tt class="docutils literal"><span class="pre">lon1,lat1</span></tt> to <tt class="docutils literal"><span class="pre">lon2,lat2</span></tt>  ..</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.drawgrid" title="nansat.Nansatmap.drawgrid"><tt class="xref py py-obj docutils literal"><span class="pre">drawgrid</span></tt></a>([fontsize,&nbsp;lat_num,&nbsp;lon_num,&nbsp;...])</td>
<td>Draw and label parallels (lat and lon lines) for values (in degrees)   :Parameters:      <strong>fontsize</strong> : int                <strong>lat_num</strong> : int          Number of latitude lables      <strong>lon_num :</strong>          Number of longitude lables      <strong>lat_labels</strong> : list of Bool          Location of latitude labels      <strong>lon_labels</strong> : list of Bool          Location of longitude labels  ..</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.drawlsmask" title="nansat.Nansatmap.drawlsmask"><tt class="xref py py-obj docutils literal"><span class="pre">drawlsmask</span></tt></a>([land_color,&nbsp;ocean_color,&nbsp;...])</td>
<td>Draw land-sea mask image.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.drawmapboundary" title="nansat.Nansatmap.drawmapboundary"><tt class="xref py py-obj docutils literal"><span class="pre">drawmapboundary</span></tt></a>([color,&nbsp;linewidth,&nbsp;...])</td>
<td>draw boundary around map projection region, optionally</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.drawmapscale" title="nansat.Nansatmap.drawmapscale"><tt class="xref py py-obj docutils literal"><span class="pre">drawmapscale</span></tt></a>(lon,&nbsp;lat,&nbsp;lon0,&nbsp;lat0,&nbsp;length[,&nbsp;...])</td>
<td>Draw a map scale at <tt class="docutils literal"><span class="pre">lon,lat</span></tt> of length <tt class="docutils literal"><span class="pre">length</span></tt> representing distance in the map projection coordinates at <tt class="docutils literal"><span class="pre">lon0,lat0</span></tt>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.drawmeridians" title="nansat.Nansatmap.drawmeridians"><tt class="xref py py-obj docutils literal"><span class="pre">drawmeridians</span></tt></a>(meridians[,&nbsp;color,&nbsp;linewidth,&nbsp;...])</td>
<td>Draw and label meridians (longitude lines) for values (in degrees) given in the sequence <tt class="docutils literal"><span class="pre">meridians</span></tt>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.drawparallels" title="nansat.Nansatmap.drawparallels"><tt class="xref py py-obj docutils literal"><span class="pre">drawparallels</span></tt></a>(circles[,&nbsp;color,&nbsp;linewidth,&nbsp;...])</td>
<td>Draw and label parallels (latitude lines) for values (in degrees) given in the sequence <tt class="docutils literal"><span class="pre">circles</span></tt>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.drawrivers" title="nansat.Nansatmap.drawrivers"><tt class="xref py py-obj docutils literal"><span class="pre">drawrivers</span></tt></a>([linewidth,&nbsp;linestyle,&nbsp;color,&nbsp;...])</td>
<td>Draw major rivers.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.drawstates" title="nansat.Nansatmap.drawstates"><tt class="xref py py-obj docutils literal"><span class="pre">drawstates</span></tt></a>([linewidth,&nbsp;linestyle,&nbsp;color,&nbsp;...])</td>
<td>Draw state boundaries in Americas.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.etopo" title="nansat.Nansatmap.etopo"><tt class="xref py py-obj docutils literal"><span class="pre">etopo</span></tt></a>([ax,&nbsp;scale])</td>
<td>display etopo relief image (from</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.fillcontinents" title="nansat.Nansatmap.fillcontinents"><tt class="xref py py-obj docutils literal"><span class="pre">fillcontinents</span></tt></a>([color,&nbsp;lake_color,&nbsp;ax,&nbsp;...])</td>
<td>Fill continents.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.gcpoints" title="nansat.Nansatmap.gcpoints"><tt class="xref py py-obj docutils literal"><span class="pre">gcpoints</span></tt></a>(lon1,&nbsp;lat1,&nbsp;lon2,&nbsp;lat2,&nbsp;npoints)</td>
<td>compute <tt class="docutils literal"><span class="pre">points</span></tt> points along a great circle with endpoints</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.hexbin" title="nansat.Nansatmap.hexbin"><tt class="xref py py-obj docutils literal"><span class="pre">hexbin</span></tt></a>(x,&nbsp;y,&nbsp;**kwargs)</td>
<td>Make a hexagonal binning plot of x versus y, where x, y are 1-D sequences of the same length, N.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.imshow" title="nansat.Nansatmap.imshow"><tt class="xref py py-obj docutils literal"><span class="pre">imshow</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>Display an image over the map (see matplotlib.pyplot.imshow documentation).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.is_land" title="nansat.Nansatmap.is_land"><tt class="xref py py-obj docutils literal"><span class="pre">is_land</span></tt></a>(xpt,&nbsp;ypt)</td>
<td>Returns True if the given x,y point (in projection coordinates) is over land, False otherwise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.makegrid" title="nansat.Nansatmap.makegrid"><tt class="xref py py-obj docutils literal"><span class="pre">makegrid</span></tt></a>(nx,&nbsp;ny[,&nbsp;returnxy])</td>
<td>return arrays of shape (ny,nx) containing lon,lat coordinates of</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.nightshade" title="nansat.Nansatmap.nightshade"><tt class="xref py py-obj docutils literal"><span class="pre">nightshade</span></tt></a>(date[,&nbsp;color,&nbsp;delta,&nbsp;alpha,&nbsp;ax,&nbsp;...])</td>
<td>Shade the regions of the map that are in darkness at the time specifed by <tt class="docutils literal"><span class="pre">date</span></tt>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.pcolor" title="nansat.Nansatmap.pcolor"><tt class="xref py py-obj docutils literal"><span class="pre">pcolor</span></tt></a>(x,&nbsp;y,&nbsp;data,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Make a pseudo-color plot over the map (see matplotlib.pyplot.pcolor documentation).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.pcolormesh" title="nansat.Nansatmap.pcolormesh"><tt class="xref py py-obj docutils literal"><span class="pre">pcolormesh</span></tt></a>(data[,&nbsp;validValues])</td>
<td>Make a pseudo-color plot over the map   :Parameters:      <strong>data</strong> : numpy 2D array          Input data      <strong>validValues</strong> : list with two scalars (e.g.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.plot" title="nansat.Nansatmap.plot"><tt class="xref py py-obj docutils literal"><span class="pre">plot</span></tt></a>(x,&nbsp;y,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Draw lines and/or markers on the map (see matplotlib.pyplot.plot documentation).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.quiver" title="nansat.Nansatmap.quiver"><tt class="xref py py-obj docutils literal"><span class="pre">quiver</span></tt></a>(dataX,&nbsp;dataY[,&nbsp;quivectors])</td>
<td>Draw quiver plots</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.readshapefile" title="nansat.Nansatmap.readshapefile"><tt class="xref py py-obj docutils literal"><span class="pre">readshapefile</span></tt></a>(shapefile,&nbsp;name[,&nbsp;drawbounds,&nbsp;...])</td>
<td>Read in shape file, optionally draw boundaries on map.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.rotate_vector" title="nansat.Nansatmap.rotate_vector"><tt class="xref py py-obj docutils literal"><span class="pre">rotate_vector</span></tt></a>(uin,&nbsp;vin,&nbsp;lons,&nbsp;lats[,&nbsp;returnxy])</td>
<td>Rotate a vector field (<tt class="docutils literal"><span class="pre">uin,vin</span></tt>) on a rectilinear grid with longitudes = <tt class="docutils literal"><span class="pre">lons</span></tt> and latitudes = <tt class="docutils literal"><span class="pre">lats</span></tt> from geographical (lat/lon) into map projection (x/y) coordinates.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.save" title="nansat.Nansatmap.save"><tt class="xref py py-obj docutils literal"><span class="pre">save</span></tt></a>(fileName[,&nbsp;landmask])</td>
<td>Draw continents and save</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.scatter" title="nansat.Nansatmap.scatter"><tt class="xref py py-obj docutils literal"><span class="pre">scatter</span></tt></a>(x,&nbsp;y,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Plot points with markers on the map (see matplotlib.pyplot.scatter documentation).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.set_axes_limits" title="nansat.Nansatmap.set_axes_limits"><tt class="xref py py-obj docutils literal"><span class="pre">set_axes_limits</span></tt></a>([ax])</td>
<td>Final step in Basemap method wrappers of Axes plotting methods:  Set axis limits, fix aspect ratio for map domain using current or specified axes instance.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.shadedrelief" title="nansat.Nansatmap.shadedrelief"><tt class="xref py py-obj docutils literal"><span class="pre">shadedrelief</span></tt></a>([ax,&nbsp;scale])</td>
<td>display shaded relief image (from <a class="reference external" href="http://www.shadedrelief.com">http://www.shadedrelief.com</a>)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.shiftdata" title="nansat.Nansatmap.shiftdata"><tt class="xref py py-obj docutils literal"><span class="pre">shiftdata</span></tt></a>(lonsin[,&nbsp;datain,&nbsp;lon_0])</td>
<td>Shift longitudes (and optionally data) so that they match map projection region.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.smooth" title="nansat.Nansatmap.smooth"><tt class="xref py py-obj docutils literal"><span class="pre">smooth</span></tt></a>(idata,&nbsp;mode,&nbsp;**kwargs)</td>
<td>Smooth data for contour() and contourf()  idata is smoothed by convolve, fourier_gaussian, spline or gaussian (default).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.streamplot" title="nansat.Nansatmap.streamplot"><tt class="xref py py-obj docutils literal"><span class="pre">streamplot</span></tt></a>(x,&nbsp;y,&nbsp;u,&nbsp;v,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Draws streamlines of a vector flow.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.tissot" title="nansat.Nansatmap.tissot"><tt class="xref py py-obj docutils literal"><span class="pre">tissot</span></tt></a>(lon_0,&nbsp;lat_0,&nbsp;radius_deg,&nbsp;npts[,&nbsp;ax])</td>
<td>Draw a polygon centered at <tt class="docutils literal"><span class="pre">lon_0,lat_0</span></tt>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.transform_scalar" title="nansat.Nansatmap.transform_scalar"><tt class="xref py py-obj docutils literal"><span class="pre">transform_scalar</span></tt></a>(datin,&nbsp;lons,&nbsp;lats,&nbsp;nx,&nbsp;ny)</td>
<td>Interpolate a scalar field (<tt class="docutils literal"><span class="pre">datin</span></tt>) from a lat/lon grid with longitudes = <tt class="docutils literal"><span class="pre">lons</span></tt> and latitudes = <tt class="docutils literal"><span class="pre">lats</span></tt> to a <tt class="docutils literal"><span class="pre">ny</span></tt> by <tt class="docutils literal"><span class="pre">nx</span></tt> map projection grid.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.transform_vector" title="nansat.Nansatmap.transform_vector"><tt class="xref py py-obj docutils literal"><span class="pre">transform_vector</span></tt></a>(uin,&nbsp;vin,&nbsp;lons,&nbsp;lats,&nbsp;nx,&nbsp;ny)</td>
<td>Rotate and interpolate a vector field (<tt class="docutils literal"><span class="pre">uin,vin</span></tt>) from a lat/lon grid with longitudes = <tt class="docutils literal"><span class="pre">lons</span></tt> and latitudes = <tt class="docutils literal"><span class="pre">lats</span></tt> to a <tt class="docutils literal"><span class="pre">ny</span></tt> by <tt class="docutils literal"><span class="pre">nx</span></tt> map projection grid.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.warpimage" title="nansat.Nansatmap.warpimage"><tt class="xref py py-obj docutils literal"><span class="pre">warpimage</span></tt></a>([image,&nbsp;scale])</td>
<td>Display an image (filename given by <tt class="docutils literal"><span class="pre">image</span></tt> keyword) as a map background.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.wmsimage" title="nansat.Nansatmap.wmsimage"><tt class="xref py py-obj docutils literal"><span class="pre">wmsimage</span></tt></a>(server[,&nbsp;xpixels,&nbsp;ypixels,&nbsp;format,&nbsp;...])</td>
<td>Retrieve an image using from a WMS server using the Open Geospatial Consortium (OGC) standard interface and display on the map.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nansat.Nansatmap.add_colorbar">
<tt class="descname">add_colorbar</tt><big>(</big><em>fontsize=6</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.add_colorbar" title="Permalink to this definition">¶</a></dt>
<dd><p>Add color bar</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fontsize</strong> : int</p>
<p><strong>Parameters for matplotlib.pyplot.colorbar</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>Adds colorbar to self.fig</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.arcgisimage">
<tt class="descname">arcgisimage</tt><big>(</big><em>server='http://server.arcgisonline.com/ArcGIS'</em>, <em>service='ESRI_Imagery_World_2D'</em>, <em>xpixels=400</em>, <em>ypixels=None</em>, <em>dpi=96</em>, <em>verbose=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.arcgisimage" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve an image using the ArcGIS Server REST API and display it on
the map. In order to use this method, the Basemap instance must be
created using the <tt class="docutils literal"><span class="pre">epsg</span></tt> keyword to define the map projection, unless
the <tt class="docutils literal"><span class="pre">cyl</span></tt> projection is used (in which case the epsg code 4326 is
assumed).</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keywords</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>server</td>
<td>web map server URL (default
<a class="reference external" href="http://server.arcgisonline.com/ArcGIS">http://server.arcgisonline.com/ArcGIS</a>).</td>
</tr>
<tr class="row-odd"><td>service</td>
<td>service (image type) hosted on server (default
ESRI_Imagery_World_2D, which is NASA &#8216;Blue Marble&#8217;
image).</td>
</tr>
<tr class="row-even"><td>xpixels</td>
<td>requested number of image pixels in x-direction
(default 400).</td>
</tr>
<tr class="row-odd"><td>ypixels</td>
<td>requested number of image pixels in y-direction.
Default (None) is to infer the number from
from xpixels and the aspect ratio of the
map projection region.</td>
</tr>
<tr class="row-even"><td>dpi</td>
<td>The device resolution of the exported image (dots per
inch, default 96).</td>
</tr>
<tr class="row-odd"><td>verbose</td>
<td>if True, print URL used to retrieve image (default
False).</td>
</tr>
</tbody>
</table>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>returns a matplotlib.image.AxesImage instance.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.barbs">
<tt class="descname">barbs</tt><big>(</big><em>x</em>, <em>y</em>, <em>u</em>, <em>v</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.barbs" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a wind barb plot (u, v) with on the map.
(see matplotlib.pyplot.barbs documentation).</p>
<p>If <tt class="docutils literal"><span class="pre">latlon</span></tt> keyword is set to True, x,y are intrepreted as
longitude and latitude in degrees.  Data and longitudes are
automatically shifted to match map projection region for cylindrical
and pseudocylindrical projections, and x,y are transformed to map
projection coordinates. If <tt class="docutils literal"><span class="pre">latlon</span></tt> is False (default), x and y
are assumed to be map projection coordinates.</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>Other *args and **kwargs passed on to matplotlib.pyplot.barbs</p>
<p>Returns two matplotlib.axes.Barbs instances, one for the Northern
Hemisphere and one for the Southern Hemisphere.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.bluemarble">
<tt class="descname">bluemarble</tt><big>(</big><em>ax=None</em>, <em>scale=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.bluemarble" title="Permalink to this definition">¶</a></dt>
<dd><p>display blue marble image (from <a class="reference external" href="http://visibleearth.nasa.gov">http://visibleearth.nasa.gov</a>)
as map background.
Default image size is 5400x2700, which can be quite slow and
use quite a bit of memory.  The <tt class="docutils literal"><span class="pre">scale</span></tt> keyword can be used
to downsample the image (<tt class="docutils literal"><span class="pre">scale=0.5</span></tt> downsamples to 2700x1350).</p>
<p>**kwargs passed on to <a class="reference internal" href="#nansat.Nansatmap.imshow" title="nansat.Nansatmap.imshow"><tt class="xref py py-meth docutils literal"><span class="pre">imshow()</span></tt></a>.</p>
<p>returns a matplotlib.image.AxesImage instance.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.contour">
<tt class="descname">contour</tt><big>(</big><em>data</em>, <em>v=None</em>, <em>smooth=False</em>, <em>mode='gaussian'</em>, <em>label=True</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.contour" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw lined contour plots</p>
<p>If smooth is True, data is smoothed. Then draw lined contour.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : numpy 2D array</p>
<blockquote>
<div><p>Input data</p>
</div></blockquote>
<p><strong>v</strong> : list with values</p>
<blockquote>
<div><p>draw contour lines at the values specified in sequence v</p>
</div></blockquote>
<p><strong>smooth</strong> : Boolean</p>
<blockquote>
<div><p>Apply smoothing?</p>
</div></blockquote>
<p><strong>mode</strong> : string</p>
<blockquote>
<div><p>&#8216;gaussian&#8217;, &#8216;spline&#8217;, &#8216;fourier&#8217;, &#8216;convolve&#8217;
mname of smoothing algorithm to apply</p>
</div></blockquote>
<p><strong>label</strong> : boolean</p>
<blockquote>
<div><p>Add lables?</p>
</div></blockquote>
<p><strong>**kwargs:</strong></p>
<blockquote>
<div><div class="line-block">
<div class="line">Optional parameters for Nansatmap.smooth()</div>
<div class="line">Optional parameters for pyplot.contour().</div>
<div class="line">Optional parameters for pyplot.clabel()</div>
</div>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.mpl</strong> : list</p>
<blockquote class="last">
<div><p>append QuadContourSet instance</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.contourf">
<tt class="descname">contourf</tt><big>(</big><em>data</em>, <em>v=None</em>, <em>smooth=False</em>, <em>mode='gaussian'</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.contourf" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw filled contour plots</p>
<p>If smooth is True, data is smoothed. Then draw filled contour.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : numpy 2D array</p>
<blockquote>
<div><p>Input data</p>
</div></blockquote>
<p><strong>v</strong> : list with values</p>
<blockquote>
<div><p>draw contour lines at the values specified in sequence v</p>
</div></blockquote>
<p><strong>smooth</strong> : Boolean</p>
<blockquote>
<div><p>Apply smoothing?</p>
</div></blockquote>
<p><strong>mode</strong> : string</p>
<blockquote>
<div><p>&#8216;gaussian&#8217;, &#8216;spline&#8217;, &#8216;fourier&#8217;, &#8216;convolve&#8217;
mname of smoothing algorithm to apply</p>
</div></blockquote>
<p><strong>**kwargs:</strong></p>
<blockquote>
<div><div class="line-block">
<div class="line">cmap : colormap (e.g. cm.jet)</div>
<div class="line">Optional parameters for Nansatmap.smooth()</div>
<div class="line">Optional parameters for pyplot.contourf().</div>
</div>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.mpl</strong> : list</p>
<blockquote class="last">
<div><p>append QuadContourSet instance</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.draw_continents">
<tt class="descname">draw_continents</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.draw_continents" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw continents</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>Parameters of basemap.fillcontinents</strong></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.drawcoastlines">
<tt class="descname">drawcoastlines</tt><big>(</big><em>linewidth=1.0</em>, <em>linestyle='solid'</em>, <em>color='k'</em>, <em>antialiased=1</em>, <em>ax=None</em>, <em>zorder=None</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.drawcoastlines" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw coastlines.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>linewidth</td>
<td>coastline width (default 1.)</td>
</tr>
<tr class="row-odd"><td>linestyle</td>
<td>coastline linestyle (default solid)</td>
</tr>
<tr class="row-even"><td>color</td>
<td>coastline color (default black)</td>
</tr>
<tr class="row-odd"><td>antialiased</td>
<td>antialiasing switch for coastlines (default True).</td>
</tr>
<tr class="row-even"><td>ax</td>
<td>axes instance (overrides default axes instance)</td>
</tr>
<tr class="row-odd"><td>zorder</td>
<td>sets the zorder for the coastlines (if not specified,
uses default zorder for
matplotlib.patches.LineCollections).</td>
</tr>
</tbody>
</table>
<p>returns a matplotlib.patches.LineCollection object.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.drawcounties">
<tt class="descname">drawcounties</tt><big>(</big><em>linewidth=0.1</em>, <em>linestyle='solid'</em>, <em>color='k'</em>, <em>antialiased=1</em>, <em>ax=None</em>, <em>zorder=None</em>, <em>drawbounds=False</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.drawcounties" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw county boundaries in US. The county boundary shapefile
originates with the NOAA Coastal Geospatial Data Project
(<a class="reference external" href="http://coastalgeospatial.noaa.gov/data_gis.html">http://coastalgeospatial.noaa.gov/data_gis.html</a>).</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>linewidth</td>
<td>county boundary line width (default 0.1)</td>
</tr>
<tr class="row-odd"><td>linestyle</td>
<td>coastline linestyle (default solid)</td>
</tr>
<tr class="row-even"><td>color</td>
<td>county boundary line color (default black)</td>
</tr>
<tr class="row-odd"><td>antialiased</td>
<td>antialiasing switch for county boundaries
(default True).</td>
</tr>
<tr class="row-even"><td>ax</td>
<td>axes instance (overrides default axes instance)</td>
</tr>
<tr class="row-odd"><td>zorder</td>
<td>sets the zorder for the county boundaries (if not
specified, uses default zorder for
matplotlib.patches.LineCollections).</td>
</tr>
</tbody>
</table>
<p>returns a matplotlib.patches.LineCollection object.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.drawcountries">
<tt class="descname">drawcountries</tt><big>(</big><em>linewidth=0.5</em>, <em>linestyle='solid'</em>, <em>color='k'</em>, <em>antialiased=1</em>, <em>ax=None</em>, <em>zorder=None</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.drawcountries" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw country boundaries.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>linewidth</td>
<td>country boundary line width (default 0.5)</td>
</tr>
<tr class="row-odd"><td>linestyle</td>
<td>coastline linestyle (default solid)</td>
</tr>
<tr class="row-even"><td>color</td>
<td>country boundary line color (default black)</td>
</tr>
<tr class="row-odd"><td>antialiased</td>
<td>antialiasing switch for country boundaries (default
True).</td>
</tr>
<tr class="row-even"><td>ax</td>
<td>axes instance (overrides default axes instance)</td>
</tr>
<tr class="row-odd"><td>zorder</td>
<td>sets the zorder for the country boundaries (if not
specified uses default zorder for
matplotlib.patches.LineCollections).</td>
</tr>
</tbody>
</table>
<p>returns a matplotlib.patches.LineCollection object.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.drawgreatcircle">
<tt class="descname">drawgreatcircle</tt><big>(</big><em>lon1</em>, <em>lat1</em>, <em>lon2</em>, <em>lat2</em>, <em>del_s=100.0</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.drawgreatcircle" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a great circle on the map from the longitude-latitude
pair <tt class="docutils literal"><span class="pre">lon1,lat1</span></tt> to <tt class="docutils literal"><span class="pre">lon2,lat2</span></tt></p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>del_s</td>
<td>points on great circle computed every del_s kilometers
(default 100).</td>
</tr>
<tr class="row-odd"><td>**kwargs</td>
<td>other keyword arguments are passed on to <a class="reference internal" href="#nansat.Nansatmap.plot" title="nansat.Nansatmap.plot"><tt class="xref py py-meth docutils literal"><span class="pre">plot()</span></tt></a>
method of Basemap instance.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Cannot handle situations in which the great circle intersects
the edge of the map projection domain, and then re-enters the domain.</p>
</div>
<p>Returns a matplotlib.lines.Line2D object.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.drawgrid">
<tt class="descname">drawgrid</tt><big>(</big><em>fontsize=10, lat_num=5, lon_num=5, lat_labels=[True, False, False, False], lon_labels=[False, False, True, False]</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.drawgrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw and label parallels (lat and lon lines) for values (in degrees)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fontsize</strong> : int</p>
<p><strong>lat_num</strong> : int</p>
<blockquote>
<div><p>Number of latitude lables</p>
</div></blockquote>
<p><strong>lon_num :</strong></p>
<blockquote>
<div><p>Number of longitude lables</p>
</div></blockquote>
<p><strong>lat_labels</strong> : list of Bool</p>
<blockquote>
<div><p>Location of latitude labels</p>
</div></blockquote>
<p><strong>lon_labels</strong> : list of Bool</p>
<blockquote class="last">
<div><p>Location of longitude labels</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<dl class="docutils">
<dt>Basemap.drawparallels() :</dt>
<dd><a class="reference external" href="http://matplotlib.org/basemap/api/basemap_api.html#mpl_toolkits.basemap.Basemap.drawparallels">http://matplotlib.org/basemap/api/basemap_api.html#mpl_toolkits.basemap.Basemap.drawparallels</a></dd>
<dt>Basemap.drawmeridians() :</dt>
<dd><a class="reference external" href="http://matplotlib.org/basemap/api/basemap_api.html#mpl_toolkits.basemap.Basemap.drawmeridians">http://matplotlib.org/basemap/api/basemap_api.html#mpl_toolkits.basemap.Basemap.drawmeridians</a></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.drawlsmask">
<tt class="descname">drawlsmask</tt><big>(</big><em>land_color='0.8'</em>, <em>ocean_color='w'</em>, <em>lsmask=None</em>, <em>lsmask_lons=None</em>, <em>lsmask_lats=None</em>, <em>lakes=True</em>, <em>resolution='l'</em>, <em>grid=5</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.drawlsmask" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw land-sea mask image.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The land-sea mask image cannot be overlaid on top
of other images, due to limitations in matplotlib image handling
(you can&#8217;t specify the zorder of an image).</p>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keywords</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>land_color</td>
<td>desired land color (color name or rgba tuple).
Default gray (&#8220;0.8&#8221;).</td>
</tr>
<tr class="row-odd"><td>ocean_color</td>
<td>desired water color (color name or rgba tuple).
Default white.</td>
</tr>
<tr class="row-even"><td>lsmask</td>
<td>An array of 0&#8217;s for ocean pixels, 1&#8217;s for
land pixels and 2&#8217;s for lake/pond pixels.
Default is None
(default 5-minute resolution land-sea mask is used).</td>
</tr>
<tr class="row-odd"><td>lakes</td>
<td>Plot lakes and ponds (Default True)</td>
</tr>
<tr class="row-even"><td>lsmask_lons</td>
<td>1d array of longitudes for lsmask (ignored
if lsmask is None). Longitudes must be ordered
from -180 W eastward.</td>
</tr>
<tr class="row-odd"><td>lsmask_lats</td>
<td>1d array of latitudes for lsmask (ignored
if lsmask is None). Latitudes must be ordered
from -90 S northward.</td>
</tr>
<tr class="row-even"><td>resolution</td>
<td>gshhs coastline resolution used to define land/sea
mask (default &#8216;l&#8217;, available &#8216;c&#8217;,&#8217;l&#8217;,&#8217;i&#8217;,&#8217;h&#8217; or &#8216;f&#8217;)</td>
</tr>
<tr class="row-odd"><td>grid</td>
<td>land/sea mask grid spacing in minutes (Default 5;
10, 2.5 and 1.25 are also available).</td>
</tr>
<tr class="row-even"><td>**kwargs</td>
<td>extra keyword arguments passed on to
<a class="reference internal" href="#nansat.Nansatmap.imshow" title="nansat.Nansatmap.imshow"><tt class="xref py py-meth docutils literal"><span class="pre">imshow()</span></tt></a></td>
</tr>
</tbody>
</table>
<p>If any of the lsmask, lsmask_lons or lsmask_lats keywords are not
set, the built in GSHHS land-sea mask datasets are used.</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>returns a matplotlib.image.AxesImage instance.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.drawmapboundary">
<tt class="descname">drawmapboundary</tt><big>(</big><em>color='k'</em>, <em>linewidth=1.0</em>, <em>fill_color=None</em>, <em>zorder=None</em>, <em>ax=None</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.drawmapboundary" title="Permalink to this definition">¶</a></dt>
<dd><p>draw boundary around map projection region, optionally
filling interior of region.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>linewidth</td>
<td>line width for boundary (default 1.)</td>
</tr>
<tr class="row-odd"><td>color</td>
<td>color of boundary line (default black)</td>
</tr>
<tr class="row-even"><td>fill_color</td>
<td>fill the map region background with this
color (default is to fill with axis
background color). If set to the string
&#8216;none&#8217;, no filling is done.</td>
</tr>
<tr class="row-odd"><td>zorder</td>
<td>sets the zorder for filling map background
(default 0).</td>
</tr>
<tr class="row-even"><td>ax</td>
<td>axes instance to use
(default None, use default axes instance).</td>
</tr>
</tbody>
</table>
<p>returns matplotlib.collections.PatchCollection representing map boundary.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.drawmapscale">
<tt class="descname">drawmapscale</tt><big>(</big><em>lon</em>, <em>lat</em>, <em>lon0</em>, <em>lat0</em>, <em>length</em>, <em>barstyle='simple'</em>, <em>units='km'</em>, <em>fontsize=9</em>, <em>yoffset=None</em>, <em>labelstyle='simple'</em>, <em>fontcolor='k'</em>, <em>fillcolor1='w'</em>, <em>fillcolor2='k'</em>, <em>ax=None</em>, <em>format='%d'</em>, <em>zorder=None</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.drawmapscale" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a map scale at <tt class="docutils literal"><span class="pre">lon,lat</span></tt> of length <tt class="docutils literal"><span class="pre">length</span></tt>
representing distance in the map
projection coordinates at <tt class="docutils literal"><span class="pre">lon0,lat0</span></tt>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keywords</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>units</td>
<td>the units of the length argument (Default km).</td>
</tr>
<tr class="row-odd"><td>barstyle</td>
<td><tt class="docutils literal"><span class="pre">simple</span></tt> or <tt class="docutils literal"><span class="pre">fancy</span></tt> (roughly corresponding
to the styles provided by Generic Mapping Tools).
Default <tt class="docutils literal"><span class="pre">simple</span></tt>.</td>
</tr>
<tr class="row-even"><td>fontsize</td>
<td>for map scale annotations, default 9.</td>
</tr>
<tr class="row-odd"><td>color</td>
<td>for map scale annotations, default black.</td>
</tr>
<tr class="row-even"><td>labelstype</td>
<td><tt class="docutils literal"><span class="pre">simple</span></tt> (default) or <tt class="docutils literal"><span class="pre">fancy</span></tt>.  For
<tt class="docutils literal"><span class="pre">fancy</span></tt> the map scale factor (ratio betwee
the actual distance and map projection distance
at lon0,lat0) and the value of lon0,lat0 are also
displayed on the top of the scale bar. For
<tt class="docutils literal"><span class="pre">simple</span></tt>, just the units are display on top
and the distance below the scale bar.
If equal to False, plot an empty label.</td>
</tr>
<tr class="row-odd"><td>format</td>
<td>a string formatter to format numeric values</td>
</tr>
<tr class="row-even"><td>yoffset</td>
<td>yoffset controls how tall the scale bar is,
and how far the annotations are offset from the
scale bar.  Default is 0.02 times the height of
the map (0.02*(self.ymax-self.ymin)).</td>
</tr>
<tr class="row-odd"><td>fillcolor1(2)</td>
<td>colors of the alternating filled regions
(default white and black).  Only relevant for
&#8216;fancy&#8217; barstyle.</td>
</tr>
<tr class="row-even"><td>zorder</td>
<td>sets the zorder for the map scale.</td>
</tr>
</tbody>
</table>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.drawmeridians">
<tt class="descname">drawmeridians</tt><big>(</big><em>meridians, color='k', linewidth=1.0, zorder=None, dashes=[1, 1], labels=[0, 0, 0, 0], labelstyle=None, fmt='%g', xoffset=None, yoffset=None, ax=None, latmax=None, **kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.drawmeridians" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw and label meridians (longitude lines) for values (in degrees)
given in the sequence <tt class="docutils literal"><span class="pre">meridians</span></tt>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>color</td>
<td>color to draw meridians (default black).</td>
</tr>
<tr class="row-odd"><td>linewidth</td>
<td>line width for meridians (default 1.)</td>
</tr>
<tr class="row-even"><td>zorder</td>
<td>sets the zorder for meridians (if not specified,
uses default zorder for matplotlib.lines.Line2D
objects).</td>
</tr>
<tr class="row-odd"><td>dashes</td>
<td>dash pattern for meridians (default [1,1], i.e.
1 pixel on, 1 pixel off).</td>
</tr>
<tr class="row-even"><td>labels</td>
<td>list of 4 values (default [0,0,0,0]) that control
whether meridians are labelled where they intersect
the left, right, top or bottom of the plot. For
example labels=[1,0,0,1] will cause meridians
to be labelled where they intersect the left and
and bottom of the plot, but not the right and top.</td>
</tr>
<tr class="row-odd"><td>labelstyle</td>
<td>if set to &#8220;+/-&#8221;, east and west longitudes are
labelled with &#8220;+&#8221; and &#8220;-&#8221;, otherwise they are
labelled with &#8220;E&#8221; and &#8220;W&#8221;.</td>
</tr>
<tr class="row-even"><td>fmt</td>
<td>a format string to format the meridian labels
(default &#8216;%g&#8217;) <strong>or</strong> a function that takes a
longitude value in degrees as it&#8217;s only argument
and returns a formatted string.</td>
</tr>
<tr class="row-odd"><td>xoffset</td>
<td>label offset from edge of map in x-direction
(default is 0.01 times width of map in map
projection coordinates).</td>
</tr>
<tr class="row-even"><td>yoffset</td>
<td>label offset from edge of map in y-direction
(default is 0.01 times height of map in map
projection coordinates).</td>
</tr>
<tr class="row-odd"><td>ax</td>
<td>axes instance (overrides default axes instance)</td>
</tr>
<tr class="row-even"><td>latmax</td>
<td>absolute value of latitude to which meridians are drawn
(default is 80).</td>
</tr>
<tr class="row-odd"><td>**kwargs</td>
<td>additional keyword arguments controlling text
for labels that are passed on to
the text method of the axes instance (see
matplotlib.pyplot.text documentation).</td>
</tr>
</tbody>
</table>
<p>returns a dictionary whose keys are the meridian values, and
whose values are tuples containing lists of the
matplotlib.lines.Line2D and matplotlib.text.Text instances
associated with each meridian. Deleting an item from the
dictionary removes the correpsonding meridian from the plot.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.drawparallels">
<tt class="descname">drawparallels</tt><big>(</big><em>circles, color='k', linewidth=1.0, zorder=None, dashes=[1, 1], labels=[0, 0, 0, 0], labelstyle=None, fmt='%g', xoffset=None, yoffset=None, ax=None, latmax=None, **kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.drawparallels" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw and label parallels (latitude lines) for values (in degrees)
given in the sequence <tt class="docutils literal"><span class="pre">circles</span></tt>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>color</td>
<td>color to draw parallels (default black).</td>
</tr>
<tr class="row-odd"><td>linewidth</td>
<td>line width for parallels (default 1.)</td>
</tr>
<tr class="row-even"><td>zorder</td>
<td>sets the zorder for parallels (if not specified,
uses default zorder for matplotlib.lines.Line2D
objects).</td>
</tr>
<tr class="row-odd"><td>dashes</td>
<td>dash pattern for parallels (default [1,1], i.e.
1 pixel on, 1 pixel off).</td>
</tr>
<tr class="row-even"><td>labels</td>
<td>list of 4 values (default [0,0,0,0]) that control
whether parallels are labelled where they intersect
the left, right, top or bottom of the plot. For
example labels=[1,0,0,1] will cause parallels
to be labelled where they intersect the left and
and bottom of the plot, but not the right and top.</td>
</tr>
<tr class="row-odd"><td>labelstyle</td>
<td>if set to &#8220;+/-&#8221;, north and south latitudes are
labelled with &#8220;+&#8221; and &#8220;-&#8221;, otherwise they are
labelled with &#8220;N&#8221; and &#8220;S&#8221;.</td>
</tr>
<tr class="row-even"><td>fmt</td>
<td>a format string to format the parallel labels
(default &#8216;%g&#8217;) <strong>or</strong> a function that takes a
latitude value in degrees as it&#8217;s only argument
and returns a formatted string.</td>
</tr>
<tr class="row-odd"><td>xoffset</td>
<td>label offset from edge of map in x-direction
(default is 0.01 times width of map in map
projection coordinates).</td>
</tr>
<tr class="row-even"><td>yoffset</td>
<td>label offset from edge of map in y-direction
(default is 0.01 times height of map in map
projection coordinates).</td>
</tr>
<tr class="row-odd"><td>ax</td>
<td>axes instance (overrides default axes instance)</td>
</tr>
<tr class="row-even"><td>latmax</td>
<td>absolute value of latitude to which meridians are drawn
(default is 80).</td>
</tr>
<tr class="row-odd"><td>**kwargs</td>
<td>additional keyword arguments controlling text
for labels that are passed on to
the text method of the axes instance (see
matplotlib.pyplot.text documentation).</td>
</tr>
</tbody>
</table>
<p>returns a dictionary whose keys are the parallel values, and
whose values are tuples containing lists of the
matplotlib.lines.Line2D and matplotlib.text.Text instances
associated with each parallel. Deleting an item from the
dictionary removes the corresponding parallel from the plot.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.drawrivers">
<tt class="descname">drawrivers</tt><big>(</big><em>linewidth=0.5</em>, <em>linestyle='solid'</em>, <em>color='k'</em>, <em>antialiased=1</em>, <em>ax=None</em>, <em>zorder=None</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.drawrivers" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw major rivers.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>linewidth</td>
<td>river boundary line width (default 0.5)</td>
</tr>
<tr class="row-odd"><td>linestyle</td>
<td>coastline linestyle (default solid)</td>
</tr>
<tr class="row-even"><td>color</td>
<td>river boundary line color (default black)</td>
</tr>
<tr class="row-odd"><td>antialiased</td>
<td>antialiasing switch for river boundaries (default
True).</td>
</tr>
<tr class="row-even"><td>ax</td>
<td>axes instance (overrides default axes instance)</td>
</tr>
<tr class="row-odd"><td>zorder</td>
<td>sets the zorder for the rivers (if not
specified uses default zorder for
matplotlib.patches.LineCollections).</td>
</tr>
</tbody>
</table>
<p>returns a matplotlib.patches.LineCollection object.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.drawstates">
<tt class="descname">drawstates</tt><big>(</big><em>linewidth=0.5</em>, <em>linestyle='solid'</em>, <em>color='k'</em>, <em>antialiased=1</em>, <em>ax=None</em>, <em>zorder=None</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.drawstates" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw state boundaries in Americas.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>linewidth</td>
<td>state boundary line width (default 0.5)</td>
</tr>
<tr class="row-odd"><td>linestyle</td>
<td>coastline linestyle (default solid)</td>
</tr>
<tr class="row-even"><td>color</td>
<td>state boundary line color (default black)</td>
</tr>
<tr class="row-odd"><td>antialiased</td>
<td>antialiasing switch for state boundaries
(default True).</td>
</tr>
<tr class="row-even"><td>ax</td>
<td>axes instance (overrides default axes instance)</td>
</tr>
<tr class="row-odd"><td>zorder</td>
<td>sets the zorder for the state boundaries (if not
specified, uses default zorder for
matplotlib.patches.LineCollections).</td>
</tr>
</tbody>
</table>
<p>returns a matplotlib.patches.LineCollection object.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.etopo">
<tt class="descname">etopo</tt><big>(</big><em>ax=None</em>, <em>scale=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.etopo" title="Permalink to this definition">¶</a></dt>
<dd><p>display etopo relief image (from
<a class="reference external" href="http://www.ngdc.noaa.gov/mgg/global/global.html">http://www.ngdc.noaa.gov/mgg/global/global.html</a>)
as map background.
Default image size is 5400x2700, which can be quite slow and
use quite a bit of memory.  The <tt class="docutils literal"><span class="pre">scale</span></tt> keyword can be used
to downsample the image (<tt class="docutils literal"><span class="pre">scale=0.5</span></tt> downsamples to 5400x2700).</p>
<p>**kwargs passed on to <a class="reference internal" href="#nansat.Nansatmap.imshow" title="nansat.Nansatmap.imshow"><tt class="xref py py-meth docutils literal"><span class="pre">imshow()</span></tt></a>.</p>
<p>returns a matplotlib.image.AxesImage instance.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.fillcontinents">
<tt class="descname">fillcontinents</tt><big>(</big><em>color='0.8'</em>, <em>lake_color=None</em>, <em>ax=None</em>, <em>zorder=None</em>, <em>alpha=None</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.fillcontinents" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill continents.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>color</td>
<td>color to fill continents (default gray).</td>
</tr>
<tr class="row-odd"><td>lake_color</td>
<td>color to fill inland lakes (default axes background).</td>
</tr>
<tr class="row-even"><td>ax</td>
<td>axes instance (overrides default axes instance).</td>
</tr>
<tr class="row-odd"><td>zorder</td>
<td>sets the zorder for the continent polygons (if not
specified, uses default zorder for a Polygon patch).
Set to zero if you want to paint over the filled
continents).</td>
</tr>
<tr class="row-even"><td>alpha</td>
<td>sets alpha transparency for continent polygons</td>
</tr>
</tbody>
</table>
<p>After filling continents, lakes are re-filled with
axis background color.</p>
<p>returns a list of matplotlib.patches.Polygon objects.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.gcpoints">
<tt class="descname">gcpoints</tt><big>(</big><em>lon1</em>, <em>lat1</em>, <em>lon2</em>, <em>lat2</em>, <em>npoints</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.gcpoints" title="Permalink to this definition">¶</a></dt>
<dd><p>compute <tt class="docutils literal"><span class="pre">points</span></tt> points along a great circle with endpoints
<tt class="docutils literal"><span class="pre">(lon1,lat1)</span></tt> and <tt class="docutils literal"><span class="pre">(lon2,lat2)</span></tt>.</p>
<p>Returns arrays x,y with map projection coordinates.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.hexbin">
<tt class="descname">hexbin</tt><big>(</big><em>x</em>, <em>y</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.hexbin" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a hexagonal binning plot of x versus y, where x, y are 1-D
sequences of the same length, N. If C is None (the default), this is a
histogram of the number of occurences of the observations at
(x[i],y[i]).</p>
<p>If C is specified, it specifies values at the coordinate (x[i],y[i]).
These values are accumulated for each hexagonal bin and then reduced
according to reduce_C_function, which defaults to the numpy mean function
(np.mean). (If C is specified, it must also be a 1-D sequence of the
same length as x and y.)</p>
<p>x, y and/or C may be masked arrays, in which case only unmasked points
will be plotted.</p>
<p>(see matplotlib.pyplot.hexbin documentation).</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>Other **kwargs passed on to matplotlib.pyplot.hexbin</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.imshow">
<tt class="descname">imshow</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.imshow" title="Permalink to this definition">¶</a></dt>
<dd><p>Display an image over the map
(see matplotlib.pyplot.imshow documentation).</p>
<p><tt class="docutils literal"><span class="pre">extent</span></tt> and <tt class="docutils literal"><span class="pre">origin</span></tt> keywords set automatically so image
will be drawn over map region.</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>Other **kwargs passed on to matplotlib.pyplot.plot.</p>
<p>returns an matplotlib.image.AxesImage instance.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.is_land">
<tt class="descname">is_land</tt><big>(</big><em>xpt</em>, <em>ypt</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.is_land" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the given x,y point (in projection coordinates) is
over land, False otherwise.  The definition of land is based upon
the GSHHS coastline polygons associated with the class instance.
Points over lakes inside land regions are not counted as land points.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.makegrid">
<tt class="descname">makegrid</tt><big>(</big><em>nx</em>, <em>ny</em>, <em>returnxy=False</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.makegrid" title="Permalink to this definition">¶</a></dt>
<dd><p>return arrays of shape (ny,nx) containing lon,lat coordinates of
an equally spaced native projection grid.</p>
<p>If <tt class="docutils literal"><span class="pre">returnxy</span> <span class="pre">=</span> <span class="pre">True</span></tt>, the x,y values of the grid are returned also.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.nightshade">
<tt class="descname">nightshade</tt><big>(</big><em>date</em>, <em>color='k'</em>, <em>delta=0.25</em>, <em>alpha=0.5</em>, <em>ax=None</em>, <em>zorder=2</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.nightshade" title="Permalink to this definition">¶</a></dt>
<dd><p>Shade the regions of the map that are in darkness at the time
specifed by <tt class="docutils literal"><span class="pre">date</span></tt>.  <tt class="docutils literal"><span class="pre">date</span></tt> is a datetime instance,
assumed to be UTC.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keywords</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>color</td>
<td>color to shade night regions (default black).</td>
</tr>
<tr class="row-odd"><td>delta</td>
<td>day/night terminator is computed with a
a resolution of <tt class="docutils literal"><span class="pre">delta</span></tt> degrees (default 0.25).</td>
</tr>
<tr class="row-even"><td>alpha</td>
<td>alpha transparency for shading (default 0.5, so
map background shows through).</td>
</tr>
<tr class="row-odd"><td>zorder</td>
<td>zorder for shading (default 2).</td>
</tr>
</tbody>
</table>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>returns a matplotlib.contour.ContourSet instance.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.pcolor">
<tt class="descname">pcolor</tt><big>(</big><em>x</em>, <em>y</em>, <em>data</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.pcolor" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a pseudo-color plot over the map
(see matplotlib.pyplot.pcolor documentation).</p>
<p>If <tt class="docutils literal"><span class="pre">latlon</span></tt> keyword is set to True, x,y are intrepreted as
longitude and latitude in degrees.  Data and longitudes are
automatically shifted to match map projection region for cylindrical
and pseudocylindrical projections, and x,y are transformed to map
projection coordinates. If <tt class="docutils literal"><span class="pre">latlon</span></tt> is False (default), x and y
are assumed to be map projection coordinates.</p>
<p>If x or y are outside projection limb (i.e. they have values &gt; 1.e20)
they will be convert to masked arrays with those values masked.
As a result, those values will not be plotted.</p>
<p>If <tt class="docutils literal"><span class="pre">tri</span></tt> is set to <tt class="docutils literal"><span class="pre">True</span></tt>, an unstructured grid is assumed
(x,y,data must be 1-d) and matplotlib.pyplot.tricolor is used.</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>Other **kwargs passed on to matplotlib.pyplot.pcolor (or tricolor if
<tt class="docutils literal"><span class="pre">tri=True</span></tt>).</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.pcolormesh">
<tt class="descname">pcolormesh</tt><big>(</big><em>data</em>, <em>validValues=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.pcolormesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a pseudo-color plot over the map</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : numpy 2D array</p>
<blockquote>
<div><p>Input data</p>
</div></blockquote>
<p><strong>validValues</strong> : list with two scalars (e.g. [min, max])</p>
<blockquote>
<div><p>minimum and maximum valid values</p>
</div></blockquote>
<p><strong>Parameters of Basemap.pcolormesh</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.mpl</strong> : list</p>
<blockquote class="last">
<div><p>append matplotlib.collections.QuadMesh object</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.plot">
<tt class="descname">plot</tt><big>(</big><em>x</em>, <em>y</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw lines and/or markers on the map
(see matplotlib.pyplot.plot documentation).</p>
<p>If <tt class="docutils literal"><span class="pre">latlon</span></tt> keyword is set to True, x,y are intrepreted as
longitude and latitude in degrees.  Data and longitudes are
automatically shifted to match map projection region for cylindrical
and pseudocylindrical projections, and x,y are transformed to map
projection coordinates. If <tt class="docutils literal"><span class="pre">latlon</span></tt> is False (default), x and y
are assumed to be map projection coordinates.</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>Other **kwargs passed on to matplotlib.pyplot.plot.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.quiver">
<tt class="descname">quiver</tt><big>(</big><em>dataX</em>, <em>dataY</em>, <em>quivectors=30</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.quiver" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw quiver plots</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dataX</strong> :  numpy array</p>
<blockquote>
<div><p>Input data with X-component</p>
</div></blockquote>
<p><strong>dataY</strong> :  numpy array</p>
<blockquote>
<div><p>Input data with Y-component</p>
</div></blockquote>
<p><strong>quivectors</strong> : int</p>
<blockquote>
<div><p>Number of vectors along both dimentions</p>
</div></blockquote>
<p><strong>Parameters of Basemap.quiver()</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.mpl</strong> : list</p>
<blockquote class="last">
<div><p>append matplotlib.quiver.Quiver instance</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.readshapefile">
<tt class="descname">readshapefile</tt><big>(</big><em>shapefile</em>, <em>name</em>, <em>drawbounds=True</em>, <em>zorder=None</em>, <em>linewidth=0.5</em>, <em>color='k'</em>, <em>antialiased=1</em>, <em>ax=None</em>, <em>default_encoding='utf-8'</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.readshapefile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read in shape file, optionally draw boundaries on map.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>Assumes shapes are 2D</li>
<li>only works for Point, MultiPoint, Polyline and Polygon shapes.</li>
<li>vertices/points must be in geographic (lat/lon) coordinates.</li>
</ul>
</div>
<p>Mandatory Arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Argument</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>shapefile</td>
<td>path to shapefile components.  Example:
shapefile=&#8217;/home/jeff/esri/world_borders&#8217; assumes
that world_borders.shp, world_borders.shx and
world_borders.dbf live in /home/jeff/esri.</td>
</tr>
<tr class="row-odd"><td>name</td>
<td>name for Basemap attribute to hold the shapefile
vertices or points in map projection
coordinates. Class attribute name+&#8217;_info&#8217; is a list
of dictionaries, one for each shape, containing
attributes of each shape from dbf file, For
example, if name=&#8217;counties&#8217;, self.counties
will be a list of x,y vertices for each shape in
map projection  coordinates and self.counties_info
will be a list of dictionaries with shape
attributes.  Rings in individual Polygon
shapes are split out into separate polygons, and
additional keys &#8216;RINGNUM&#8217; and &#8216;SHAPENUM&#8217; are added
to the shape attribute dictionary.</td>
</tr>
</tbody>
</table>
<p>The following optional keyword arguments are only relevant for Polyline
and Polygon shape types, for Point and MultiPoint shapes they are
ignored.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>drawbounds</td>
<td>draw boundaries of shapes (default True).</td>
</tr>
<tr class="row-odd"><td>zorder</td>
<td>shape boundary zorder (if not specified,
default for mathplotlib.lines.LineCollection
is used).</td>
</tr>
<tr class="row-even"><td>linewidth</td>
<td>shape boundary line width (default 0.5)</td>
</tr>
<tr class="row-odd"><td>color</td>
<td>shape boundary line color (default black)</td>
</tr>
<tr class="row-even"><td>antialiased</td>
<td>antialiasing switch for shape boundaries
(default True).</td>
</tr>
<tr class="row-odd"><td>ax</td>
<td>axes instance (overrides default axes instance)</td>
</tr>
</tbody>
</table>
<p>A tuple (num_shapes, type, min, max) containing shape file info
is returned.
num_shapes is the number of shapes, type is the type code (one of
the SHPT* constants defined in the shapelib module, see
<a class="reference external" href="http://shapelib.maptools.org/shp_api.html">http://shapelib.maptools.org/shp_api.html</a>) and min and
max are 4-element lists with the minimum and maximum values of the
vertices. If <tt class="docutils literal"><span class="pre">drawbounds=True</span></tt> a
matplotlib.patches.LineCollection object is appended to the tuple.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.rotate_vector">
<tt class="descname">rotate_vector</tt><big>(</big><em>uin</em>, <em>vin</em>, <em>lons</em>, <em>lats</em>, <em>returnxy=False</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.rotate_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate a vector field (<tt class="docutils literal"><span class="pre">uin,vin</span></tt>) on a rectilinear grid
with longitudes = <tt class="docutils literal"><span class="pre">lons</span></tt> and latitudes = <tt class="docutils literal"><span class="pre">lats</span></tt> from
geographical (lat/lon) into map projection (x/y) coordinates.</p>
<p>Differs from transform_vector in that no interpolation is done.
The vector is returned on the same grid, but rotated into
x,y coordinates.</p>
<p>The input vector field is defined in spherical coordinates (it
has eastward and northward components) while the output
vector field is rotated to map projection coordinates (relative
to x and y). The magnitude of the vector is preserved.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Arguments</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>uin, vin</td>
<td>input vector field on a lat/lon grid.</td>
</tr>
<tr class="row-odd"><td>lons, lats</td>
<td>Arrays containing longitudes and latitudes
(in degrees) of input data in increasing order.
For non-cylindrical projections (those other than
<tt class="docutils literal"><span class="pre">cyl</span></tt>, <tt class="docutils literal"><span class="pre">merc</span></tt>, <tt class="docutils literal"><span class="pre">cyl</span></tt>, <tt class="docutils literal"><span class="pre">gall</span></tt> and <tt class="docutils literal"><span class="pre">mill</span></tt>) lons
must fit within range -180 to 180.</td>
</tr>
</tbody>
</table>
<p>Returns <tt class="docutils literal"><span class="pre">uout,</span> <span class="pre">vout</span></tt> (rotated vector field).
If the optional keyword argument
<tt class="docutils literal"><span class="pre">returnxy</span></tt> is True (default is False),
returns <tt class="docutils literal"><span class="pre">uout,vout,x,y</span></tt> (where <tt class="docutils literal"><span class="pre">x,y</span></tt> are the map projection
coordinates of the grid defined by <tt class="docutils literal"><span class="pre">lons,lats</span></tt>).</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.save">
<tt class="descname">save</tt><big>(</big><em>fileName</em>, <em>landmask=True</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw continents and save</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : string</p>
<blockquote>
<div><p>name of outputfile</p>
</div></blockquote>
<p><strong>landmask</strong> : Boolean</p>
<blockquote>
<div><p>Draw landmask?</p>
</div></blockquote>
<p class="last"><strong>Parameters of basemap.fillcontinents</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.scatter">
<tt class="descname">scatter</tt><big>(</big><em>x</em>, <em>y</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.scatter" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot points with markers on the map
(see matplotlib.pyplot.scatter documentation).</p>
<p>If <tt class="docutils literal"><span class="pre">latlon</span></tt> keyword is set to True, x,y are intrepreted as
longitude and latitude in degrees.  Data and longitudes are
automatically shifted to match map projection region for cylindrical
and pseudocylindrical projections, and x,y are transformed to map
projection coordinates. If <tt class="docutils literal"><span class="pre">latlon</span></tt> is False (default), x and y
are assumed to be map projection coordinates.</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axes instance.</p>
<p>Other **kwargs passed on to matplotlib.pyplot.scatter.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.set_axes_limits">
<tt class="descname">set_axes_limits</tt><big>(</big><em>ax=None</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.set_axes_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Final step in Basemap method wrappers of Axes plotting methods:</p>
<p>Set axis limits, fix aspect ratio for map domain using current
or specified axes instance.  This is done only once per axes
instance.</p>
<p>In interactive mode, this method always calls draw_if_interactive
before returning.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.shadedrelief">
<tt class="descname">shadedrelief</tt><big>(</big><em>ax=None</em>, <em>scale=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.shadedrelief" title="Permalink to this definition">¶</a></dt>
<dd><p>display shaded relief image (from <a class="reference external" href="http://www.shadedrelief.com">http://www.shadedrelief.com</a>)
as map background.
Default image size is 10800x5400, which can be quite slow and
use quite a bit of memory.  The <tt class="docutils literal"><span class="pre">scale</span></tt> keyword can be used
to downsample the image (<tt class="docutils literal"><span class="pre">scale=0.5</span></tt> downsamples to 5400x2700).</p>
<p>**kwargs passed on to <a class="reference internal" href="#nansat.Nansatmap.imshow" title="nansat.Nansatmap.imshow"><tt class="xref py py-meth docutils literal"><span class="pre">imshow()</span></tt></a>.</p>
<p>returns a matplotlib.image.AxesImage instance.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.shiftdata">
<tt class="descname">shiftdata</tt><big>(</big><em>lonsin</em>, <em>datain=None</em>, <em>lon_0=None</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.shiftdata" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift longitudes (and optionally data) so that they match map projection region.
Only valid for cylindrical/pseudo-cylindrical global projections and data
on regular lat/lon grids. longitudes and data can be 1-d or 2-d, if 2-d
it is assumed longitudes are 2nd (rightmost) dimension.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Arguments</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>lonsin</td>
<td>original 1-d or 2-d longitudes.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keywords</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>datain</td>
<td>original 1-d or 2-d data. Default None.</td>
</tr>
<tr class="row-odd"><td>lon_0</td>
<td>center of map projection region. Defaut None,
given by current map projection.</td>
</tr>
</tbody>
</table>
<p>if datain given, returns <tt class="docutils literal"><span class="pre">dataout,lonsout</span></tt> (data and longitudes shifted to fit in interval
[lon_0-180,lon_0+180]), otherwise just returns longitudes.  If
transformed longitudes lie outside map projection region, data is
masked and longitudes are set to 1.e30.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.smooth">
<tt class="descname">smooth</tt><big>(</big><em>idata</em>, <em>mode</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.smooth" title="Permalink to this definition">¶</a></dt>
<dd><p>Smooth data for contour() and contourf()</p>
<p>idata is smoothed by convolve, fourier_gaussian, spline or
gaussian (default). If contour_mode is &#8216;convolve&#8217; and weight is None,
the weight matrix is created automatically.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>idata</strong> : numpy 2D array</p>
<blockquote>
<div><p>Input data</p>
</div></blockquote>
<p><strong>mode</strong> : string</p>
<blockquote>
<div><p>&#8216;convolve&#8217;,&#8217;fourier&#8217;,&#8217;spline&#8217; or &#8216;gaussian&#8217;</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>odata</strong> : numpy 2D array</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<dl class="docutils">
<dt>scipy.ndimage() :</dt>
<dd><a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/ndimage.html">http://docs.scipy.org/doc/scipy/reference/ndimage.html</a></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.streamplot">
<tt class="descname">streamplot</tt><big>(</big><em>x</em>, <em>y</em>, <em>u</em>, <em>v</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.streamplot" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws streamlines of a vector flow.
(see matplotlib.pyplot.streamplot documentation).</p>
<p>If <tt class="docutils literal"><span class="pre">latlon</span></tt> keyword is set to True, x,y are intrepreted as
longitude and latitude in degrees.  Data and longitudes are
automatically shifted to match map projection region for cylindrical
and pseudocylindrical projections, and x,y are transformed to map
projection coordinates. If <tt class="docutils literal"><span class="pre">latlon</span></tt> is False (default), x and y
are assumed to be map projection coordinates.</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>Other *args and **kwargs passed on to matplotlib.pyplot.streamplot.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.tissot">
<tt class="descname">tissot</tt><big>(</big><em>lon_0</em>, <em>lat_0</em>, <em>radius_deg</em>, <em>npts</em>, <em>ax=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.tissot" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a polygon centered at <tt class="docutils literal"><span class="pre">lon_0,lat_0</span></tt>.  The polygon
approximates a circle on the surface of the earth with radius
<tt class="docutils literal"><span class="pre">radius_deg</span></tt> degrees latitude along longitude <tt class="docutils literal"><span class="pre">lon_0</span></tt>,
made up of <tt class="docutils literal"><span class="pre">npts</span></tt> vertices.
The polygon represents a Tissot&#8217;s indicatrix
(<a class="reference external" href="http://en.wikipedia.org/wiki/Tissot's_Indicatrix">http://en.wikipedia.org/wiki/Tissot&#8217;s_Indicatrix</a>),
which when drawn on a map shows the distortion
inherent in the map projection.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Cannot handle situations in which the polygon intersects
the edge of the map projection domain, and then re-enters the domain.</p>
</div>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>Other **kwargs passed on to matplotlib.patches.Polygon.</p>
<p>returns a matplotlib.patches.Polygon object.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.transform_scalar">
<tt class="descname">transform_scalar</tt><big>(</big><em>datin</em>, <em>lons</em>, <em>lats</em>, <em>nx</em>, <em>ny</em>, <em>returnxy=False</em>, <em>checkbounds=False</em>, <em>order=1</em>, <em>masked=False</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.transform_scalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate a scalar field (<tt class="docutils literal"><span class="pre">datin</span></tt>) from a lat/lon grid with
longitudes = <tt class="docutils literal"><span class="pre">lons</span></tt> and latitudes = <tt class="docutils literal"><span class="pre">lats</span></tt> to a <tt class="docutils literal"><span class="pre">ny</span></tt> by <tt class="docutils literal"><span class="pre">nx</span></tt>
map projection grid.  Typically used to transform data to
map projection coordinates for plotting on a map with
the <a class="reference internal" href="#nansat.Nansatmap.imshow" title="nansat.Nansatmap.imshow"><tt class="xref py py-meth docutils literal"><span class="pre">imshow()</span></tt></a>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Argument</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>datin</td>
<td>input data on a lat/lon grid.</td>
</tr>
<tr class="row-odd"><td>lons, lats</td>
<td>rank-1 arrays containing longitudes and latitudes
(in degrees) of input data in increasing order.
For non-cylindrical projections (those other than
<tt class="docutils literal"><span class="pre">cyl</span></tt>, <tt class="docutils literal"><span class="pre">merc</span></tt>, <tt class="docutils literal"><span class="pre">cea</span></tt>, <tt class="docutils literal"><span class="pre">gall</span></tt> and <tt class="docutils literal"><span class="pre">mill</span></tt>) lons
must fit within range -180 to 180.</td>
</tr>
<tr class="row-even"><td>nx, ny</td>
<td>The size of the output regular grid in map
projection coordinates</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>returnxy</td>
<td>If True, the x and y values of the map
projection grid are also returned (Default False).</td>
</tr>
<tr class="row-odd"><td>checkbounds</td>
<td>If True, values of lons and lats are checked to see
that they lie within the map projection region.
Default is False, and data outside map projection
region is clipped to values on boundary.</td>
</tr>
<tr class="row-even"><td>masked</td>
<td>If True, interpolated data is returned as a masked
array with values outside map projection region
masked (Default False).</td>
</tr>
<tr class="row-odd"><td>order</td>
<td>0 for nearest-neighbor interpolation, 1 for
bilinear, 3 for cubic spline (Default 1).
Cubic spline interpolation requires scipy.ndimage.</td>
</tr>
</tbody>
</table>
<p>Returns <tt class="docutils literal"><span class="pre">datout</span></tt> (data on map projection grid).
If returnxy=True, returns <tt class="docutils literal"><span class="pre">data,x,y</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.transform_vector">
<tt class="descname">transform_vector</tt><big>(</big><em>uin</em>, <em>vin</em>, <em>lons</em>, <em>lats</em>, <em>nx</em>, <em>ny</em>, <em>returnxy=False</em>, <em>checkbounds=False</em>, <em>order=1</em>, <em>masked=False</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.transform_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate and interpolate a vector field (<tt class="docutils literal"><span class="pre">uin,vin</span></tt>) from a
lat/lon grid with longitudes = <tt class="docutils literal"><span class="pre">lons</span></tt> and latitudes = <tt class="docutils literal"><span class="pre">lats</span></tt>
to a <tt class="docutils literal"><span class="pre">ny</span></tt> by <tt class="docutils literal"><span class="pre">nx</span></tt> map projection grid.</p>
<p>The input vector field is defined in spherical coordinates (it
has eastward and northward components) while the output
vector field is rotated to map projection coordinates (relative
to x and y). The magnitude of the vector is preserved.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Arguments</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>uin, vin</td>
<td>input vector field on a lat/lon grid.</td>
</tr>
<tr class="row-odd"><td>lons, lats</td>
<td>rank-1 arrays containing longitudes and latitudes
(in degrees) of input data in increasing order.
For non-cylindrical projections (those other than
<tt class="docutils literal"><span class="pre">cyl</span></tt>, <tt class="docutils literal"><span class="pre">merc</span></tt>, <tt class="docutils literal"><span class="pre">cea</span></tt>, <tt class="docutils literal"><span class="pre">gall</span></tt> and <tt class="docutils literal"><span class="pre">mill</span></tt>) lons
must fit within range -180 to 180.</td>
</tr>
<tr class="row-even"><td>nx, ny</td>
<td>The size of the output regular grid in map
projection coordinates</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>returnxy</td>
<td>If True, the x and y values of the map
projection grid are also returned (Default False).</td>
</tr>
<tr class="row-odd"><td>checkbounds</td>
<td>If True, values of lons and lats are checked to see
that they lie within the map projection region.
Default is False, and data outside map projection
region is clipped to values on boundary.</td>
</tr>
<tr class="row-even"><td>masked</td>
<td>If True, interpolated data is returned as a masked
array with values outside map projection region
masked (Default False).</td>
</tr>
<tr class="row-odd"><td>order</td>
<td>0 for nearest-neighbor interpolation, 1 for
bilinear, 3 for cubic spline (Default 1).
Cubic spline interpolation requires scipy.ndimage.</td>
</tr>
</tbody>
</table>
<p>Returns <tt class="docutils literal"><span class="pre">uout,</span> <span class="pre">vout</span></tt> (vector field on map projection grid).
If returnxy=True, returns <tt class="docutils literal"><span class="pre">uout,vout,x,y</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.warpimage">
<tt class="descname">warpimage</tt><big>(</big><em>image='bluemarble'</em>, <em>scale=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.warpimage" title="Permalink to this definition">¶</a></dt>
<dd><p>Display an image (filename given by <tt class="docutils literal"><span class="pre">image</span></tt> keyword) as a map background.
If image is a URL (starts with &#8216;http&#8217;), it is downloaded to a temp
file using urllib.urlretrieve.</p>
<p>Default (if <tt class="docutils literal"><span class="pre">image</span></tt> not specified) is to display
&#8216;blue marble next generation&#8217; image from <a class="reference external" href="http://visibleearth.nasa.gov/">http://visibleearth.nasa.gov/</a>.</p>
<p>Specified image must have pixels covering the whole globe in a regular
lat/lon grid, starting and -180W and the South Pole.
Works with the global images from
<a class="reference external" href="http://earthobservatory.nasa.gov/Features/BlueMarble/BlueMarble_monthlies.php">http://earthobservatory.nasa.gov/Features/BlueMarble/BlueMarble_monthlies.php</a>.</p>
<p>The <tt class="docutils literal"><span class="pre">scale</span></tt> keyword can be used to downsample (rescale) the image.
Values less than 1.0 will speed things up at the expense of image
resolution.</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>**kwargs passed on to <a class="reference internal" href="#nansat.Nansatmap.imshow" title="nansat.Nansatmap.imshow"><tt class="xref py py-meth docutils literal"><span class="pre">imshow()</span></tt></a>.</p>
<p>returns a matplotlib.image.AxesImage instance.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.wmsimage">
<tt class="descname">wmsimage</tt><big>(</big><em>server</em>, <em>xpixels=400</em>, <em>ypixels=None</em>, <em>format='png'</em>, <em>verbose=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.wmsimage" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve an image using from a WMS server using the
Open Geospatial Consortium (OGC) standard interface
and display on the map. Requires OWSLib
(<a class="reference external" href="http://pypi.python.org/pypi/OWSLib">http://pypi.python.org/pypi/OWSLib</a>).
In order to use this method, the Basemap instance must be
created using the <tt class="docutils literal"><span class="pre">epsg</span></tt> keyword to define the map projection, unless
the <tt class="docutils literal"><span class="pre">cyl</span></tt> projection is used (in which case the epsg code 4326 is
assumed).</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keywords</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>server</td>
<td>WMS server URL.</td>
</tr>
<tr class="row-odd"><td>xpixels</td>
<td>requested number of image pixels in x-direction
(default 400).</td>
</tr>
<tr class="row-even"><td>ypixels</td>
<td>requested number of image pixels in y-direction.
Default (None) is to infer the number from
from xpixels and the aspect ratio of the
map projection region.</td>
</tr>
<tr class="row-odd"><td>format</td>
<td>desired image format (default &#8216;png&#8217;)</td>
</tr>
<tr class="row-even"><td>verbose</td>
<td>if True, print WMS server info (default
False).</td>
</tr>
<tr class="row-odd"><td>**kwargs</td>
<td>extra keyword arguments passed on to
OWSLib.wms.WebMapService.getmap.</td>
</tr>
</tbody>
</table>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>returns a matplotlib.image.AxesImage instance.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nansat.Mosaic">
<em class="property">class </em><tt class="descclassname">nansat.</tt><tt class="descname">Mosaic</tt><big>(</big><em>fileName=''</em>, <em>mapperName=''</em>, <em>domain=None</em>, <em>array=None</em>, <em>parameters=None</em>, <em>logLevel=30</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Mosaic" title="Permalink to this definition">¶</a></dt>
<dd><p>Create Nansat object</p>
<div class="line-block">
<div class="line">if &lt;fileName&gt; is given:</div>
<div class="line-block">
<div class="line">Open GDAL dataset,</div>
<div class="line">Read metadata,</div>
<div class="line">Generate GDAL VRT file with mapping of variables in memory</div>
<div class="line">Create logger</div>
<div class="line">Create Nansat object for perfroming high-level operations</div>
</div>
<div class="line">if &lt;domain&gt; and &lt;array&gt; are given:</div>
<div class="line-block">
<div class="line">Create VRT object from data in &lt;array&gt;</div>
<div class="line">Add geolocation from &lt;domain&gt;</div>
</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : string</p>
<blockquote>
<div><p>location of the file</p>
</div></blockquote>
<p><strong>mapperName</strong> : string, optional</p>
<blockquote>
<div><p>name of the mapper from nansat/mappers dir. E.g.
&#8216;ASAR&#8217;, &#8216;hirlam&#8217;, &#8216;merisL1&#8217;, &#8216;merisL2&#8217;, etc.</p>
</div></blockquote>
<p><strong>domain</strong> : Domain object</p>
<blockquote>
<div><p>Geo-reference of a new raster</p>
</div></blockquote>
<p><strong>array</strong> : numpy array</p>
<blockquote>
<div><p>Firts band of a new raster</p>
</div></blockquote>
<p><strong>parameters</strong> : dictionary</p>
<blockquote>
<div><p>Metadata for the 1st band of a new raster,e.g. name, wkv, units,...</p>
</div></blockquote>
<p><strong>logLevel</strong> : int, optional, default: logging.DEBUG (30)</p>
<blockquote>
<div><p>Level of logging. See: <a class="reference external" href="http://docs.python.org/howto/logging.html">http://docs.python.org/howto/logging.html</a></p>
</div></blockquote>
<p class="last"><strong>kwargs</strong> : additional arguments for mappers</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="89%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>mapperList</td>
<td>(list of file names) list of available working mappers</td>
</tr>
<tr class="row-even"><td>fileName</td>
<td>(file name) set file name given by the argument</td>
</tr>
<tr class="row-odd"><td>vrt</td>
<td>(VRT object) Wrapper around VRT file and GDAL dataset with satellite raster data</td>
</tr>
<tr class="row-even"><td>logger</td>
<td>(logging.Logger) logger for output debugging info</td>
</tr>
<tr class="row-odd"><td>name</td>
<td>(string) name of object (for writing KML)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.add_band" title="nansat.Mosaic.add_band"><tt class="xref py py-obj docutils literal"><span class="pre">add_band</span></tt></a>(array[,&nbsp;parameters,&nbsp;nomem])</td>
<td>Add band from the array to self.vrt  Create VRT object which contains VRT and RAW binary file and append it to self.vrt.subVRTs  :Parameters:      <strong>array</strong> : Numpy array with band data                <strong>parameters</strong> : dictionary, band metadata: wkv, name, etc.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Mosaic.average" title="nansat.Mosaic.average"><tt class="xref py py-obj docutils literal"><span class="pre">average</span></tt></a>([files,&nbsp;bands,&nbsp;doReproject,&nbsp;...])</td>
<td>Memory-friendly, multithreaded mosaicing(averaging) of input files  | Convert all input files into Nansat objects, reproject onto the | Domain of the current object, get bands, from each object,   calculate average and STD, add averaged bands (and STD) to   the current object.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.azimuth_up" title="nansat.Mosaic.azimuth_up"><tt class="xref py py-obj docutils literal"><span class="pre">azimuth_up</span></tt></a>([reductionFactor])</td>
<td>Calculate the azimuth of &#8216;upward&#8217; direction in each pixel  | Generaly speaking, azimuth is angle from the reference vector   (direction to North) to the chosen direction.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Mosaic.bands" title="nansat.Mosaic.bands"><tt class="xref py py-obj docutils literal"><span class="pre">bands</span></tt></a>()</td>
<td>Make a dictionary with all bands metadata</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.crop" title="nansat.Mosaic.crop"><tt class="xref py py-obj docutils literal"><span class="pre">crop</span></tt></a>([xOff,&nbsp;yOff,&nbsp;xSize,&nbsp;ySize,&nbsp;lonlim,&nbsp;latlim])</td>
<td>Crop Nansat object  | Create superVRT, modify the Source Rectangle (SrcRect) and   Destination.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Mosaic.export" title="nansat.Mosaic.export"><tt class="xref py py-obj docutils literal"><span class="pre">export</span></tt></a>(fileName[,&nbsp;rmMetadata,&nbsp;...])</td>
<td>Export Nansat object into netCDF or GTiff file   :Parameters:      <strong>fileName</strong> : str          output file name      <strong>rmMetadata</strong> : list          | metadata names for removal before export.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.export_band" title="nansat.Mosaic.export_band"><tt class="xref py py-obj docutils literal"><span class="pre">export_band</span></tt></a>(fileName[,&nbsp;bandID,&nbsp;driver])</td>
<td>Export only one band of the Nansat object</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Mosaic.get_GDALRasterBand" title="nansat.Mosaic.get_GDALRasterBand"><tt class="xref py py-obj docutils literal"><span class="pre">get_GDALRasterBand</span></tt></a>([bandID])</td>
<td>Get a GDALRasterBand of a given Nansat object  | If str is given find corresponding band number.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.get_border" title="nansat.Mosaic.get_border"><tt class="xref py py-obj docutils literal"><span class="pre">get_border</span></tt></a>([nPoints])</td>
<td>Generate two vectors with values of lat/lon for the border of domain</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Mosaic.get_border_geometry" title="nansat.Mosaic.get_border_geometry"><tt class="xref py py-obj docutils literal"><span class="pre">get_border_geometry</span></tt></a>()</td>
<td>Get OGR Geometry of the border Polygon</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.get_border_postgis" title="nansat.Mosaic.get_border_postgis"><tt class="xref py py-obj docutils literal"><span class="pre">get_border_postgis</span></tt></a>()</td>
<td>Get PostGIS formatted string of the border Polygon</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Mosaic.get_border_wkt" title="nansat.Mosaic.get_border_wkt"><tt class="xref py py-obj docutils literal"><span class="pre">get_border_wkt</span></tt></a>()</td>
<td>Creates string with WKT representation of the border polygon</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.get_corners" title="nansat.Mosaic.get_corners"><tt class="xref py py-obj docutils literal"><span class="pre">get_corners</span></tt></a>()</td>
<td>Get coordinates of corners of the Domain</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Mosaic.get_geolocation_grids" title="nansat.Mosaic.get_geolocation_grids"><tt class="xref py py-obj docutils literal"><span class="pre">get_geolocation_grids</span></tt></a>([stepSize])</td>
<td>Get longitude and latitude grids representing the full data grid  | If GEOLOCATION is not present in the self.vrt.dataset then grids   are generated by converting pixel/line of each pixel into lat/lon | If GEOLOCATION is present in the self.vrt.dataset then grids are   read from the geolocation bands.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.get_metadata" title="nansat.Mosaic.get_metadata"><tt class="xref py py-obj docutils literal"><span class="pre">get_metadata</span></tt></a>([key,&nbsp;bandID])</td>
<td>Get metadata from self.vrt.dataset   :Parameters:      <strong>key</strong> : string, optional          name of the metadata key.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Mosaic.get_pixelsize_meters" title="nansat.Mosaic.get_pixelsize_meters"><tt class="xref py py-obj docutils literal"><span class="pre">get_pixelsize_meters</span></tt></a>()</td>
<td>Returns the pixelsize (deltaX, deltaY) of the domain  | For projected domains, the exact result which is constant   over the domain is returned.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.get_time" title="nansat.Mosaic.get_time"><tt class="xref py py-obj docutils literal"><span class="pre">get_time</span></tt></a>([bandID])</td>
<td>Get time for dataset and/or its bands   :Parameters:      <strong>bandID</strong> : int or str (default = None)          band number or name  :Returns:      <strong>time</strong> : list with datetime objects for each band.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Mosaic.get_transect" title="nansat.Mosaic.get_transect"><tt class="xref py py-obj docutils literal"><span class="pre">get_transect</span></tt></a>([points,&nbsp;bandList,&nbsp;latlon,&nbsp;...])</td>
<td>Get transect from two poins and retun the values by numpy array   :Parameters:      <strong>points</strong> : tuple with one or more points or shape file name          | i.e.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.has_band" title="nansat.Mosaic.has_band"><tt class="xref py py-obj docutils literal"><span class="pre">has_band</span></tt></a>(band)</td>
<td>Check if self has band with name &lt;band&gt;</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Mosaic.latest" title="nansat.Mosaic.latest"><tt class="xref py py-obj docutils literal"><span class="pre">latest</span></tt></a>([files,&nbsp;bands,&nbsp;doReproject,&nbsp;maskName])</td>
<td>Mosaic by adding the latest image on top without averaging  | Uses Nansat.get_time() to estimate time of each input file; | Sorts images by aquisition time; | Creates date_index band - with mask of coverage of each frame; | Uses date_index to fill bands of self only with the latest data  :Parameters:      <strong>files</strong> : list          list of input files      <strong>bands</strong> : list          list of names/band_numbers to be processed      <strong>doReproject</strong> : boolean, [True]          reproject input files?      <strong>maskName</strong> : str, [&#8216;mask&#8217;]          name of the mask in input files      <strong>nClass</strong> : child of Nansat, [Nansat]          This class is used to read input files      <strong>eResampleAlg</strong> : int, [0]          agorithm for reprojection, see Nansat.reproject()      <strong>period</strong> : [datetime0, datetime1]          Start and stop datetime objects from pyhon datetime.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.list_bands" title="nansat.Mosaic.list_bands"><tt class="xref py py-obj docutils literal"><span class="pre">list_bands</span></tt></a>([doPrint])</td>
<td>Show band information of the given Nansat object  Show serial number, longName, name and all parameters for each band in the metadata of the given Nansat object.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Mosaic.median" title="nansat.Mosaic.median"><tt class="xref py py-obj docutils literal"><span class="pre">median</span></tt></a>([files,&nbsp;bands,&nbsp;doReproject,&nbsp;maskName])</td>
<td>Calculate median of input bands  Memory and CPU greedy method.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.nClass" title="nansat.Mosaic.nClass"><tt class="xref py py-obj docutils literal"><span class="pre">nClass</span></tt></a></td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Mosaic.process" title="nansat.Mosaic.process"><tt class="xref py py-obj docutils literal"><span class="pre">process</span></tt></a>([opts])</td>
<td>Default L2 processing of Nansat object.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.reproject" title="nansat.Mosaic.reproject"><tt class="xref py py-obj docutils literal"><span class="pre">reproject</span></tt></a>([dstDomain,&nbsp;eResampleAlg,&nbsp;...])</td>
<td>Change projection of the object based on the given Domain  | Create superVRT from self.vrt with AutoCreateWarpedVRT() using   projection from the dstDomain.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Mosaic.reproject_GCPs" title="nansat.Mosaic.reproject_GCPs"><tt class="xref py py-obj docutils literal"><span class="pre">reproject_GCPs</span></tt></a>(srsString)</td>
<td>Reproject all GCPs to a new spatial reference system  | Necessary before warping an image if the given GCPs   are in a coordinate system which has a singularity   in (or near) the destination area (e.g.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.resize" title="nansat.Mosaic.resize"><tt class="xref py py-obj docutils literal"><span class="pre">resize</span></tt></a>([factor,&nbsp;width,&nbsp;height,&nbsp;pixelsize,&nbsp;...])</td>
<td>Proportional resize of the dataset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Mosaic.set_metadata" title="nansat.Mosaic.set_metadata"><tt class="xref py py-obj docutils literal"><span class="pre">set_metadata</span></tt></a>([key,&nbsp;value,&nbsp;bandID])</td>
<td>Set metadata to self.vrt.dataset</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.shape" title="nansat.Mosaic.shape"><tt class="xref py py-obj docutils literal"><span class="pre">shape</span></tt></a>()</td>
<td>Return Numpy-like shape of Domain object (ySize, xSize)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Mosaic.transform_points" title="nansat.Mosaic.transform_points"><tt class="xref py py-obj docutils literal"><span class="pre">transform_points</span></tt></a>(colVector,&nbsp;rowVector[,&nbsp;...])</td>
<td>Transform given lists of X,Y coordinates into lon/lat or inverse</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.undo" title="nansat.Mosaic.undo"><tt class="xref py py-obj docutils literal"><span class="pre">undo</span></tt></a>([steps])</td>
<td>Undo reproject, resize, add_band or crop of Nansat object</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Mosaic.upwards_azimuth_direction" title="nansat.Mosaic.upwards_azimuth_direction"><tt class="xref py py-obj docutils literal"><span class="pre">upwards_azimuth_direction</span></tt></a>([orbit_direction])</td>
<td>Caluculate and return upwards azimuth direction of domain.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.watermask" title="nansat.Mosaic.watermask"><tt class="xref py py-obj docutils literal"><span class="pre">watermask</span></tt></a>([mod44path,&nbsp;dstDomain])</td>
<td>Create numpy array with watermask (water=1, land=0)  | 250 meters resolution watermask from MODIS 44W Product: | <a class="reference external" href="http://www.glcf.umd.edu/data/watermask/">http://www.glcf.umd.edu/data/watermask/</a> | Watermask is stored as tiles in TIF(LZW) format and a VRT file.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Mosaic.write_figure" title="nansat.Mosaic.write_figure"><tt class="xref py py-obj docutils literal"><span class="pre">write_figure</span></tt></a>([fileName,&nbsp;bands,&nbsp;clim,&nbsp;addDate])</td>
<td>Save a raster band to a figure in graphical format.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.write_geotiffimage" title="nansat.Mosaic.write_geotiffimage"><tt class="xref py py-obj docutils literal"><span class="pre">write_geotiffimage</span></tt></a>(fileName[,&nbsp;bandID])</td>
<td>Writes an 8-bit GeoTiff image for a given band.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Mosaic.write_kml" title="nansat.Mosaic.write_kml"><tt class="xref py py-obj docutils literal"><span class="pre">write_kml</span></tt></a>([xmlFileName,&nbsp;kmlFileName])</td>
<td>Write KML file with domains  Convert XML-file with domains into KML-file for GoogleEarth or write KML-file with the current Domain  :Parameters:      <strong>xmlFileName</strong> : string, optional          Name of the XML-file to convert.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.write_kml_image" title="nansat.Mosaic.write_kml_image"><tt class="xref py py-obj docutils literal"><span class="pre">write_kml_image</span></tt></a>([kmlFileName,&nbsp;kmlFigureName])</td>
<td>Create KML file for already projected image  Write Domain Image into KML-file for GoogleEarth  :Parameters:      <strong>kmlFileName</strong> : string, optional          Name of the KML-file to generate from the current Domain      <strong>kmlFigureName</strong> : string, optional          Name of the projected image stored in .png format  ..</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Mosaic.write_map" title="nansat.Mosaic.write_map"><tt class="xref py py-obj docutils literal"><span class="pre">write_map</span></tt></a>(outputFileName[,&nbsp;lonVec,&nbsp;latVec,&nbsp;...])</td>
<td>Create an image with a map of the domain  | Uses Basemap to create a World Map.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nansat.Mosaic.add_band">
<tt class="descname">add_band</tt><big>(</big><em>array</em>, <em>parameters=None</em>, <em>nomem=False</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.add_band" title="Permalink to this definition">¶</a></dt>
<dd><p>Add band from the array to self.vrt</p>
<p>Create VRT object which contains VRT and RAW binary file and append
it to self.vrt.subVRTs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>array</strong> : Numpy array with band data</p>
<p><strong>parameters</strong> : dictionary, band metadata: wkv, name, etc.</p>
<p><strong>nomem</strong> : boolean, saves the vrt to a tempfile if nomem is True</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Creates:</th><td class="field-body"><p class="first"><strong>VRT object</strong> : VRT object with VRT-file and RAW-file</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.vrt</strong> : Add a band</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.average">
<tt class="descname">average</tt><big>(</big><em>files=[], bands=[1], doReproject=True, maskName='mask', threads=1, **kwargs</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.average" title="Permalink to this definition">¶</a></dt>
<dd><p>Memory-friendly, multithreaded mosaicing(averaging) of input files</p>
<div class="line-block">
<div class="line">Convert all input files into Nansat objects, reproject onto the</div>
<div class="line">Domain of the current object, get bands, from each object,
calculate average and STD, add averaged bands (and STD) to
the current object.</div>
<div class="line">average() tries to get band &#8216;mask&#8217; from the input files. The mask
should have the following coding</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Code:</th><td class="field-body"><div class="first last line-block">
<div class="line">0 : nodata</div>
<div class="line">1 : clouds</div>
<div class="line">2 : land</div>
<div class="line">64 : valid pixel</div>
</div>
</td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line">If it gets that band (which can be provided by some mappers or Nansat
childs, e.g.  ModisL2Image) it uses it to select averagable pixels
(i.e. where mask == 64).</div>
<div class="line">If it cannot locate the band &#8216;mask&#8217; is assumes that all pixels are
averagebale except for thouse out of swath after reprojection.</div>
<div class="line">average() adds bands to the object, so it works only with empty, or
non-projected objects</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>files</strong> : list</p>
<blockquote>
<div><p>list of input files</p>
</div></blockquote>
<p><strong>bands</strong> : list</p>
<blockquote>
<div><p>list of names/band_numbers to be processed</p>
</div></blockquote>
<p><strong>doReproject</strong> : boolean, [True]</p>
<blockquote>
<div><p>reproject input files?</p>
</div></blockquote>
<p><strong>maskName</strong> : str, [&#8216;mask&#8217;]</p>
<blockquote>
<div><p>name of the mask in input files</p>
</div></blockquote>
<p><strong>nClass</strong> : child of Nansat, [Nansat]</p>
<blockquote>
<div><p>This class is used to read input files</p>
</div></blockquote>
<p><strong>threads</strong> : int</p>
<blockquote>
<div><p>number of parallel processes to use</p>
</div></blockquote>
<p><strong>eResampleAlg</strong> : int, [0]</p>
<blockquote>
<div><p>agorithm for reprojection, see Nansat.reproject()</p>
</div></blockquote>
<p><strong>period</strong> : [datetime0, datetime1]</p>
<blockquote class="last">
<div><p>Start and stop datetime objects from pyhon datetime.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.azimuth_up">
<tt class="descname">azimuth_up</tt><big>(</big><em>reductionFactor=1</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.azimuth_up" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the azimuth of &#8216;upward&#8217; direction in each pixel</p>
<div class="line-block">
<div class="line">Generaly speaking, azimuth is angle from the reference vector
(direction to North) to the chosen direction. Azimuth increases
clockwise from direction to North.
<a class="reference external" href="http://en.wikipedia.org/wiki/Azimuth">http://en.wikipedia.org/wiki/Azimuth</a></div>
<div class="line">Here we calcluate azimuth of &#8216;upward&#8217; direction.
&#8216;Upward&#8217; direction coincides with Y-axis direction (and hence is
opposite to the ROW-axis direction). For lon-lat (cylindrical,
Plate Caree) and Mercator projections &#8216;upward&#8217; direction coincides
with direction to North, hence azimuth is 0.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reductionFactor</strong> : integer</p>
<blockquote>
<div><p>factor by which the size of the output array is reduced</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>azimuth</strong> : numpy array</p>
<blockquote class="last">
<div><p>Values of azimuth in degrees in range 0 - 360</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.bands">
<tt class="descname">bands</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Mosaic.bands" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a dictionary with all bands metadata</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>b</strong> : dictionary</p>
<blockquote class="last">
<div><p>key = N, value = dict with all band metadata</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.crop">
<tt class="descname">crop</tt><big>(</big><em>xOff=0</em>, <em>yOff=0</em>, <em>xSize=None</em>, <em>ySize=None</em>, <em>lonlim=None</em>, <em>latlim=None</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.crop" title="Permalink to this definition">¶</a></dt>
<dd><p>Crop Nansat object</p>
<div class="line-block">
<div class="line">Create superVRT, modify the Source Rectangle (SrcRect) and
Destination.</div>
<div class="line">Rectangle (DstRect) tags in the VRT file for each band in order
to take only part of the original image, create new GCPs or
new GeoTransform for the cropped object.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xOff</strong> : int</p>
<blockquote>
<div><p>pixel offset of subimage</p>
</div></blockquote>
<p><strong>yOff</strong> : int</p>
<blockquote>
<div><p>line offset of subimage</p>
</div></blockquote>
<p><strong>xSize</strong> : int</p>
<blockquote>
<div><p>width in pixels of subimage</p>
</div></blockquote>
<p><strong>ySize</strong> : int</p>
<blockquote>
<div><p>height in pizels of subimage</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Creates:</th><td class="field-body"><p class="first"><strong>superVRT</strong> : VRT with modified SrcRect and DstRect</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.vrt</strong> : VRT</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>status</strong> : int</p>
<blockquote class="last">
<div><div class="line-block">
<div class="line">0 - everyhting is OK, image is cropped</div>
<div class="line">1 - if crop is totally outside, image is NOT cropped</div>
<div class="line">2 - crop area is too large and crop is not needed</div>
</div>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.export">
<tt class="descname">export</tt><big>(</big><em>fileName</em>, <em>rmMetadata=</em>, <span class="optional">[</span><span class="optional">]</span><em>addGeolocArray=True</em>, <em>addGCPs=True</em>, <em>driver='netCDF'</em>, <em>bottomup=False</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.export" title="Permalink to this definition">¶</a></dt>
<dd><p>Export Nansat object into netCDF or GTiff file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : str</p>
<blockquote>
<div><p>output file name</p>
</div></blockquote>
<p><strong>rmMetadata</strong> : list</p>
<blockquote>
<div><div class="line-block">
<div class="line">metadata names for removal before export.</div>
<div class="line">e.g. [&#8216;name&#8217;, &#8216;colormap&#8217;, &#8216;source&#8217;, &#8216;sourceBands&#8217;]</div>
</div>
</div></blockquote>
<p><strong>addGeolocArray</strong> : bool</p>
<blockquote>
<div><p>add geolocation array datasets to exported file?</p>
</div></blockquote>
<p><strong>addGCPs</strong> : bool</p>
<blockquote>
<div><p>add GCPs?  to exported file?</p>
</div></blockquote>
<p><strong>driver</strong> : str</p>
<blockquote>
<div><p>Name of GDAL driver (format)</p>
</div></blockquote>
<p><strong>bottomup</strong> : bool</p>
<blockquote>
<div><div class="line-block">
<div class="line">False : Write swath-projected data with rows and columns
organized as in the original product.</div>
<div class="line">True : Use the default behaviour of GDAL, which is to flip
the rows</div>
</div>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Creates:</th><td class="field-body"><p class="first last"><strong>a netCDF file</strong></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="line-block">
<div class="line">If number of bands is more than one, serial numbers are
added at the end of each band name.</div>
<div class="line">It is possible to fix it by changing
line.4605 in GDAL/frmts/netcdf/netcdfdataset.cpp :</div>
<div class="line">&#8216;if( nBands &gt; 1 ) sprintf(szBandName,&#8221;%s%d&#8221;,tmpMetadata,iBand);&#8217;</div>
<div class="line">&#8211;&gt; &#8216;if( nBands &gt; 1 ) sprintf(szBandName,&#8221;%s&#8221;,tmpMetadata);&#8217;</div>
<div class="line">CreateCopy fails in case the band name has special characters,</div>
<div class="line">e.g. the slash in &#8216;HH/VV&#8217;.</div>
</div>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.export_band">
<tt class="descname">export_band</tt><big>(</big><em>fileName</em>, <em>bandID=1</em>, <em>driver='netCDF'</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.export_band" title="Permalink to this definition">¶</a></dt>
<dd><p>Export only one band of the Nansat object</p>
<div class="line-block">
<div class="line">Get array from the required band</div>
<div class="line">Create temporary Nansat from the array</div>
<div class="line">Export temporary Nansat to file</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : str</p>
<blockquote>
<div><p>name of the output file</p>
</div></blockquote>
<p><strong>bandID</strong> : int or str, [1]</p>
<blockquote>
<div><p>number of name of the band</p>
</div></blockquote>
<p><strong>driver</strong> : str, [&#8216;netCDF&#8217;]</p>
<blockquote class="last">
<div><p>name of the GDAL Driver (format) to use</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.get_GDALRasterBand">
<tt class="descname">get_GDALRasterBand</tt><big>(</big><em>bandID=1</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.get_GDALRasterBand" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a GDALRasterBand of a given Nansat object</p>
<div class="line-block">
<div class="line">If str is given find corresponding band number.</div>
<div class="line">If int is given check if band with this number exists.</div>
<div class="line">Get a GDALRasterBand from vrt.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>bandID</strong> : serial number or string, optional (default is 1)</p>
<blockquote>
<div><div class="line-block">
<div class="line">if number - a band number of the band to fetch</div>
<div class="line">if string - bandID = {&#8216;name&#8217;: bandID}</div>
</div>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">GDAL RasterBand</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Get a raster band</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># get a band from the band number</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">get_GDALRasterBand</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="c"># get a band from the name</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">get_GDALRasterBand</span><span class="p">(</span><span class="s">&#39;sigma0&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.get_border">
<tt class="descname">get_border</tt><big>(</big><em>nPoints=10</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.get_border" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate two vectors with values of lat/lon for the border of domain</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>nPoints</strong> : int, optional</p>
<blockquote>
<div><p>Number of points on each border</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>lonVec, latVec</strong> : lists</p>
<blockquote class="last">
<div><p>vectors with lon/lat values for each point at the border</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.get_border_geometry">
<tt class="descname">get_border_geometry</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Mosaic.get_border_geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Get OGR Geometry of the border Polygon</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>OGR Geometry</strong> : type Polygon</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.get_border_postgis">
<tt class="descname">get_border_postgis</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Mosaic.get_border_postgis" title="Permalink to this definition">¶</a></dt>
<dd><p>Get PostGIS formatted string of the border Polygon</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>str</strong> : &#8216;PolygonFromText(PolygonWKT)&#8217;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.get_border_wkt">
<tt class="descname">get_border_wkt</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Mosaic.get_border_wkt" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates string with WKT representation of the border polygon</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>WKTPolygon</strong> : string</p>
<blockquote class="last">
<div><p>string with WKT representation of the border polygon</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.get_corners">
<tt class="descname">get_corners</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Mosaic.get_corners" title="Permalink to this definition">¶</a></dt>
<dd><p>Get coordinates of corners of the Domain</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>lonVec, latVec</strong> : lists</p>
<blockquote class="last">
<div><p>vectors with lon/lat values for each corner</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.get_geolocation_grids">
<tt class="descname">get_geolocation_grids</tt><big>(</big><em>stepSize=1</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.get_geolocation_grids" title="Permalink to this definition">¶</a></dt>
<dd><p>Get longitude and latitude grids representing the full data grid</p>
<div class="line-block">
<div class="line">If GEOLOCATION is not present in the self.vrt.dataset then grids
are generated by converting pixel/line of each pixel into lat/lon</div>
<div class="line">If GEOLOCATION is present in the self.vrt.dataset then grids are
read from the geolocation bands.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>stepSize</strong> : int</p>
<blockquote>
<div><p>Reduction factor if output is desired on a reduced grid size</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>longitude</strong> : numpy array</p>
<blockquote>
<div><p>grid with longitudes</p>
</div></blockquote>
<p><strong>latitude</strong> : numpy array</p>
<blockquote class="last">
<div><p>grid with latitudes</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.get_metadata">
<tt class="descname">get_metadata</tt><big>(</big><em>key=None</em>, <em>bandID=None</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.get_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Get metadata from self.vrt.dataset</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>key</strong> : string, optional</p>
<blockquote>
<div><p>name of the metadata key. If not givem all metadata is returned</p>
</div></blockquote>
<p><strong>bandID</strong> : int or str, optional</p>
<blockquote>
<div><p>number or name of band to get metadata from.
If not given, global metadata is returned</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>string</strong> : a string with metadata</p>
<blockquote>
<div><div class="line-block">
<div class="line">if key is given and found an empty string</div>
<div class="line">if key is given and not found</div>
</div>
</div></blockquote>
<p><strong>dictionary</strong> : a dictionary with all metadata</p>
<blockquote class="last">
<div><p>if key is not given</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.get_pixelsize_meters">
<tt class="descname">get_pixelsize_meters</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Mosaic.get_pixelsize_meters" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pixelsize (deltaX, deltaY) of the domain</p>
<div class="line-block">
<div class="line">For projected domains, the exact result which is constant
over the domain is returned.</div>
<div class="line">For geographic (lon-lat) projections,
or domains with no geotransform,
the haversine formula is used to calculate the pixel size
in the center of the domain.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>deltaX, deltaY</strong> : float</p>
<blockquote class="last">
<div><p>pixel size in X and Y directions given in meters</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.get_time">
<tt class="descname">get_time</tt><big>(</big><em>bandID=None</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.get_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Get time for dataset and/or its bands</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>bandID</strong> : int or str (default = None)</p>
<blockquote>
<div><p>band number or name</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>time</strong> : list with datetime objects for each band.</p>
<blockquote class="last">
<div><p>If time is the same for all bands, the list contains 1 item</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.get_transect">
<tt class="descname">get_transect</tt><big>(</big><em>points=None, bandList=[1], latlon=True, transect=True, returnOGR=False, layerNum=0, smoothRadius=0, smoothAlg=0, **kwargs</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.get_transect" title="Permalink to this definition">¶</a></dt>
<dd><p>Get transect from two poins and retun the values by numpy array</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>points</strong> : tuple with one or more points or shape file name</p>
<blockquote>
<div><div class="line-block">
<div class="line">i.e. ((lon1, lat1),(lon2, lat2),(lon3, lat3), ...) or</div>
<div class="line-block">
<div class="line">((col1, row1),(col2, row2),(col3, row3), ...)</div>
</div>
</div>
</div></blockquote>
<p><strong>bandList</strong> : list of int or string</p>
<blockquote>
<div><p>elements of the list are band number or band Name</p>
</div></blockquote>
<p><strong>latlon</strong> : bool</p>
<blockquote>
<div><p>If the points in lat/lon, then True.
If the points in pixel/line, then False.</p>
</div></blockquote>
<p><strong>transect</strong> : bool</p>
<blockquote>
<div><p>If True, get all transact values
If False, get values of points</p>
</div></blockquote>
<p><strong>returnOGR: bool</strong></p>
<blockquote>
<div><p>If True, then return numpy array
If False, return OGR object</p>
</div></blockquote>
<p><strong>layerNum: int</strong></p>
<blockquote>
<div><p>If shapefile is given as points, it is the number of the layer</p>
</div></blockquote>
<p><strong>smoothRadius: int</strong></p>
<blockquote>
<div><p>If smootRadius is greater than 0, smooth every transect
pixel as the median or mean value in a circule with radius
equal to the given number.</p>
</div></blockquote>
<p><strong>smoothAlg: 0 or 1 for median or mean</strong></p>
<p><strong>vmin, vmax</strong> : int (optional)</p>
<blockquote>
<div><p>minimum and maximum pixel values of an image shown
in case points is None.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>if returnOGR = True</strong></p>
<blockquote>
<div><p><strong>transect</strong> : OGR object with points coordinates and values</p>
</div></blockquote>
<p><strong>if returnOGR = False</strong></p>
<blockquote>
<div><p><strong>transect</strong> : list or values of the transect or
OGR object with the transect values</p>
</div></blockquote>
<p><strong>[lonVector, latVector]</strong> : list with longitudes, latitudes</p>
<p class="last"><strong>pixlinCoord</strong> : numpy array with pixels and lines coordinates</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.has_band">
<tt class="descname">has_band</tt><big>(</big><em>band</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.has_band" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if self has band with name &lt;band&gt;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>band</strong> : str</p>
<blockquote>
<div><p>name of the band to check</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>bool</strong> : True/False if band exists or not</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.latest">
<tt class="descname">latest</tt><big>(</big><em>files=[], bands=[1], doReproject=True, maskName='mask', **kwargs</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.latest" title="Permalink to this definition">¶</a></dt>
<dd><p>Mosaic by adding the latest image on top without averaging</p>
<div class="line-block">
<div class="line">Uses Nansat.get_time() to estimate time of each input file;</div>
<div class="line">Sorts images by aquisition time;</div>
<div class="line">Creates date_index band - with mask of coverage of each frame;</div>
<div class="line">Uses date_index to fill bands of self only with the latest data</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>files</strong> : list</p>
<blockquote>
<div><p>list of input files</p>
</div></blockquote>
<p><strong>bands</strong> : list</p>
<blockquote>
<div><p>list of names/band_numbers to be processed</p>
</div></blockquote>
<p><strong>doReproject</strong> : boolean, [True]</p>
<blockquote>
<div><p>reproject input files?</p>
</div></blockquote>
<p><strong>maskName</strong> : str, [&#8216;mask&#8217;]</p>
<blockquote>
<div><p>name of the mask in input files</p>
</div></blockquote>
<p><strong>nClass</strong> : child of Nansat, [Nansat]</p>
<blockquote>
<div><p>This class is used to read input files</p>
</div></blockquote>
<p><strong>eResampleAlg</strong> : int, [0]</p>
<blockquote>
<div><p>agorithm for reprojection, see Nansat.reproject()</p>
</div></blockquote>
<p><strong>period</strong> : [datetime0, datetime1]</p>
<blockquote class="last">
<div><p>Start and stop datetime objects from pyhon datetime.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.list_bands">
<tt class="descname">list_bands</tt><big>(</big><em>doPrint=True</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.list_bands" title="Permalink to this definition">¶</a></dt>
<dd><p>Show band information of the given Nansat object</p>
<p>Show serial number, longName, name and all parameters
for each band in the metadata of the given Nansat object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>doPrint</strong> : boolean, optional, default=True</p>
<blockquote>
<div><p>do print, otherwise it is returned as string</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>outString</strong> : String</p>
<blockquote class="last">
<div><p>formatted string with bands info</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.median">
<tt class="descname">median</tt><big>(</big><em>files=[], bands=[1], doReproject=True, maskName='mask', **kwargs</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.median" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate median of input bands</p>
<p>Memory and CPU greedy method. Generates 3D cube from bands of
all input images and calculates median. Adds median bands to self</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>files</strong> : list</p>
<blockquote>
<div><p>list of input files</p>
</div></blockquote>
<p><strong>bands</strong> : list</p>
<blockquote>
<div><p>list of names/band_numbers to be processed</p>
</div></blockquote>
<p><strong>doReproject</strong> : boolean, [True]</p>
<blockquote>
<div><p>reproject input files?</p>
</div></blockquote>
<p><strong>maskName</strong> : str, [&#8216;mask&#8217;]</p>
<blockquote>
<div><p>name of the mask in input files</p>
</div></blockquote>
<p><strong>nClass</strong> : child of Nansat, [Nansat]</p>
<blockquote>
<div><p>This class is used to read input files</p>
</div></blockquote>
<p><strong>eResampleAlg</strong> : int, [0]</p>
<blockquote>
<div><p>agorithm for reprojection, see Nansat.reproject()</p>
</div></blockquote>
<p><strong>period</strong> : [datetime0, datetime1]</p>
<blockquote class="last">
<div><p>Start and stop datetime objects from pyhon datetime.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="nansat.Mosaic.nClass">
<tt class="descname">nClass</tt><a class="headerlink" href="#nansat.Mosaic.nClass" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#nansat.Nansat" title="nansat.Nansat"><tt class="xref py py-class docutils literal"><span class="pre">Nansat</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.process">
<tt class="descname">process</tt><big>(</big><em>opts=None</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.process" title="Permalink to this definition">¶</a></dt>
<dd><p>Default L2 processing of Nansat object. Overloaded in childs.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.reproject">
<tt class="descname">reproject</tt><big>(</big><em>dstDomain=None</em>, <em>eResampleAlg=0</em>, <em>blockSize=None</em>, <em>WorkingDataType=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.reproject" title="Permalink to this definition">¶</a></dt>
<dd><p>Change projection of the object based on the given Domain</p>
<div class="line-block">
<div class="line">Create superVRT from self.vrt with AutoCreateWarpedVRT() using
projection from the dstDomain.</div>
<div class="line">Modify XML content of the warped vrt using the Domain parameters.</div>
<div class="line">Generate warpedVRT and replace self.vrt with warpedVRT.</div>
<div class="line">If current object spans from 0 to 360 and dstDomain is west of 0,
the object is shifted by 180 westwards.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dstDomain</strong> : domain</p>
<blockquote>
<div><p>destination Domain where projection and resolution are set</p>
</div></blockquote>
<p><strong>eResampleAlg</strong> : int (GDALResampleAlg)</p>
<blockquote>
<div><div class="line-block">
<div class="line">0 : NearestNeighbour</div>
<div class="line">1 : Bilinear</div>
<div class="line">2 : Cubic,</div>
<div class="line">3 : CubicSpline</div>
<div class="line">4 : Lancoz</div>
</div>
</div></blockquote>
<p><strong>blockSize</strong> : int</p>
<blockquote>
<div><p>size of blocks for resampling. Large value decrease speed
but increase accuracy at the edge</p>
</div></blockquote>
<p><strong>WorkingDataType</strong> : int (GDT_int, ...)</p>
<blockquote>
<div><p>type of data in bands. Shuold be integer for int32 bands</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.vrt</strong> : VRT object with dataset replaced to warpedVRT dataset</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>gdalwarp : <a class="reference external" href="http://www.gdal.org/gdalwarp.html">http://www.gdal.org/gdalwarp.html</a></p>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.reproject_GCPs">
<tt class="descname">reproject_GCPs</tt><big>(</big><em>srsString</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.reproject_GCPs" title="Permalink to this definition">¶</a></dt>
<dd><p>Reproject all GCPs to a new spatial reference system</p>
<div class="line-block">
<div class="line">Necessary before warping an image if the given GCPs
are in a coordinate system which has a singularity
in (or near) the destination area (e.g. poles for lonlat GCPs)</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>srsString</strong> : string</p>
<blockquote>
<div><p>SRS given as Proj4 string</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>Reprojects all GCPs to new SRS and updates GCPProjection</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.resize">
<tt class="descname">resize</tt><big>(</big><em>factor=1</em>, <em>width=None</em>, <em>height=None</em>, <em>pixelsize=None</em>, <em>eResampleAlg=-1</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.resize" title="Permalink to this definition">¶</a></dt>
<dd><p>Proportional resize of the dataset.</p>
<div class="line-block">
<div class="line">The dataset is resized as (xSize*factor, ySize*factor)</div>
<div class="line">If desired width, height or pixelsize is specified,
the scaling factor is calculated accordingly.</div>
<div class="line">If GCPs are given in a dataset, they are also rewritten.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>factor</strong> : float, optional, default=1</p>
<blockquote>
<div><div class="line-block">
<div class="line">scaling factor for width and height</div>
<div class="line">&gt;1 : increasing domain size</div>
<div class="line">&lt;1 : decreasing domain size</div>
</div>
</div></blockquote>
<p><strong>width</strong> : int, optional</p>
<blockquote>
<div><p>Desired new width in pixels</p>
</div></blockquote>
<p><strong>height</strong> : int, optional</p>
<blockquote>
<div><p>Desired new height in pixels</p>
</div></blockquote>
<p><strong>pixelsize</strong> : float, optional</p>
<blockquote>
<div><p>Desired new pixelsize in meters (approximate).
A factor is calculated from ratio of the
current pixelsize to the desired pixelsize.</p>
</div></blockquote>
<p><strong>eResampleAlg</strong> : int (GDALResampleAlg), optional</p>
<blockquote>
<div><div class="line-block">
<div class="line">-1 : Average</div>
<div class="line">0 : NearestNeighbour</div>
<div class="line">1 : Bilinear</div>
<div class="line">2 : Cubic</div>
<div class="line">3 : CubicSpline</div>
<div class="line">4 : Lancoz</div>
</div>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.vrt.dataset</strong> : raster size are modified to downscaled size.</p>
<blockquote class="last">
<div><p>If GCPs are given in the dataset, they are also overwritten.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.set_metadata">
<tt class="descname">set_metadata</tt><big>(</big><em>key=''</em>, <em>value=''</em>, <em>bandID=None</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.set_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Set metadata to self.vrt.dataset</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>key</strong> : string or dictionary with strings</p>
<blockquote>
<div><p>name of the metadata, or dictionary with metadata names, values</p>
</div></blockquote>
<p><strong>value</strong> : string</p>
<blockquote>
<div><p>value of metadata</p>
</div></blockquote>
<p><strong>bandID</strong> : int or str</p>
<blockquote>
<div><div class="line-block">
<div class="line">number or name of band</div>
<div class="line">Without bandID (None), global metadata is set</div>
</div>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.vrt.dataset</strong> : sets metadata in GDAL current dataset</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.shape">
<tt class="descname">shape</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Mosaic.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Numpy-like shape of Domain object (ySize, xSize)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>shape</strong> : tuple of two INT</p>
<blockquote class="last">
<div><p>Numpy-like shape of Domain object (ySize, xSize)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.transform_points">
<tt class="descname">transform_points</tt><big>(</big><em>colVector</em>, <em>rowVector</em>, <em>DstToSrc=0</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.transform_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform given lists of X,Y coordinates into lon/lat or inverse</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>colVector</strong> : lists</p>
<blockquote>
<div><p>X and Y coordinates in pixel/line or lon/lat  coordinate system</p>
</div></blockquote>
<p><strong>DstToSrc</strong> : 0 or 1</p>
<blockquote>
<div><ul class="simple">
<li>0 - forward transform (pix/line =&gt; lon/lat)</li>
<li>1 - inverse transformation</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>X, Y</strong> : lists</p>
<blockquote class="last">
<div><p>X and Y coordinates in lon/lat or pixel/line coordinate system</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.undo">
<tt class="descname">undo</tt><big>(</big><em>steps=1</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.undo" title="Permalink to this definition">¶</a></dt>
<dd><p>Undo reproject, resize, add_band or crop of Nansat object</p>
<p>Restore the self.vrt from self.vrt.vrt</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>steps</strong> : int</p>
<blockquote>
<div><p>How many steps back to undo</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.vrt</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.upwards_azimuth_direction">
<tt class="descname">upwards_azimuth_direction</tt><big>(</big><em>orbit_direction=None</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.upwards_azimuth_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Caluculate and return upwards azimuth direction of domain.</p>
<p>The upward azimuth direction will be the satellite flight
direction (bearing) for unprojected satellite images.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>bearing_center</strong> : float</p>
<blockquote class="last">
<div><p>The upwards azimuth direction (bearing) in the center of
the domain.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="line-block">
<div class="line">For longer domains especially at high latitudes
the azimuth direction may vary a lot over the domain,
and using the center angle will be a coarse approximation.</div>
<div class="line">This function should be updated to return a matrix
of bearings interpolated to each pixel of the domain.
This method should probably also get a better name.</div>
</div>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.watermask">
<tt class="descname">watermask</tt><big>(</big><em>mod44path=None</em>, <em>dstDomain=None</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.watermask" title="Permalink to this definition">¶</a></dt>
<dd><p>Create numpy array with watermask (water=1, land=0)</p>
<div class="line-block">
<div class="line">250 meters resolution watermask from MODIS 44W Product:</div>
<div class="line"><a class="reference external" href="http://www.glcf.umd.edu/data/watermask/">http://www.glcf.umd.edu/data/watermask/</a></div>
<div class="line">Watermask is stored as tiles in TIF(LZW) format and a VRT file.</div>
<div class="line">All files are stored in one directory.</div>
<div class="line">A tarball with compressed TIF and VRT files should be additionally
downloaded from the Nansat wiki:</div>
<div class="line"><a class="reference external" href="https://github.com/nansencenter/nansat/wiki/Install-Nansat">https://github.com/nansencenter/nansat/wiki/Install-Nansat</a></div>
<div class="line"><br /></div>
<div class="line">1. Gets the directory either from input parameter or from
environment variable MOD44WPATH</div>
<div class="line">2. Open Nansat object from the VRT file</div>
<div class="line">3. Reprojects the watermask onto the current object using
reproject() or reproject_on_jcps()</div>
<div class="line">4. Returns the reprojected Nansat object</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mod44path</strong> : string, optional, default=None</p>
<blockquote>
<div><p>path with MOD44W Products and a VRT file</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>watermask</strong> : Nansat object with water mask in current projection</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>250 meters resolution watermask from MODIS 44W Product :
<a class="reference external" href="http://www.glcf.umd.edu/data/watermask/">http://www.glcf.umd.edu/data/watermask/</a></p>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.write_figure">
<tt class="descname">write_figure</tt><big>(</big><em>fileName=None</em>, <em>bands=1</em>, <em>clim=None</em>, <em>addDate=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.write_figure" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a raster band to a figure in graphical format.</p>
<div class="line-block">
<div class="line">Get numpy array from the band(s) and band information specified
either by given band number or band id.</div>
<div class="line-block">
<div class="line">If three bands are given, merge them and create PIL image.</div>
<div class="line">If one band is given, create indexed image</div>
</div>
<div class="line">Create Figure object.</div>
<div class="line">Adjust the array brightness and contrast using the given min/max or
histogram.</div>
<div class="line">Apply logarithmic scaling of color tone.</div>
<div class="line">Generate and append legend.</div>
<div class="line">Save the PIL output image in PNG or any other graphical format.</div>
<div class="line">If the filename extension is &#8216;tif&#8217;, the figure file is converted
to GeoTiff</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : string, optional</p>
<blockquote>
<div><p>Output file name. if one of extensions &#8216;png&#8217;, &#8216;PNG&#8217;, &#8216;tif&#8217;,
&#8216;TIF&#8217;, &#8216;bmp&#8217;, &#8216;BMP&#8217;, &#8216;jpg&#8217;, &#8216;JPG&#8217;, &#8216;jpeg&#8217;, &#8216;JPEG&#8217; is included,
specified file is crated. otherwise, &#8216;png&#8217; file is created.
if None, the figure object is returned.
if True, the figure is shown</p>
</div></blockquote>
<p><strong>bands</strong> : integer or string or list (elements are integer or string),</p>
<blockquote>
<div><p>default = 1
the size of the list has to be 1 or 3.
if the size is 3, RGB image is created based on the three bands.
Then the first element is Red, the second is Green,
and the third is Blue.</p>
</div></blockquote>
<p><strong>clim</strong> : list with two elements or &#8216;hist&#8217; to specify range of colormap</p>
<blockquote>
<div><p>None (default) : min/max values are fetched from WKV,
fallback-&#8216;hist&#8217;
[min, max] : min and max are numbers, or
[[min, min, min], [max, max, max]]: three bands used
&#8216;hist&#8217; : a histogram is used to calculate min and max values</p>
</div></blockquote>
<p><strong>addDate</strong> : boolean</p>
<blockquote>
<div><p>False (default) : no date will be aded to the caption
True : the first time of the object will be added to the caption</p>
</div></blockquote>
<p><strong>**kwargs</strong> : parameters for Figure().</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Creates:</th><td class="field-body"><p class="first"><strong>image file</strong> : if fileName is specified</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Figure object</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<div class="line-block">
<div class="line">Figure() class</div>
<div class="line">colormaps : <a class="reference external" href="http://www.scipy.org/Cookbook/Matplotlib/Show_colormaps">http://www.scipy.org/Cookbook/Matplotlib/Show_colormaps</a></div>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># 1. write only indexed image, color limits from WKV or</span>
<span class="c"># rom histogram</span>
<span class="n">n</span><span class="o">.</span><span class="n">write_figure</span><span class="p">(</span><span class="s">&#39;test.jpg&#39;</span><span class="p">)</span>
<span class="c"># 2. write only RGB image, color limits from histogram</span>
<span class="n">n</span><span class="o">.</span><span class="n">write_figure</span><span class="p">(</span><span class="s">&#39;test_rgb_hist.jpg&#39;</span><span class="p">,</span> <span class="n">clim</span><span class="o">=</span><span class="s">&#39;hist&#39;</span><span class="p">,</span>
                <span class="n">bands</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="c"># 3. write indexed image, apply log scaling and gamma correction,</span>
<span class="c"># add legend and type in title &#39;Title&#39;,</span>
<span class="c"># increase font size and put 15 tics</span>
<span class="n">n</span><span class="o">.</span><span class="n">write_figure</span><span class="p">(</span><span class="s">&#39;r09_log3_leg.jpg&#39;</span><span class="p">,</span> <span class="n">logarithm</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
               <span class="n">legend</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">titleString</span><span class="o">=</span><span class="s">&#39;Title&#39;</span><span class="p">,</span>
               <span class="n">fontSize</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">numOfTicks</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="c"># 4. write an image to png with transparent Mask set to color</span>
<span class="c"># transparency=[0, 0, 0], following PIL alpha mask</span>
<span class="n">n</span><span class="o">.</span><span class="n">write_figure</span><span class="p">(</span><span class="n">fileName</span><span class="o">=</span><span class="s">&#39;transparent.png&#39;</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
               <span class="n">mask_array</span><span class="o">=</span><span class="n">wmArray</span><span class="p">,</span> <span class="n">mask_lut</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]},</span>
               <span class="n">clim</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.15</span><span class="p">],</span> <span class="n">cmapName</span><span class="o">=</span><span class="s">&#39;gray&#39;</span><span class="p">,</span>
               <span class="n">transparency</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.write_geotiffimage">
<tt class="descname">write_geotiffimage</tt><big>(</big><em>fileName</em>, <em>bandID=1</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.write_geotiffimage" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes an 8-bit GeoTiff image for a given band.</p>
<div class="line-block">
<div class="line">The output GeoTiff image is convenient</div>
<div class="line-block">
<div class="line">e.g. for display in a GIS tool.</div>
</div>
<div class="line">Colormap is fetched from the metadata item &#8216;colormap&#8217;.</div>
<div class="line-block">
<div class="line">Fallback colormap is &#8216;jet&#8217;.</div>
</div>
<div class="line">Color limits are fetched from the metadata item &#8216;minmax&#8217;.</div>
<div class="line-block">
<div class="line">If &#8216;minmax&#8217; is not specified, min and max of raster is used.</div>
</div>
<div class="line">The method can be replaced by using nansat.write_figure(),
however, write_figure uses PIL which does not allow
Tiff compression, giving much larger files</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : string</p>
<p class="last"><strong>bandID</strong> : integer or string (default = 1)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.write_kml">
<tt class="descname">write_kml</tt><big>(</big><em>xmlFileName=None</em>, <em>kmlFileName=None</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.write_kml" title="Permalink to this definition">¶</a></dt>
<dd><p>Write KML file with domains</p>
<p>Convert XML-file with domains into KML-file for GoogleEarth
or write KML-file with the current Domain</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xmlFileName</strong> : string, optional</p>
<blockquote>
<div><p>Name of the XML-file to convert. If only this value is given
- kmlFileName=xmlFileName+&#8217;.kml&#8217;</p>
</div></blockquote>
<p><strong>kmlFileName</strong> : string, optional</p>
<blockquote class="last">
<div><p>Name of the KML-file to generate from the current Domain</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.write_kml_image">
<tt class="descname">write_kml_image</tt><big>(</big><em>kmlFileName=None</em>, <em>kmlFigureName=None</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.write_kml_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Create KML file for already projected image</p>
<p>Write Domain Image into KML-file for GoogleEarth</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>kmlFileName</strong> : string, optional</p>
<blockquote>
<div><p>Name of the KML-file to generate from the current Domain</p>
</div></blockquote>
<p><strong>kmlFigureName</strong> : string, optional</p>
<blockquote class="last">
<div><p>Name of the projected image stored in .png format</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Create projected a KML image</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># 1. First of all, reproject an image into Lat/Lon WGS84</span>
<span class="c"># (Simple Cylindrical) projection.</span>
<span class="c"># Cancel previous reprojection</span>
<span class="n">n</span><span class="o">.</span><span class="n">reproject</span><span class="p">()</span>
<span class="c"># 2. Get corners of the image and the pixel resolution</span>
<span class="c"># lons, lats = n.get_corners()</span>
<span class="c"># 3. Create Domain with stereographic projection,</span>
<span class="c">#    corner coordinates and resolution 1000m</span>
<span class="n">srsString</span> <span class="o">=</span> <span class="s">&#39;+proj=latlong +datum=WGS84 +ellps=WGS84 +no_defs&#39;</span>
<span class="n">extentString</span> <span class="o">=</span> <span class="s">&#39;-lle </span><span class="si">%f</span><span class="s"> </span><span class="si">%f</span><span class="s"> </span><span class="si">%f</span><span class="s"> </span><span class="si">%f</span><span class="s"> -ts 3000 3000&#39;</span> <span class="o">%</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">lons</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">lats</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">lons</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">lats</span><span class="p">))</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">Domain</span><span class="p">(</span><span class="n">srs</span><span class="o">=</span><span class="n">srsString</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">extentString</span><span class="p">)</span>
<span class="c"># 4. Reproject</span>
<span class="n">n</span><span class="o">.</span><span class="n">reproject</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="c"># 5. Write image</span>
<span class="n">n</span><span class="o">.</span><span class="n">write_figure</span><span class="p">(</span><span class="n">fileName</span><span class="o">=</span><span class="n">figureName</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">clim</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.15</span><span class="p">],</span>
               <span class="n">cmapName</span><span class="o">=</span><span class="s">&#39;gray&#39;</span><span class="p">,</span> <span class="n">transparency</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="c"># 6. Write KML for the image</span>
<span class="n">n</span><span class="o">.</span><span class="n">write_kml_image</span><span class="p">(</span><span class="n">kmlFileName</span><span class="o">=</span><span class="n">oPath</span> <span class="o">+</span> <span class="n">fileName</span> <span class="o">+</span> <span class="s">&#39;.kml&#39;</span><span class="p">,</span>
                  <span class="n">kmlFigureName</span><span class="o">=</span><span class="n">figureName</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.write_map">
<tt class="descname">write_map</tt><big>(</big><em>outputFileName</em>, <em>lonVec=None</em>, <em>latVec=None</em>, <em>lonBorder=10.0</em>, <em>latBorder=10.0</em>, <em>figureSize=(6</em>, <em>6)</em>, <em>dpi=50</em>, <em>projection='cyl'</em>, <em>resolution='c'</em>, <em>continetsColor='coral'</em>, <em>meridians=10</em>, <em>parallels=10</em>, <em>pColor='r'</em>, <em>pLine='k'</em>, <em>pAlpha=0.5</em>, <em>padding=0.0</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.write_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an image with a map of the domain</p>
<div class="line-block">
<div class="line">Uses Basemap to create a World Map.</div>
<div class="line">Adds a semitransparent patch with outline of the Domain</div>
<div class="line">Writes to an image file.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>outputFileName</strong> : string</p>
<blockquote>
<div><p>name of the output file name</p>
</div></blockquote>
<p><strong>lonBorder</strong> : float</p>
<blockquote>
<div><p>10, horisontal border around patch (degrees of longitude)</p>
</div></blockquote>
<p><strong>latBorder</strong> : float</p>
<blockquote>
<div><p>10, vertical border around patch (degrees of latitude)</p>
</div></blockquote>
<p><strong>figureSize</strong> : tuple of two integers</p>
<blockquote>
<div><p>(6, 6), size of the generated figure in inches</p>
</div></blockquote>
<p><strong>dpi: int</strong></p>
<blockquote>
<div><p>50, resolution of the output figure (size 6,6 and dpi 50
produces 300 x 300 figure)</p>
</div></blockquote>
<p><strong>projection</strong> : string, one of Basemap projections</p>
<blockquote>
<div><p>&#8216;cyl&#8217;, projection of the map</p>
</div></blockquote>
<p><strong>resolution</strong> : string, resolution of the map</p>
<blockquote>
<div><div class="line-block">
<div class="line">&#8216;c&#8217;, crude</div>
<div class="line">&#8216;l&#8217;, low</div>
<div class="line">&#8216;i&#8217;, intermediate</div>
<div class="line">&#8216;h&#8217;, high</div>
<div class="line">&#8216;f&#8217;, full</div>
</div>
</div></blockquote>
<p><strong>continetsColor</strong> : string or any matplotlib color representation</p>
<blockquote>
<div><p>&#8216;coral&#8217;, color of continets</p>
</div></blockquote>
<p><strong>meridians</strong> : int</p>
<blockquote>
<div><p>10, number of meridians to draw</p>
</div></blockquote>
<p><strong>parallels</strong> : int</p>
<blockquote>
<div><p>10, number of parallels to draw</p>
</div></blockquote>
<p><strong>pColor</strong> : string or any matplotlib color representation</p>
<blockquote>
<div><p>&#8216;r&#8217;, color of the Domain patch</p>
</div></blockquote>
<p><strong>pLine</strong> : string or any matplotlib color representation</p>
<blockquote>
<div><p>&#8216;k&#8217;, color of the Domain outline</p>
</div></blockquote>
<p><strong>pAlpha</strong> : float 0 - 1</p>
<blockquote>
<div><p>0.5, transparency of Domain patch</p>
</div></blockquote>
<p><strong>padding</strong> : float</p>
<blockquote class="last">
<div><p>0., width of white padding around the map</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2013, Nansen Center.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.1.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>
