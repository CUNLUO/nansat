<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>nansat package &mdash; Nansat 0.6dev documentation</title>
    
    <link rel="stylesheet" type="text/css" href="_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="_static/css/spc-extend.css">
    <link rel="stylesheet" href="_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.6dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/js/copybutton.js"></script>
    <link rel="top" title="Nansat 0.6dev documentation" href="index.html" > 
  </head>
  <body>

<div class="container">
  <div class="top-scipy-org-logo-header">
    <a href="index.html">
      <img style="border: 0;" alt="SciPy" src="_static/img/nansat_logo.gif"></a>
    </div>
  </div>
</div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
        <li class="active"><a href="https://github.com/nansencenter/nansat/">GitHub</a></li>
	
        <li class="active"><a href="index.html">Nansat 0.6dev documentation</a></li>
	 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <div class="section" id="nansat-package">
<h1>nansat package<a class="headerlink" href="#nansat-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="nansat.domain.html">nansat.domain module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="nansat.figure.html">nansat.figure module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="nansat.geolocationarray.html">nansat.geolocationarray module</a></li>
<li class="toctree-l1"><a class="reference internal" href="nansat.mosaic.html">nansat.mosaic module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="nansat.nansat.html">nansat.nansat module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="nansat.nansatmap.html">nansat.nansatmap module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="nansat.nansatshape.html">nansat.nansatshape module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="nansat.vrt.html">nansat.vrt module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="nansat.nansatshape.html">nansat.nansatshape module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="nansat.node.html">nansat.node module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="nansat.nsr.html">nansat.nsr module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="nansat.pointbrowser.html">nansat.pointbrowser module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="nansat.tools.html">nansat.tools module</a></li>
</ul>
</div>
</div>
<div class="section" id="module-nansat">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-nansat" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nansat.NSR">
<em class="property">class </em><tt class="descclassname">nansat.</tt><tt class="descname">NSR</tt><big>(</big><em>srs=0</em><big>)</big><a class="headerlink" href="#nansat.NSR" title="Permalink to this definition">¶</a></dt>
<dd><p>Create Spatial Reference System from input parameter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>srs</strong> : 0, PROJ4 or EPSG or WKT or osr.SpatialReference, NSR</p>
<blockquote class="last">
<div><div class="line-block">
<div class="line">Specifies spatial reference system (SRS)</div>
<div class="line">PROJ4:</div>
<div class="line">string with proj4 options [<a class="reference external" href="http://trac.osgeo.org/proj/">http://trac.osgeo.org/proj/</a>] e.g.:</div>
<div class="line">&#8216;+proj=latlong +datum=WGS84 +ellps=WGS84 +no_defs&#8217;</div>
<div class="line">&#8216;+proj=stere +datum=WGS84 +ellps=WGS84 +lat_0=75 +lon_0=10 +no_defs&#8217;</div>
<div class="line">EPSG:</div>
<div class="line">integer with EPSG number, [<a class="reference external" href="http://spatialreference.org/">http://spatialreference.org/</a>],</div>
<div class="line">e.g. 4326</div>
<div class="line">WKT:</div>
<div class="line">string with Well Know Text of SRS.</div>
<div class="line">E.g.:</div>
<div class="line">&#8216;GEOGCS[&#8220;WGS 84&#8221;,</div>
<div class="line-block">
<div class="line">DATUM[&#8220;WGS_1984&#8221;,</div>
<div class="line-block">
<div class="line">SPHEROID[&#8220;WGS 84&#8221;,6378137,298.257223563,</div>
<div class="line-block">
<div class="line">AUTHORITY[&#8220;EPSG&#8221;,&#8221;7030&#8221;]],</div>
</div>
<div class="line">TOWGS84[0,0,0,0,0,0,0],</div>
<div class="line">AUTHORITY[&#8220;EPSG&#8221;,&#8221;6326&#8221;]],</div>
</div>
<div class="line">PRIMEM[&#8220;Greenwich&#8221;,0,</div>
<div class="line-block">
<div class="line">AUTHORITY[&#8220;EPSG&#8221;,&#8221;8901&#8221;]],</div>
</div>
<div class="line">UNIT[&#8220;degree&#8221;,0.0174532925199433,</div>
<div class="line-block">
<div class="line">AUTHORITY[&#8220;EPSG&#8221;,&#8221;9108&#8221;]],</div>
</div>
<div class="line">AUTHORITY[&#8220;EPSG&#8221;,&#8221;4326&#8221;]]&#8217;</div>
</div>
</div>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="line-block">
<div class="line">see also:</div>
<div class="line"><a class="reference external" href="http://www.gdal.org/gdalwarp.html">http://www.gdal.org/gdalwarp.html</a></div>
<div class="line"><a class="reference external" href="http://trac.osgeo.org/proj/">http://trac.osgeo.org/proj/</a></div>
<div class="line"><a class="reference external" href="http://spatialreference.org/">http://spatialreference.org/</a></div>
<div class="line"><a class="reference external" href="http://www.gdal.org/ogr/osr_tutorial.html">http://www.gdal.org/ogr/osr_tutorial.html</a></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.AutoIdentifyEPSG" title="nansat.NSR.AutoIdentifyEPSG"><tt class="xref py py-obj docutils literal"><span class="pre">AutoIdentifyEPSG</span></tt></a>((self)&nbsp;-&gt;&nbsp;OGRErr)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.Clone" title="nansat.NSR.Clone"><tt class="xref py py-obj docutils literal"><span class="pre">Clone</span></tt></a>((self)&nbsp;-&gt;&nbsp;SpatialReference)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.CloneGeogCS" title="nansat.NSR.CloneGeogCS"><tt class="xref py py-obj docutils literal"><span class="pre">CloneGeogCS</span></tt></a>((self)&nbsp;-&gt;&nbsp;SpatialReference)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.CopyGeogCSFrom" title="nansat.NSR.CopyGeogCSFrom"><tt class="xref py py-obj docutils literal"><span class="pre">CopyGeogCSFrom</span></tt></a>((self,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.EPSGTreatsAsLatLong" title="nansat.NSR.EPSGTreatsAsLatLong"><tt class="xref py py-obj docutils literal"><span class="pre">EPSGTreatsAsLatLong</span></tt></a>((self)&nbsp;-&gt;&nbsp;int)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.ExportToMICoordSys" title="nansat.NSR.ExportToMICoordSys"><tt class="xref py py-obj docutils literal"><span class="pre">ExportToMICoordSys</span></tt></a>((self)&nbsp;-&gt;&nbsp;OGRErr)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.ExportToPCI" title="nansat.NSR.ExportToPCI"><tt class="xref py py-obj docutils literal"><span class="pre">ExportToPCI</span></tt></a>((self)&nbsp;-&gt;&nbsp;OGRErr)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.ExportToPrettyWkt" title="nansat.NSR.ExportToPrettyWkt"><tt class="xref py py-obj docutils literal"><span class="pre">ExportToPrettyWkt</span></tt></a>((self,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.ExportToProj4" title="nansat.NSR.ExportToProj4"><tt class="xref py py-obj docutils literal"><span class="pre">ExportToProj4</span></tt></a>((self)&nbsp;-&gt;&nbsp;OGRErr)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.ExportToUSGS" title="nansat.NSR.ExportToUSGS"><tt class="xref py py-obj docutils literal"><span class="pre">ExportToUSGS</span></tt></a>((self)&nbsp;-&gt;&nbsp;OGRErr)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.ExportToWkt" title="nansat.NSR.ExportToWkt"><tt class="xref py py-obj docutils literal"><span class="pre">ExportToWkt</span></tt></a>((self)&nbsp;-&gt;&nbsp;OGRErr)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.ExportToXML" title="nansat.NSR.ExportToXML"><tt class="xref py py-obj docutils literal"><span class="pre">ExportToXML</span></tt></a>((self,&nbsp;char&nbsp;dialect&nbsp;=&nbsp;&#8221;&#8221;)&nbsp;-&gt;&nbsp;OGRErr)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.Fixup" title="nansat.NSR.Fixup"><tt class="xref py py-obj docutils literal"><span class="pre">Fixup</span></tt></a>((self)&nbsp;-&gt;&nbsp;OGRErr)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.FixupOrdering" title="nansat.NSR.FixupOrdering"><tt class="xref py py-obj docutils literal"><span class="pre">FixupOrdering</span></tt></a>((self)&nbsp;-&gt;&nbsp;OGRErr)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.GetAngularUnits" title="nansat.NSR.GetAngularUnits"><tt class="xref py py-obj docutils literal"><span class="pre">GetAngularUnits</span></tt></a>((self)&nbsp;-&gt;&nbsp;double)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.GetAttrValue" title="nansat.NSR.GetAttrValue"><tt class="xref py py-obj docutils literal"><span class="pre">GetAttrValue</span></tt></a>((self,&nbsp;char&nbsp;name,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.GetAuthorityCode" title="nansat.NSR.GetAuthorityCode"><tt class="xref py py-obj docutils literal"><span class="pre">GetAuthorityCode</span></tt></a>((self,&nbsp;char&nbsp;target_key)&nbsp;-&gt;&nbsp;char)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.GetAuthorityName" title="nansat.NSR.GetAuthorityName"><tt class="xref py py-obj docutils literal"><span class="pre">GetAuthorityName</span></tt></a>((self,&nbsp;char&nbsp;target_key)&nbsp;-&gt;&nbsp;char)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.GetInvFlattening" title="nansat.NSR.GetInvFlattening"><tt class="xref py py-obj docutils literal"><span class="pre">GetInvFlattening</span></tt></a>((self)&nbsp;-&gt;&nbsp;double)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.GetLinearUnits" title="nansat.NSR.GetLinearUnits"><tt class="xref py py-obj docutils literal"><span class="pre">GetLinearUnits</span></tt></a>((self)&nbsp;-&gt;&nbsp;double)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.GetLinearUnitsName" title="nansat.NSR.GetLinearUnitsName"><tt class="xref py py-obj docutils literal"><span class="pre">GetLinearUnitsName</span></tt></a>((self)&nbsp;-&gt;&nbsp;char)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.GetNormProjParm" title="nansat.NSR.GetNormProjParm"><tt class="xref py py-obj docutils literal"><span class="pre">GetNormProjParm</span></tt></a>((self,&nbsp;char&nbsp;name,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.GetProjParm" title="nansat.NSR.GetProjParm"><tt class="xref py py-obj docutils literal"><span class="pre">GetProjParm</span></tt></a>((self,&nbsp;char&nbsp;name,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.GetSemiMajor" title="nansat.NSR.GetSemiMajor"><tt class="xref py py-obj docutils literal"><span class="pre">GetSemiMajor</span></tt></a>((self)&nbsp;-&gt;&nbsp;double)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.GetSemiMinor" title="nansat.NSR.GetSemiMinor"><tt class="xref py py-obj docutils literal"><span class="pre">GetSemiMinor</span></tt></a>((self)&nbsp;-&gt;&nbsp;double)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.GetTOWGS84" title="nansat.NSR.GetTOWGS84"><tt class="xref py py-obj docutils literal"><span class="pre">GetTOWGS84</span></tt></a>((self)&nbsp;-&gt;&nbsp;OGRErr)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.GetUTMZone" title="nansat.NSR.GetUTMZone"><tt class="xref py py-obj docutils literal"><span class="pre">GetUTMZone</span></tt></a>((self)&nbsp;-&gt;&nbsp;int)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.ImportFromEPSG" title="nansat.NSR.ImportFromEPSG"><tt class="xref py py-obj docutils literal"><span class="pre">ImportFromEPSG</span></tt></a>((self,&nbsp;int&nbsp;arg)&nbsp;-&gt;&nbsp;OGRErr)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.ImportFromEPSGA" title="nansat.NSR.ImportFromEPSGA"><tt class="xref py py-obj docutils literal"><span class="pre">ImportFromEPSGA</span></tt></a>((self,&nbsp;int&nbsp;arg)&nbsp;-&gt;&nbsp;OGRErr)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.ImportFromERM" title="nansat.NSR.ImportFromERM"><tt class="xref py py-obj docutils literal"><span class="pre">ImportFromERM</span></tt></a>((self,&nbsp;char&nbsp;proj,&nbsp;char&nbsp;datum,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.ImportFromESRI" title="nansat.NSR.ImportFromESRI"><tt class="xref py py-obj docutils literal"><span class="pre">ImportFromESRI</span></tt></a>((self,&nbsp;char&nbsp;ppszInput)&nbsp;-&gt;&nbsp;OGRErr)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.ImportFromMICoordSys" title="nansat.NSR.ImportFromMICoordSys"><tt class="xref py py-obj docutils literal"><span class="pre">ImportFromMICoordSys</span></tt></a>((self,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.ImportFromOzi" title="nansat.NSR.ImportFromOzi"><tt class="xref py py-obj docutils literal"><span class="pre">ImportFromOzi</span></tt></a>((self,&nbsp;char&nbsp;datum,&nbsp;char&nbsp;proj,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.ImportFromPCI" title="nansat.NSR.ImportFromPCI"><tt class="xref py py-obj docutils literal"><span class="pre">ImportFromPCI</span></tt></a>((self,&nbsp;char&nbsp;proj,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.ImportFromProj4" title="nansat.NSR.ImportFromProj4"><tt class="xref py py-obj docutils literal"><span class="pre">ImportFromProj4</span></tt></a>((self,&nbsp;char&nbsp;ppszInput)&nbsp;-&gt;&nbsp;OGRErr)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.ImportFromUSGS" title="nansat.NSR.ImportFromUSGS"><tt class="xref py py-obj docutils literal"><span class="pre">ImportFromUSGS</span></tt></a>((self,&nbsp;long&nbsp;proj_code,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.ImportFromUrl" title="nansat.NSR.ImportFromUrl"><tt class="xref py py-obj docutils literal"><span class="pre">ImportFromUrl</span></tt></a>((self,&nbsp;char&nbsp;url)&nbsp;-&gt;&nbsp;OGRErr)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.ImportFromWkt" title="nansat.NSR.ImportFromWkt"><tt class="xref py py-obj docutils literal"><span class="pre">ImportFromWkt</span></tt></a>((self,&nbsp;char&nbsp;ppszInput)&nbsp;-&gt;&nbsp;OGRErr)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.ImportFromXML" title="nansat.NSR.ImportFromXML"><tt class="xref py py-obj docutils literal"><span class="pre">ImportFromXML</span></tt></a>((self,&nbsp;char&nbsp;xmlString)&nbsp;-&gt;&nbsp;OGRErr)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.IsCompound" title="nansat.NSR.IsCompound"><tt class="xref py py-obj docutils literal"><span class="pre">IsCompound</span></tt></a>((self)&nbsp;-&gt;&nbsp;int)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.IsGeocentric" title="nansat.NSR.IsGeocentric"><tt class="xref py py-obj docutils literal"><span class="pre">IsGeocentric</span></tt></a>((self)&nbsp;-&gt;&nbsp;int)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.IsGeographic" title="nansat.NSR.IsGeographic"><tt class="xref py py-obj docutils literal"><span class="pre">IsGeographic</span></tt></a>((self)&nbsp;-&gt;&nbsp;int)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.IsLocal" title="nansat.NSR.IsLocal"><tt class="xref py py-obj docutils literal"><span class="pre">IsLocal</span></tt></a>((self)&nbsp;-&gt;&nbsp;int)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.IsProjected" title="nansat.NSR.IsProjected"><tt class="xref py py-obj docutils literal"><span class="pre">IsProjected</span></tt></a>((self)&nbsp;-&gt;&nbsp;int)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.IsSame" title="nansat.NSR.IsSame"><tt class="xref py py-obj docutils literal"><span class="pre">IsSame</span></tt></a>((self,&nbsp;SpatialReference&nbsp;rhs)&nbsp;-&gt;&nbsp;int)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.IsSameGeogCS" title="nansat.NSR.IsSameGeogCS"><tt class="xref py py-obj docutils literal"><span class="pre">IsSameGeogCS</span></tt></a>((self,&nbsp;SpatialReference&nbsp;rhs)&nbsp;-&gt;&nbsp;int)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.IsSameVertCS" title="nansat.NSR.IsSameVertCS"><tt class="xref py py-obj docutils literal"><span class="pre">IsSameVertCS</span></tt></a>((self,&nbsp;SpatialReference&nbsp;rhs)&nbsp;-&gt;&nbsp;int)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.IsVertical" title="nansat.NSR.IsVertical"><tt class="xref py py-obj docutils literal"><span class="pre">IsVertical</span></tt></a>((self)&nbsp;-&gt;&nbsp;int)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.MorphFromESRI" title="nansat.NSR.MorphFromESRI"><tt class="xref py py-obj docutils literal"><span class="pre">MorphFromESRI</span></tt></a>((self)&nbsp;-&gt;&nbsp;OGRErr)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.MorphToESRI" title="nansat.NSR.MorphToESRI"><tt class="xref py py-obj docutils literal"><span class="pre">MorphToESRI</span></tt></a>((self)&nbsp;-&gt;&nbsp;OGRErr)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.SetACEA" title="nansat.NSR.SetACEA"><tt class="xref py py-obj docutils literal"><span class="pre">SetACEA</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>SetACEA(self, double stdp1, double stdp2, double clat, double clong,</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.SetAE" title="nansat.NSR.SetAE"><tt class="xref py py-obj docutils literal"><span class="pre">SetAE</span></tt></a>((self,&nbsp;double&nbsp;clat,&nbsp;double&nbsp;clong,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.SetAngularUnits" title="nansat.NSR.SetAngularUnits"><tt class="xref py py-obj docutils literal"><span class="pre">SetAngularUnits</span></tt></a>((self,&nbsp;char&nbsp;name,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.SetAttrValue" title="nansat.NSR.SetAttrValue"><tt class="xref py py-obj docutils literal"><span class="pre">SetAttrValue</span></tt></a>((self,&nbsp;char&nbsp;name,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.SetAuthority" title="nansat.NSR.SetAuthority"><tt class="xref py py-obj docutils literal"><span class="pre">SetAuthority</span></tt></a>((self,&nbsp;char&nbsp;pszTargetKey,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.SetBonne" title="nansat.NSR.SetBonne"><tt class="xref py py-obj docutils literal"><span class="pre">SetBonne</span></tt></a>((self,&nbsp;double&nbsp;stdp,&nbsp;double&nbsp;cm,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.SetCEA" title="nansat.NSR.SetCEA"><tt class="xref py py-obj docutils literal"><span class="pre">SetCEA</span></tt></a>((self,&nbsp;double&nbsp;stdp1,&nbsp;double&nbsp;cm,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.SetCS" title="nansat.NSR.SetCS"><tt class="xref py py-obj docutils literal"><span class="pre">SetCS</span></tt></a>((self,&nbsp;double&nbsp;clat,&nbsp;double&nbsp;clong,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.SetCompoundCS" title="nansat.NSR.SetCompoundCS"><tt class="xref py py-obj docutils literal"><span class="pre">SetCompoundCS</span></tt></a>((self,&nbsp;char&nbsp;name,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.SetEC" title="nansat.NSR.SetEC"><tt class="xref py py-obj docutils literal"><span class="pre">SetEC</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>SetEC(self, double stdp1, double stdp2, double clat, double clong,</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.SetEckertIV" title="nansat.NSR.SetEckertIV"><tt class="xref py py-obj docutils literal"><span class="pre">SetEckertIV</span></tt></a>((self,&nbsp;double&nbsp;cm,&nbsp;double&nbsp;fe,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.SetEckertVI" title="nansat.NSR.SetEckertVI"><tt class="xref py py-obj docutils literal"><span class="pre">SetEckertVI</span></tt></a>((self,&nbsp;double&nbsp;cm,&nbsp;double&nbsp;fe,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.SetEquirectangular" title="nansat.NSR.SetEquirectangular"><tt class="xref py py-obj docutils literal"><span class="pre">SetEquirectangular</span></tt></a>((self,&nbsp;double&nbsp;clat,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.SetEquirectangular2" title="nansat.NSR.SetEquirectangular2"><tt class="xref py py-obj docutils literal"><span class="pre">SetEquirectangular2</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>SetEquirectangular2(self, double clat, double clong, double pseudostdparallellat,</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.SetFromUserInput" title="nansat.NSR.SetFromUserInput"><tt class="xref py py-obj docutils literal"><span class="pre">SetFromUserInput</span></tt></a>((self,&nbsp;char&nbsp;name)&nbsp;-&gt;&nbsp;OGRErr)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.SetGEOS" title="nansat.NSR.SetGEOS"><tt class="xref py py-obj docutils literal"><span class="pre">SetGEOS</span></tt></a>((self,&nbsp;double&nbsp;cm,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.SetGH" title="nansat.NSR.SetGH"><tt class="xref py py-obj docutils literal"><span class="pre">SetGH</span></tt></a>((self,&nbsp;double&nbsp;cm,&nbsp;double&nbsp;fe,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.SetGS" title="nansat.NSR.SetGS"><tt class="xref py py-obj docutils literal"><span class="pre">SetGS</span></tt></a>((self,&nbsp;double&nbsp;cm,&nbsp;double&nbsp;fe,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.SetGaussSchreiberTMercator" title="nansat.NSR.SetGaussSchreiberTMercator"><tt class="xref py py-obj docutils literal"><span class="pre">SetGaussSchreiberTMercator</span></tt></a>((self,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.SetGeocCS" title="nansat.NSR.SetGeocCS"><tt class="xref py py-obj docutils literal"><span class="pre">SetGeocCS</span></tt></a>((self,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.SetGeogCS" title="nansat.NSR.SetGeogCS"><tt class="xref py py-obj docutils literal"><span class="pre">SetGeogCS</span></tt></a>(*args)</td>
<td>SetGeogCS(self, char pszGeogName, char pszDatumName, char pszEllipsoidName,</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.SetGnomonic" title="nansat.NSR.SetGnomonic"><tt class="xref py py-obj docutils literal"><span class="pre">SetGnomonic</span></tt></a>((self,&nbsp;double&nbsp;clat,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.SetHOM" title="nansat.NSR.SetHOM"><tt class="xref py py-obj docutils literal"><span class="pre">SetHOM</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>SetHOM(self, double clat, double clong, double azimuth, double recttoskew,</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.SetHOM2PNO" title="nansat.NSR.SetHOM2PNO"><tt class="xref py py-obj docutils literal"><span class="pre">SetHOM2PNO</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>SetHOM2PNO(self, double clat, double dfLat1, double dfLong1, double dfLat2,</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.SetIGH" title="nansat.NSR.SetIGH"><tt class="xref py py-obj docutils literal"><span class="pre">SetIGH</span></tt></a>((self)&nbsp;-&gt;&nbsp;OGRErr)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.SetKrovak" title="nansat.NSR.SetKrovak"><tt class="xref py py-obj docutils literal"><span class="pre">SetKrovak</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>SetKrovak(self, double clat, double clong, double azimuth, double pseudostdparallellat,</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.SetLAEA" title="nansat.NSR.SetLAEA"><tt class="xref py py-obj docutils literal"><span class="pre">SetLAEA</span></tt></a>((self,&nbsp;double&nbsp;clat,&nbsp;double&nbsp;clong,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.SetLCC" title="nansat.NSR.SetLCC"><tt class="xref py py-obj docutils literal"><span class="pre">SetLCC</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>SetLCC(self, double stdp1, double stdp2, double clat, double clong,</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.SetLCC1SP" title="nansat.NSR.SetLCC1SP"><tt class="xref py py-obj docutils literal"><span class="pre">SetLCC1SP</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>SetLCC1SP(self, double clat, double clong, double scale, double fe,</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.SetLCCB" title="nansat.NSR.SetLCCB"><tt class="xref py py-obj docutils literal"><span class="pre">SetLCCB</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>SetLCCB(self, double stdp1, double stdp2, double clat, double clong,</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.SetLinearUnits" title="nansat.NSR.SetLinearUnits"><tt class="xref py py-obj docutils literal"><span class="pre">SetLinearUnits</span></tt></a>((self,&nbsp;char&nbsp;name,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.SetLinearUnitsAndUpdateParameters" title="nansat.NSR.SetLinearUnitsAndUpdateParameters"><tt class="xref py py-obj docutils literal"><span class="pre">SetLinearUnitsAndUpdateParameters</span></tt></a>((self,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.SetLocalCS" title="nansat.NSR.SetLocalCS"><tt class="xref py py-obj docutils literal"><span class="pre">SetLocalCS</span></tt></a>((self,&nbsp;char&nbsp;pszName)&nbsp;-&gt;&nbsp;OGRErr)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.SetMC" title="nansat.NSR.SetMC"><tt class="xref py py-obj docutils literal"><span class="pre">SetMC</span></tt></a>((self,&nbsp;double&nbsp;clat,&nbsp;double&nbsp;clong,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.SetMercator" title="nansat.NSR.SetMercator"><tt class="xref py py-obj docutils literal"><span class="pre">SetMercator</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>SetMercator(self, double clat, double clong, double scale, double fe,</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.SetMollweide" title="nansat.NSR.SetMollweide"><tt class="xref py py-obj docutils literal"><span class="pre">SetMollweide</span></tt></a>((self,&nbsp;double&nbsp;cm,&nbsp;double&nbsp;fe,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.SetNZMG" title="nansat.NSR.SetNZMG"><tt class="xref py py-obj docutils literal"><span class="pre">SetNZMG</span></tt></a>((self,&nbsp;double&nbsp;clat,&nbsp;double&nbsp;clong,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.SetNormProjParm" title="nansat.NSR.SetNormProjParm"><tt class="xref py py-obj docutils literal"><span class="pre">SetNormProjParm</span></tt></a>((self,&nbsp;char&nbsp;name,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.SetOS" title="nansat.NSR.SetOS"><tt class="xref py py-obj docutils literal"><span class="pre">SetOS</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>SetOS(self, double dfOriginLat, double dfCMeridian, double scale,</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.SetOrthographic" title="nansat.NSR.SetOrthographic"><tt class="xref py py-obj docutils literal"><span class="pre">SetOrthographic</span></tt></a>((self,&nbsp;double&nbsp;clat,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.SetPS" title="nansat.NSR.SetPS"><tt class="xref py py-obj docutils literal"><span class="pre">SetPS</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>SetPS(self, double clat, double clong, double scale, double fe,</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.SetPolyconic" title="nansat.NSR.SetPolyconic"><tt class="xref py py-obj docutils literal"><span class="pre">SetPolyconic</span></tt></a>((self,&nbsp;double&nbsp;clat,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.SetProjCS" title="nansat.NSR.SetProjCS"><tt class="xref py py-obj docutils literal"><span class="pre">SetProjCS</span></tt></a>((self,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.SetProjParm" title="nansat.NSR.SetProjParm"><tt class="xref py py-obj docutils literal"><span class="pre">SetProjParm</span></tt></a>((self,&nbsp;char&nbsp;name,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.SetProjection" title="nansat.NSR.SetProjection"><tt class="xref py py-obj docutils literal"><span class="pre">SetProjection</span></tt></a>((self,&nbsp;char&nbsp;arg)&nbsp;-&gt;&nbsp;OGRErr)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.SetRobinson" title="nansat.NSR.SetRobinson"><tt class="xref py py-obj docutils literal"><span class="pre">SetRobinson</span></tt></a>((self,&nbsp;double&nbsp;clong,&nbsp;double&nbsp;fe,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.SetSOC" title="nansat.NSR.SetSOC"><tt class="xref py py-obj docutils literal"><span class="pre">SetSOC</span></tt></a>((self,&nbsp;double&nbsp;latitudeoforigin,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.SetSinusoidal" title="nansat.NSR.SetSinusoidal"><tt class="xref py py-obj docutils literal"><span class="pre">SetSinusoidal</span></tt></a>((self,&nbsp;double&nbsp;clong,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.SetStatePlane" title="nansat.NSR.SetStatePlane"><tt class="xref py py-obj docutils literal"><span class="pre">SetStatePlane</span></tt></a>((self,&nbsp;int&nbsp;zone,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.SetStereographic" title="nansat.NSR.SetStereographic"><tt class="xref py py-obj docutils literal"><span class="pre">SetStereographic</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>SetStereographic(self, double clat, double clong, double scale, double fe,</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.SetTM" title="nansat.NSR.SetTM"><tt class="xref py py-obj docutils literal"><span class="pre">SetTM</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>SetTM(self, double clat, double clong, double scale, double fe,</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.SetTMG" title="nansat.NSR.SetTMG"><tt class="xref py py-obj docutils literal"><span class="pre">SetTMG</span></tt></a>((self,&nbsp;double&nbsp;clat,&nbsp;double&nbsp;clong,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.SetTMSO" title="nansat.NSR.SetTMSO"><tt class="xref py py-obj docutils literal"><span class="pre">SetTMSO</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>SetTMSO(self, double clat, double clong, double scale, double fe,</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.SetTMVariant" title="nansat.NSR.SetTMVariant"><tt class="xref py py-obj docutils literal"><span class="pre">SetTMVariant</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>SetTMVariant(self, char pszVariantName, double clat, double clong, double scale,</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.SetTOWGS84" title="nansat.NSR.SetTOWGS84"><tt class="xref py py-obj docutils literal"><span class="pre">SetTOWGS84</span></tt></a>(*args)</td>
<td>SetTOWGS84(self, double p1, double p2, double p3, double p4 = 0.0, double p5 = 0.0,</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.SetTargetLinearUnits" title="nansat.NSR.SetTargetLinearUnits"><tt class="xref py py-obj docutils literal"><span class="pre">SetTargetLinearUnits</span></tt></a>((self,&nbsp;char&nbsp;target,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.SetUTM" title="nansat.NSR.SetUTM"><tt class="xref py py-obj docutils literal"><span class="pre">SetUTM</span></tt></a>((self,&nbsp;int&nbsp;zone,&nbsp;int&nbsp;north&nbsp;=&nbsp;1)&nbsp;-&gt;&nbsp;OGRErr)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.SetVDG" title="nansat.NSR.SetVDG"><tt class="xref py py-obj docutils literal"><span class="pre">SetVDG</span></tt></a>((self,&nbsp;double&nbsp;clong,&nbsp;double&nbsp;fe,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.SetVertCS" title="nansat.NSR.SetVertCS"><tt class="xref py py-obj docutils literal"><span class="pre">SetVertCS</span></tt></a>(*args)</td>
<td>SetVertCS(self, char VertCSName = &#8220;unnamed&#8221;, char VertDatumName = &#8220;unnamed&#8221;,</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.SetWellKnownGeogCS" title="nansat.NSR.SetWellKnownGeogCS"><tt class="xref py py-obj docutils literal"><span class="pre">SetWellKnownGeogCS</span></tt></a>((self,&nbsp;char&nbsp;name)&nbsp;-&gt;&nbsp;OGRErr)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.NSR.StripCTParms" title="nansat.NSR.StripCTParms"><tt class="xref py py-obj docutils literal"><span class="pre">StripCTParms</span></tt></a>((self)&nbsp;-&gt;&nbsp;OGRErr)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.NSR.Validate" title="nansat.NSR.Validate"><tt class="xref py py-obj docutils literal"><span class="pre">Validate</span></tt></a>((self)&nbsp;-&gt;&nbsp;OGRErr)</td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nansat.NSR.AutoIdentifyEPSG">
<tt class="descname">AutoIdentifyEPSG</tt><big>(</big><em>self</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.AutoIdentifyEPSG" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.Clone">
<tt class="descname">Clone</tt><big>(</big><em>self</em><big>)</big> &rarr; SpatialReference<a class="headerlink" href="#nansat.NSR.Clone" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.CloneGeogCS">
<tt class="descname">CloneGeogCS</tt><big>(</big><em>self</em><big>)</big> &rarr; SpatialReference<a class="headerlink" href="#nansat.NSR.CloneGeogCS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.CopyGeogCSFrom">
<tt class="descname">CopyGeogCSFrom</tt><big>(</big><em>self</em>, <em>SpatialReference rhs</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.CopyGeogCSFrom" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.EPSGTreatsAsLatLong">
<tt class="descname">EPSGTreatsAsLatLong</tt><big>(</big><em>self</em><big>)</big> &rarr; int<a class="headerlink" href="#nansat.NSR.EPSGTreatsAsLatLong" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.ExportToMICoordSys">
<tt class="descname">ExportToMICoordSys</tt><big>(</big><em>self</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.ExportToMICoordSys" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.ExportToPCI">
<tt class="descname">ExportToPCI</tt><big>(</big><em>self</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.ExportToPCI" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.ExportToPrettyWkt">
<tt class="descname">ExportToPrettyWkt</tt><big>(</big><em>self</em>, <em>int simplify = 0</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.ExportToPrettyWkt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.ExportToProj4">
<tt class="descname">ExportToProj4</tt><big>(</big><em>self</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.ExportToProj4" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.ExportToUSGS">
<tt class="descname">ExportToUSGS</tt><big>(</big><em>self</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.ExportToUSGS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.ExportToWkt">
<tt class="descname">ExportToWkt</tt><big>(</big><em>self</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.ExportToWkt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.ExportToXML">
<tt class="descname">ExportToXML</tt><big>(</big><em>self</em>, <em>char dialect = &quot;&quot;</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.ExportToXML" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.Fixup">
<tt class="descname">Fixup</tt><big>(</big><em>self</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.Fixup" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.FixupOrdering">
<tt class="descname">FixupOrdering</tt><big>(</big><em>self</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.FixupOrdering" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.GetAngularUnits">
<tt class="descname">GetAngularUnits</tt><big>(</big><em>self</em><big>)</big> &rarr; double<a class="headerlink" href="#nansat.NSR.GetAngularUnits" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.GetAttrValue">
<tt class="descname">GetAttrValue</tt><big>(</big><em>self</em>, <em>char name</em>, <em>int child = 0</em><big>)</big> &rarr; char<a class="headerlink" href="#nansat.NSR.GetAttrValue" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.GetAuthorityCode">
<tt class="descname">GetAuthorityCode</tt><big>(</big><em>self</em>, <em>char target_key</em><big>)</big> &rarr; char<a class="headerlink" href="#nansat.NSR.GetAuthorityCode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.GetAuthorityName">
<tt class="descname">GetAuthorityName</tt><big>(</big><em>self</em>, <em>char target_key</em><big>)</big> &rarr; char<a class="headerlink" href="#nansat.NSR.GetAuthorityName" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.GetInvFlattening">
<tt class="descname">GetInvFlattening</tt><big>(</big><em>self</em><big>)</big> &rarr; double<a class="headerlink" href="#nansat.NSR.GetInvFlattening" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.GetLinearUnits">
<tt class="descname">GetLinearUnits</tt><big>(</big><em>self</em><big>)</big> &rarr; double<a class="headerlink" href="#nansat.NSR.GetLinearUnits" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.GetLinearUnitsName">
<tt class="descname">GetLinearUnitsName</tt><big>(</big><em>self</em><big>)</big> &rarr; char<a class="headerlink" href="#nansat.NSR.GetLinearUnitsName" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.GetNormProjParm">
<tt class="descname">GetNormProjParm</tt><big>(</big><em>self</em>, <em>char name</em>, <em>double default_val = 0.0</em><big>)</big> &rarr; double<a class="headerlink" href="#nansat.NSR.GetNormProjParm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.GetProjParm">
<tt class="descname">GetProjParm</tt><big>(</big><em>self</em>, <em>char name</em>, <em>double default_val = 0.0</em><big>)</big> &rarr; double<a class="headerlink" href="#nansat.NSR.GetProjParm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.GetSemiMajor">
<tt class="descname">GetSemiMajor</tt><big>(</big><em>self</em><big>)</big> &rarr; double<a class="headerlink" href="#nansat.NSR.GetSemiMajor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.GetSemiMinor">
<tt class="descname">GetSemiMinor</tt><big>(</big><em>self</em><big>)</big> &rarr; double<a class="headerlink" href="#nansat.NSR.GetSemiMinor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.GetTOWGS84">
<tt class="descname">GetTOWGS84</tt><big>(</big><em>self</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.GetTOWGS84" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.GetUTMZone">
<tt class="descname">GetUTMZone</tt><big>(</big><em>self</em><big>)</big> &rarr; int<a class="headerlink" href="#nansat.NSR.GetUTMZone" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.ImportFromEPSG">
<tt class="descname">ImportFromEPSG</tt><big>(</big><em>self</em>, <em>int arg</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.ImportFromEPSG" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.ImportFromEPSGA">
<tt class="descname">ImportFromEPSGA</tt><big>(</big><em>self</em>, <em>int arg</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.ImportFromEPSGA" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.ImportFromERM">
<tt class="descname">ImportFromERM</tt><big>(</big><em>self</em>, <em>char proj</em>, <em>char datum</em>, <em>char units</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.ImportFromERM" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.ImportFromESRI">
<tt class="descname">ImportFromESRI</tt><big>(</big><em>self</em>, <em>char ppszInput</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.ImportFromESRI" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.ImportFromMICoordSys">
<tt class="descname">ImportFromMICoordSys</tt><big>(</big><em>self</em>, <em>char pszCoordSys</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.ImportFromMICoordSys" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.ImportFromOzi">
<tt class="descname">ImportFromOzi</tt><big>(</big><em>self</em>, <em>char datum</em>, <em>char proj</em>, <em>char projParms</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.ImportFromOzi" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.ImportFromPCI">
<tt class="descname">ImportFromPCI</tt><big>(</big><em>self</em>, <em>char proj</em>, <em>char units = &quot;METRE&quot;</em>, <em>double argin = 0</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.ImportFromPCI" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.ImportFromProj4">
<tt class="descname">ImportFromProj4</tt><big>(</big><em>self</em>, <em>char ppszInput</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.ImportFromProj4" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.ImportFromUSGS">
<tt class="descname">ImportFromUSGS</tt><big>(</big><em>self</em>, <em>long proj_code</em>, <em>long zone = 0</em>, <em>double argin = 0</em>, <em>long datum_code = 0</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.ImportFromUSGS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.ImportFromUrl">
<tt class="descname">ImportFromUrl</tt><big>(</big><em>self</em>, <em>char url</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.ImportFromUrl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.ImportFromWkt">
<tt class="descname">ImportFromWkt</tt><big>(</big><em>self</em>, <em>char ppszInput</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.ImportFromWkt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.ImportFromXML">
<tt class="descname">ImportFromXML</tt><big>(</big><em>self</em>, <em>char xmlString</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.ImportFromXML" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.IsCompound">
<tt class="descname">IsCompound</tt><big>(</big><em>self</em><big>)</big> &rarr; int<a class="headerlink" href="#nansat.NSR.IsCompound" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.IsGeocentric">
<tt class="descname">IsGeocentric</tt><big>(</big><em>self</em><big>)</big> &rarr; int<a class="headerlink" href="#nansat.NSR.IsGeocentric" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.IsGeographic">
<tt class="descname">IsGeographic</tt><big>(</big><em>self</em><big>)</big> &rarr; int<a class="headerlink" href="#nansat.NSR.IsGeographic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.IsLocal">
<tt class="descname">IsLocal</tt><big>(</big><em>self</em><big>)</big> &rarr; int<a class="headerlink" href="#nansat.NSR.IsLocal" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.IsProjected">
<tt class="descname">IsProjected</tt><big>(</big><em>self</em><big>)</big> &rarr; int<a class="headerlink" href="#nansat.NSR.IsProjected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.IsSame">
<tt class="descname">IsSame</tt><big>(</big><em>self</em>, <em>SpatialReference rhs</em><big>)</big> &rarr; int<a class="headerlink" href="#nansat.NSR.IsSame" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.IsSameGeogCS">
<tt class="descname">IsSameGeogCS</tt><big>(</big><em>self</em>, <em>SpatialReference rhs</em><big>)</big> &rarr; int<a class="headerlink" href="#nansat.NSR.IsSameGeogCS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.IsSameVertCS">
<tt class="descname">IsSameVertCS</tt><big>(</big><em>self</em>, <em>SpatialReference rhs</em><big>)</big> &rarr; int<a class="headerlink" href="#nansat.NSR.IsSameVertCS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.IsVertical">
<tt class="descname">IsVertical</tt><big>(</big><em>self</em><big>)</big> &rarr; int<a class="headerlink" href="#nansat.NSR.IsVertical" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.MorphFromESRI">
<tt class="descname">MorphFromESRI</tt><big>(</big><em>self</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.MorphFromESRI" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.MorphToESRI">
<tt class="descname">MorphToESRI</tt><big>(</big><em>self</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.MorphToESRI" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetACEA">
<tt class="descname">SetACEA</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.NSR.SetACEA" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>SetACEA(self, double stdp1, double stdp2, double clat, double clong, </dt>
<dd>double fe, double fn) -&gt; OGRErr</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetAE">
<tt class="descname">SetAE</tt><big>(</big><em>self</em>, <em>double clat</em>, <em>double clong</em>, <em>double fe</em>, <em>double fn</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetAE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetAngularUnits">
<tt class="descname">SetAngularUnits</tt><big>(</big><em>self</em>, <em>char name</em>, <em>double to_radians</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetAngularUnits" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetAttrValue">
<tt class="descname">SetAttrValue</tt><big>(</big><em>self</em>, <em>char name</em>, <em>char value</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetAttrValue" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetAuthority">
<tt class="descname">SetAuthority</tt><big>(</big><em>self</em>, <em>char pszTargetKey</em>, <em>char pszAuthority</em>, <em>int nCode</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetAuthority" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetBonne">
<tt class="descname">SetBonne</tt><big>(</big><em>self</em>, <em>double stdp</em>, <em>double cm</em>, <em>double fe</em>, <em>double fn</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetBonne" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetCEA">
<tt class="descname">SetCEA</tt><big>(</big><em>self</em>, <em>double stdp1</em>, <em>double cm</em>, <em>double fe</em>, <em>double fn</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetCEA" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetCS">
<tt class="descname">SetCS</tt><big>(</big><em>self</em>, <em>double clat</em>, <em>double clong</em>, <em>double fe</em>, <em>double fn</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetCS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetCompoundCS">
<tt class="descname">SetCompoundCS</tt><big>(</big><em>self</em>, <em>char name</em>, <em>SpatialReference horizcs</em>, <em>SpatialReference vertcs</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetCompoundCS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetEC">
<tt class="descname">SetEC</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.NSR.SetEC" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>SetEC(self, double stdp1, double stdp2, double clat, double clong, </dt>
<dd>double fe, double fn) -&gt; OGRErr</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetEckertIV">
<tt class="descname">SetEckertIV</tt><big>(</big><em>self</em>, <em>double cm</em>, <em>double fe</em>, <em>double fn</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetEckertIV" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetEckertVI">
<tt class="descname">SetEckertVI</tt><big>(</big><em>self</em>, <em>double cm</em>, <em>double fe</em>, <em>double fn</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetEckertVI" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetEquirectangular">
<tt class="descname">SetEquirectangular</tt><big>(</big><em>self</em>, <em>double clat</em>, <em>double clong</em>, <em>double fe</em>, <em>double fn</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetEquirectangular" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetEquirectangular2">
<tt class="descname">SetEquirectangular2</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.NSR.SetEquirectangular2" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>SetEquirectangular2(self, double clat, double clong, double pseudostdparallellat, </dt>
<dd>double fe, double fn) -&gt; OGRErr</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetFromUserInput">
<tt class="descname">SetFromUserInput</tt><big>(</big><em>self</em>, <em>char name</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetFromUserInput" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetGEOS">
<tt class="descname">SetGEOS</tt><big>(</big><em>self</em>, <em>double cm</em>, <em>double satelliteheight</em>, <em>double fe</em>, <em>double fn</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetGEOS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetGH">
<tt class="descname">SetGH</tt><big>(</big><em>self</em>, <em>double cm</em>, <em>double fe</em>, <em>double fn</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetGH" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetGS">
<tt class="descname">SetGS</tt><big>(</big><em>self</em>, <em>double cm</em>, <em>double fe</em>, <em>double fn</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetGS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetGaussSchreiberTMercator">
<tt class="descname">SetGaussSchreiberTMercator</tt><big>(</big><em>self</em>, <em>double clat</em>, <em>double clong</em>, <em>double sc</em>, <em>double fe</em>, <em>double fn</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetGaussSchreiberTMercator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetGeocCS">
<tt class="descname">SetGeocCS</tt><big>(</big><em>self</em>, <em>char name = &quot;unnamed&quot;</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetGeocCS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetGeogCS">
<tt class="descname">SetGeogCS</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#nansat.NSR.SetGeogCS" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>SetGeogCS(self, char pszGeogName, char pszDatumName, char pszEllipsoidName, </dt>
<dd>double dfSemiMajor, double dfInvFlattening, 
char pszPMName = &#8220;Greenwich&#8221;, double dfPMOffset = 0.0, 
char pszUnits = &#8220;degree&#8221;, double dfConvertToRadians = 0.0174532925199433) -&gt; OGRErr</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetGnomonic">
<tt class="descname">SetGnomonic</tt><big>(</big><em>self</em>, <em>double clat</em>, <em>double clong</em>, <em>double fe</em>, <em>double fn</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetGnomonic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetHOM">
<tt class="descname">SetHOM</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.NSR.SetHOM" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>SetHOM(self, double clat, double clong, double azimuth, double recttoskew, </dt>
<dd>double scale, double fe, double fn) -&gt; OGRErr</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetHOM2PNO">
<tt class="descname">SetHOM2PNO</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.NSR.SetHOM2PNO" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>SetHOM2PNO(self, double clat, double dfLat1, double dfLong1, double dfLat2, </dt>
<dd>double dfLong2, double scale, double fe, 
double fn) -&gt; OGRErr</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetIGH">
<tt class="descname">SetIGH</tt><big>(</big><em>self</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetIGH" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetKrovak">
<tt class="descname">SetKrovak</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.NSR.SetKrovak" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>SetKrovak(self, double clat, double clong, double azimuth, double pseudostdparallellat, </dt>
<dd>double scale, double fe, 
double fn) -&gt; OGRErr</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetLAEA">
<tt class="descname">SetLAEA</tt><big>(</big><em>self</em>, <em>double clat</em>, <em>double clong</em>, <em>double fe</em>, <em>double fn</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetLAEA" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetLCC">
<tt class="descname">SetLCC</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.NSR.SetLCC" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>SetLCC(self, double stdp1, double stdp2, double clat, double clong, </dt>
<dd>double fe, double fn) -&gt; OGRErr</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetLCC1SP">
<tt class="descname">SetLCC1SP</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.NSR.SetLCC1SP" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>SetLCC1SP(self, double clat, double clong, double scale, double fe, </dt>
<dd>double fn) -&gt; OGRErr</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetLCCB">
<tt class="descname">SetLCCB</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.NSR.SetLCCB" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>SetLCCB(self, double stdp1, double stdp2, double clat, double clong, </dt>
<dd>double fe, double fn) -&gt; OGRErr</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetLinearUnits">
<tt class="descname">SetLinearUnits</tt><big>(</big><em>self</em>, <em>char name</em>, <em>double to_meters</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetLinearUnits" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetLinearUnitsAndUpdateParameters">
<tt class="descname">SetLinearUnitsAndUpdateParameters</tt><big>(</big><em>self</em>, <em>char name</em>, <em>double to_meters</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetLinearUnitsAndUpdateParameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetLocalCS">
<tt class="descname">SetLocalCS</tt><big>(</big><em>self</em>, <em>char pszName</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetLocalCS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetMC">
<tt class="descname">SetMC</tt><big>(</big><em>self</em>, <em>double clat</em>, <em>double clong</em>, <em>double fe</em>, <em>double fn</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetMC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetMercator">
<tt class="descname">SetMercator</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.NSR.SetMercator" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>SetMercator(self, double clat, double clong, double scale, double fe, </dt>
<dd>double fn) -&gt; OGRErr</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetMollweide">
<tt class="descname">SetMollweide</tt><big>(</big><em>self</em>, <em>double cm</em>, <em>double fe</em>, <em>double fn</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetMollweide" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetNZMG">
<tt class="descname">SetNZMG</tt><big>(</big><em>self</em>, <em>double clat</em>, <em>double clong</em>, <em>double fe</em>, <em>double fn</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetNZMG" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetNormProjParm">
<tt class="descname">SetNormProjParm</tt><big>(</big><em>self</em>, <em>char name</em>, <em>double val</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetNormProjParm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetOS">
<tt class="descname">SetOS</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.NSR.SetOS" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>SetOS(self, double dfOriginLat, double dfCMeridian, double scale, </dt>
<dd>double fe, double fn) -&gt; OGRErr</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetOrthographic">
<tt class="descname">SetOrthographic</tt><big>(</big><em>self</em>, <em>double clat</em>, <em>double clong</em>, <em>double fe</em>, <em>double fn</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetOrthographic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetPS">
<tt class="descname">SetPS</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.NSR.SetPS" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>SetPS(self, double clat, double clong, double scale, double fe, </dt>
<dd>double fn) -&gt; OGRErr</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetPolyconic">
<tt class="descname">SetPolyconic</tt><big>(</big><em>self</em>, <em>double clat</em>, <em>double clong</em>, <em>double fe</em>, <em>double fn</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetPolyconic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetProjCS">
<tt class="descname">SetProjCS</tt><big>(</big><em>self</em>, <em>char name = &quot;unnamed&quot;</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetProjCS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetProjParm">
<tt class="descname">SetProjParm</tt><big>(</big><em>self</em>, <em>char name</em>, <em>double val</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetProjParm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetProjection">
<tt class="descname">SetProjection</tt><big>(</big><em>self</em>, <em>char arg</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetProjection" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetRobinson">
<tt class="descname">SetRobinson</tt><big>(</big><em>self</em>, <em>double clong</em>, <em>double fe</em>, <em>double fn</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetRobinson" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetSOC">
<tt class="descname">SetSOC</tt><big>(</big><em>self</em>, <em>double latitudeoforigin</em>, <em>double cm</em>, <em>double fe</em>, <em>double fn</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetSOC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetSinusoidal">
<tt class="descname">SetSinusoidal</tt><big>(</big><em>self</em>, <em>double clong</em>, <em>double fe</em>, <em>double fn</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetSinusoidal" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetStatePlane">
<tt class="descname">SetStatePlane</tt><big>(</big><em>self</em>, <em>int zone</em>, <em>int is_nad83 = 1</em>, <em>char unitsname = &quot;&quot;</em>, <em>double units = 0.0</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetStatePlane" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetStereographic">
<tt class="descname">SetStereographic</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.NSR.SetStereographic" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>SetStereographic(self, double clat, double clong, double scale, double fe, </dt>
<dd>double fn) -&gt; OGRErr</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetTM">
<tt class="descname">SetTM</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.NSR.SetTM" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>SetTM(self, double clat, double clong, double scale, double fe, </dt>
<dd>double fn) -&gt; OGRErr</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetTMG">
<tt class="descname">SetTMG</tt><big>(</big><em>self</em>, <em>double clat</em>, <em>double clong</em>, <em>double fe</em>, <em>double fn</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetTMG" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetTMSO">
<tt class="descname">SetTMSO</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.NSR.SetTMSO" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>SetTMSO(self, double clat, double clong, double scale, double fe, </dt>
<dd>double fn) -&gt; OGRErr</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetTMVariant">
<tt class="descname">SetTMVariant</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.NSR.SetTMVariant" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>SetTMVariant(self, char pszVariantName, double clat, double clong, double scale, </dt>
<dd>double fe, double fn) -&gt; OGRErr</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetTOWGS84">
<tt class="descname">SetTOWGS84</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#nansat.NSR.SetTOWGS84" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>SetTOWGS84(self, double p1, double p2, double p3, double p4 = 0.0, double p5 = 0.0, </dt>
<dd>double p6 = 0.0, double p7 = 0.0) -&gt; OGRErr</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetTargetLinearUnits">
<tt class="descname">SetTargetLinearUnits</tt><big>(</big><em>self</em>, <em>char target</em>, <em>char name</em>, <em>double to_meters</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetTargetLinearUnits" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetUTM">
<tt class="descname">SetUTM</tt><big>(</big><em>self</em>, <em>int zone</em>, <em>int north = 1</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetUTM" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetVDG">
<tt class="descname">SetVDG</tt><big>(</big><em>self</em>, <em>double clong</em>, <em>double fe</em>, <em>double fn</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetVDG" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetVertCS">
<tt class="descname">SetVertCS</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#nansat.NSR.SetVertCS" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>SetVertCS(self, char VertCSName = &#8220;unnamed&#8221;, char VertDatumName = &#8220;unnamed&#8221;, </dt>
<dd>int VertDatumType = 0) -&gt; OGRErr</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nansat.NSR.SetWellKnownGeogCS">
<tt class="descname">SetWellKnownGeogCS</tt><big>(</big><em>self</em>, <em>char name</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.SetWellKnownGeogCS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.StripCTParms">
<tt class="descname">StripCTParms</tt><big>(</big><em>self</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.StripCTParms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.NSR.Validate">
<tt class="descname">Validate</tt><big>(</big><em>self</em><big>)</big> &rarr; OGRErr<a class="headerlink" href="#nansat.NSR.Validate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nansat.Domain">
<em class="property">class </em><tt class="descclassname">nansat.</tt><tt class="descname">Domain</tt><big>(</big><em>srs=None</em>, <em>ext=None</em>, <em>ds=None</em>, <em>lon=None</em>, <em>lat=None</em>, <em>name=''</em>, <em>logLevel=None</em><big>)</big><a class="headerlink" href="#nansat.Domain" title="Permalink to this definition">¶</a></dt>
<dd><p>Create Domain from GDALDataset or string options or lat/lon grids</p>
<p>Size, extent and spatial reference is given by strings :</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">Domain</span><span class="p">(</span><span class="n">srs</span><span class="p">,</span> <span class="n">ext</span><span class="p">)</span>
</pre></div>
</div>
<p>Size, extent and spatial reference is copied from input GDAL dataset :</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">Domain</span><span class="p">(</span><span class="n">ds</span><span class="o">=</span><span class="n">GDALDataset</span><span class="p">)</span>
</pre></div>
</div>
<p>Spatial reference is given by srs, but size and extent is
determined from input GDAL dataset :</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">Domain</span><span class="p">(</span><span class="n">srs</span><span class="p">,</span> <span class="n">ds</span><span class="o">=</span><span class="n">GDALDataset</span><span class="p">)</span>
</pre></div>
</div>
<p>Size, extent and spatial reference is given by two grids :</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">Domain</span><span class="p">(</span><span class="n">lon</span><span class="o">=</span><span class="n">lonGrid</span><span class="p">,</span> <span class="n">lat</span><span class="o">=</span><span class="n">latGrid</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>srs</strong> : PROJ4 or EPSG or WKT or NSR or osr.SpatialReference()</p>
<blockquote>
<div><p>Input parameter for nansat.NSR()</p>
</div></blockquote>
<p><strong>ext</strong> : string</p>
<blockquote>
<div><p>some gdalwarp options + additional options
[<a class="reference external" href="http://www.gdal.org/gdalwarp.html">http://www.gdal.org/gdalwarp.html</a>]
Specifies extent, resolution / size
Available options: ((&#8216;-te&#8217; or &#8216;-lle&#8217;) and (&#8216;-tr&#8217; or &#8216;-ts&#8217;))
(e.g. &#8216;-lle -10 30 55 60 -ts 1000 1000&#8217; or
&#8216;-te 100 2000 300 10000 -tr 300 200&#8217;)
-tr resolutionx resolutiony
-ts sizex sizey
-te xmin ymin xmax ymax
-lle lonmin latmin lonmax latmax</p>
</div></blockquote>
<p><strong>ds</strong> : GDAL dataset</p>
<p><strong>lat</strong> : Numpy array</p>
<blockquote>
<div><p>Grid with latitudes</p>
</div></blockquote>
<p><strong>lon</strong> : Numpy array</p>
<blockquote>
<div><p>Grid with longitudes</p>
</div></blockquote>
<p><strong>name</strong> : string, optional</p>
<blockquote>
<div><p>Name to be added to the Domain object</p>
</div></blockquote>
<p><strong>logLevel</strong> : int, optional, default=30</p>
<blockquote>
<div><p>level of logging</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.vrt.datasetset</strong> : dataset in memory</p>
<blockquote>
<div><p>dataset is created based on the input arguments</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ProjectionError</strong> : occurs when Projection() is empty</p>
<blockquote>
<div><p>despite it is required for creating extentDic.</p>
</div></blockquote>
<p class="last"><strong>OptionError</strong> : occures when the arguments are not proper.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<dl class="docutils">
<dt>see also:</dt>
<dd><div class="first last line-block">
<div class="line">Nansat.reproject()</div>
<div class="line"><a class="reference external" href="http://www.gdal.org/gdalwarp.html">http://www.gdal.org/gdalwarp.html</a></div>
<div class="line"><a class="reference external" href="http://trac.osgeo.org/proj">http://trac.osgeo.org/proj</a></div>
<div class="line"><a class="reference external" href="http://spatialreference.org">http://spatialreference.org</a></div>
<div class="line"><a class="reference external" href="http://www.gdal.org/ogr/osr_tutorial.html">http://www.gdal.org/ogr/osr_tutorial.html</a></div>
</div>
</dd>
</dl>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Domain.azimuth_y" title="nansat.Domain.azimuth_y"><tt class="xref py py-obj docutils literal"><span class="pre">azimuth_y</span></tt></a>([reductionFactor])</td>
<td>Calculate the azimuth of &#8216;upward&#8217; direction in each pixel</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Domain.get_border" title="nansat.Domain.get_border"><tt class="xref py py-obj docutils literal"><span class="pre">get_border</span></tt></a>([nPoints])</td>
<td>Generate two vectors with values of lat/lon for the border of domain</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Domain.get_border_geometry" title="nansat.Domain.get_border_geometry"><tt class="xref py py-obj docutils literal"><span class="pre">get_border_geometry</span></tt></a>()</td>
<td>Get OGR Geometry of the border Polygon</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Domain.get_border_postgis" title="nansat.Domain.get_border_postgis"><tt class="xref py py-obj docutils literal"><span class="pre">get_border_postgis</span></tt></a>()</td>
<td>Get PostGIS formatted string of the border Polygon</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Domain.get_border_wkt" title="nansat.Domain.get_border_wkt"><tt class="xref py py-obj docutils literal"><span class="pre">get_border_wkt</span></tt></a>()</td>
<td>Creates string with WKT representation of the border polygon</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Domain.get_corners" title="nansat.Domain.get_corners"><tt class="xref py py-obj docutils literal"><span class="pre">get_corners</span></tt></a>()</td>
<td>Get coordinates of corners of the Domain</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Domain.get_geolocation_grids" title="nansat.Domain.get_geolocation_grids"><tt class="xref py py-obj docutils literal"><span class="pre">get_geolocation_grids</span></tt></a>([stepSize])</td>
<td>Get longitude and latitude grids representing the full data grid</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Domain.get_pixelsize_meters" title="nansat.Domain.get_pixelsize_meters"><tt class="xref py py-obj docutils literal"><span class="pre">get_pixelsize_meters</span></tt></a>()</td>
<td>Returns the pixelsize (deltaX, deltaY) of the domain</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Domain.reproject_GCPs" title="nansat.Domain.reproject_GCPs"><tt class="xref py py-obj docutils literal"><span class="pre">reproject_GCPs</span></tt></a>(srsString)</td>
<td>Reproject all GCPs to a new spatial reference system</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Domain.shape" title="nansat.Domain.shape"><tt class="xref py py-obj docutils literal"><span class="pre">shape</span></tt></a>()</td>
<td>Return Numpy-like shape of Domain object (ySize, xSize)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Domain.transform_points" title="nansat.Domain.transform_points"><tt class="xref py py-obj docutils literal"><span class="pre">transform_points</span></tt></a>(colVector,&nbsp;rowVector[,&nbsp;...])</td>
<td>Transform given lists of X,Y coordinates into lon/lat or inverse</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Domain.write_kml" title="nansat.Domain.write_kml"><tt class="xref py py-obj docutils literal"><span class="pre">write_kml</span></tt></a>([xmlFileName,&nbsp;kmlFileName])</td>
<td>Write KML file with domains</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Domain.write_kml_image" title="nansat.Domain.write_kml_image"><tt class="xref py py-obj docutils literal"><span class="pre">write_kml_image</span></tt></a>([kmlFileName,&nbsp;kmlFigureName])</td>
<td>Create KML file for already projected image</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Domain.write_map" title="nansat.Domain.write_map"><tt class="xref py py-obj docutils literal"><span class="pre">write_map</span></tt></a>(outputFileName[,&nbsp;lonVec,&nbsp;latVec,&nbsp;...])</td>
<td>Create an image with a map of the domain</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nansat.Domain.azimuth_y">
<tt class="descname">azimuth_y</tt><big>(</big><em>reductionFactor=1</em><big>)</big><a class="headerlink" href="#nansat.Domain.azimuth_y" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the azimuth of &#8216;upward&#8217; direction in each pixel</p>
<p>Generaly speaking, azimuth is angle from the reference vector
(direction to North) to the chosen direction. Azimuth increases
clockwise from direction to North. <a class="reference external" href="http://en.wikipedia.org/wiki/Azimuth">http://en.wikipedia.org/wiki/Azimuth</a></p>
<p>Here we calcluate azimuth of &#8216;upward&#8217; direction.
&#8216;Upward&#8217; direction coincides with Y-axis direction (and hence is
opposite to the ROW-axis direction). For lon-lat (cylindrical,
Plate Caree) and Mercator projections &#8216;upward&#8217; direction coincides with
direction to North, hence azimuth is 0.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reductionFactor</strong> : integer</p>
<blockquote>
<div><p>factor by which the size of the output array is reduced</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>azimuth</strong> : numpy array</p>
<blockquote class="last">
<div><p>Values of azimuth in degrees in range 0 - 360</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.get_border">
<tt class="descname">get_border</tt><big>(</big><em>nPoints=10</em><big>)</big><a class="headerlink" href="#nansat.Domain.get_border" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate two vectors with values of lat/lon for the border of domain</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>nPoints</strong> : int, optional</p>
<blockquote>
<div><p>Number of points on each border</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>lonVec, latVec</strong> : lists</p>
<blockquote class="last">
<div><p>vectors with lon/lat values for each point at the border</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.get_border_geometry">
<tt class="descname">get_border_geometry</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Domain.get_border_geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Get OGR Geometry of the border Polygon</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>OGR Geometry</strong> : OGR Geometry (type Polygon)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.get_border_postgis">
<tt class="descname">get_border_postgis</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Domain.get_border_postgis" title="Permalink to this definition">¶</a></dt>
<dd><p>Get PostGIS formatted string of the border Polygon</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>str</strong> : PolygonFromText (PolygonWKT)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.get_border_wkt">
<tt class="descname">get_border_wkt</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Domain.get_border_wkt" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates string with WKT representation of the border polygon</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>WKTPolygon</strong> : string</p>
<blockquote class="last">
<div><p>string with WKT representation of the border polygon</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.get_corners">
<tt class="descname">get_corners</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Domain.get_corners" title="Permalink to this definition">¶</a></dt>
<dd><p>Get coordinates of corners of the Domain</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>lonVec, latVec</strong> : lists</p>
<blockquote class="last">
<div><p>vectors with lon/lat values for each corner</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.get_geolocation_grids">
<tt class="descname">get_geolocation_grids</tt><big>(</big><em>stepSize=1</em><big>)</big><a class="headerlink" href="#nansat.Domain.get_geolocation_grids" title="Permalink to this definition">¶</a></dt>
<dd><p>Get longitude and latitude grids representing the full data grid</p>
<div class="line-block">
<div class="line">If GEOLOCATION is not present in the self.vrt.dataset then grids
are generated by converting pixel/line of each pixel into lat/lon</div>
<div class="line">If GEOLOCATION is present in the self.vrt.dataset then grids are read
from the geolocation bands.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>stepSize</strong> : int</p>
<blockquote>
<div><p>Reduction factor if output is desired on a reduced grid size</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>longitude</strong> : numpy array</p>
<blockquote>
<div><p>grid with longitudes</p>
</div></blockquote>
<p><strong>latitude</strong> : numpy array</p>
<blockquote class="last">
<div><p>grid with latitudes</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.get_pixelsize_meters">
<tt class="descname">get_pixelsize_meters</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Domain.get_pixelsize_meters" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pixelsize (deltaX, deltaY) of the domain</p>
<div class="line-block">
<div class="line">For projected domains, the exact result which is constant
over the domain is returned.</div>
<div class="line">For geographic (lon-lat) projections, or domains with no geotransform,
the haversine formula is used to calculate the pixel size
in the center of the domain.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>deltaX, deltaY</strong> : float</p>
<blockquote class="last">
<div><p>pixel size in X and Y directions given in meters</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.reproject_GCPs">
<tt class="descname">reproject_GCPs</tt><big>(</big><em>srsString</em><big>)</big><a class="headerlink" href="#nansat.Domain.reproject_GCPs" title="Permalink to this definition">¶</a></dt>
<dd><p>Reproject all GCPs to a new spatial reference system</p>
<p>Necessary before warping an image if the given GCPs
are in a coordinate system which has a singularity
in (or near) the destination area (e.g. poles for lonlat GCPs)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>srsString</strong> : string</p>
<blockquote>
<div><p>SRS given as Proj4 string</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.vrt</strong> : Reprojects all GCPs to new SRS and updates GCPProjection</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.shape">
<tt class="descname">shape</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Domain.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Numpy-like shape of Domain object (ySize, xSize)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>shape</strong> : tuple of two INT</p>
<blockquote class="last">
<div><p>Numpy-like shape of Domain object (ySize, xSize)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.transform_points">
<tt class="descname">transform_points</tt><big>(</big><em>colVector</em>, <em>rowVector</em>, <em>DstToSrc=0</em><big>)</big><a class="headerlink" href="#nansat.Domain.transform_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform given lists of X,Y coordinates into lon/lat or inverse</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>colVector</strong> : lists</p>
<blockquote>
<div><p>X and Y coordinates in pixel/line or lon/lat  coordinate system</p>
</div></blockquote>
<p><strong>DstToSrc</strong> : 0 or 1</p>
<blockquote>
<div><p>0 - forward transform (pix/line =&gt; lon/lat)
1 - inverse transformation</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>X, Y</strong> : lists</p>
<blockquote class="last">
<div><p>X and Y coordinates in lon/lat or pixel/line coordinate system</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.write_kml">
<tt class="descname">write_kml</tt><big>(</big><em>xmlFileName=None</em>, <em>kmlFileName=None</em><big>)</big><a class="headerlink" href="#nansat.Domain.write_kml" title="Permalink to this definition">¶</a></dt>
<dd><p>Write KML file with domains</p>
<p>Convert XML-file with domains into KML-file for GoogleEarth
or write KML-file with the current Domain</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xmlFileName</strong> : string, optional</p>
<blockquote>
<div><p>Name of the XML-file to convert. If only this value is given
- kmlFileName=xmlFileName+&#8217;.kml&#8217;</p>
</div></blockquote>
<p><strong>kmlFileName</strong> : string, optional</p>
<blockquote class="last">
<div><p>Name of the KML-file to generate from the current Domain</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.write_kml_image">
<tt class="descname">write_kml_image</tt><big>(</big><em>kmlFileName=None</em>, <em>kmlFigureName=None</em><big>)</big><a class="headerlink" href="#nansat.Domain.write_kml_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Create KML file for already projected image</p>
<p>Write Domain Image into KML-file for GoogleEarth</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>kmlFileName</strong> : string, optional</p>
<blockquote>
<div><p>Name of the KML-file to generate from the current Domain</p>
</div></blockquote>
<p><strong>kmlFigureName</strong> : string, optional</p>
<blockquote class="last">
<div><p>Name of the projected image stored in .png format</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="line-block">
<div class="line">First of all, reproject an image into Lat/Lon WGS84
(Simple Cylindrical) projection</div>
<div class="line">1. Cancel previous reprojection</div>
<div class="line">2. Get corners of the image and the pixel resolution</div>
<div class="line">3. Create Domain with stereographic projection,
corner coordinates and resolution 1000m</div>
<div class="line">4. Reproject</div>
<div class="line">5. Write image</div>
<div class="line">6. Write KML for the image</div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">reproject</span><span class="p">()</span>  <span class="c"># 1.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">get_corners</span><span class="p">()</span>  <span class="c"># 2.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">srsString</span> <span class="o">=</span> <span class="s">&#39;+proj=latlong +datum=WGS84 +ellps=WGS84 +no_defs&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">extentString</span> <span class="o">=</span> <span class="s">&#39;-lle </span><span class="si">%f</span><span class="s"> </span><span class="si">%f</span><span class="s"> </span><span class="si">%f</span><span class="s"> </span><span class="si">%f</span><span class="s"> -ts 3000 3000&#39;</span>
<span class="gp">&gt;&gt;&gt; </span>                <span class="o">%</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">lons</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">lats</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">lons</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">lats</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">Domain</span><span class="p">(</span><span class="n">srs</span><span class="o">=</span><span class="n">srsString</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">extentString</span><span class="p">)</span>  <span class="c"># 3.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">reproject</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>  <span class="c"># 4.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">write_figure</span><span class="p">(</span><span class="n">fileName</span><span class="o">=</span><span class="n">figureName</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">clim</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.15</span><span class="p">],</span>
<span class="gp">&gt;&gt;&gt; </span>               <span class="n">cmapName</span><span class="o">=</span><span class="s">&#39;gray&#39;</span><span class="p">,</span> <span class="n">transparency</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c"># 5.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">write_kml_image</span><span class="p">(</span><span class="n">kmlFileName</span><span class="o">=</span><span class="n">oPath</span> <span class="o">+</span> <span class="n">fileName</span> <span class="o">+</span> <span class="s">&#39;.kml&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">kmlFigureName</span><span class="o">=</span><span class="n">figureName</span><span class="p">)</span>  <span class="c"># 6.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.write_map">
<tt class="descname">write_map</tt><big>(</big><em>outputFileName, lonVec=None, latVec=None, lonBorder=10.0, latBorder=10.0, figureSize=(6, 6), dpi=50, projection='cyl', resolution='c', continetsColor='coral', meridians=10, parallels=10, pColor='r', pLine='k', pAlpha=0.5, padding=0.0, merLabels=[False, False, False, False], parLabels=[False, False, False, False], pltshow=False</em><big>)</big><a class="headerlink" href="#nansat.Domain.write_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an image with a map of the domain</p>
<div class="line-block">
<div class="line">Uses Basemap to create a World Map</div>
<div class="line">Adds a semitransparent patch with outline of the Domain</div>
<div class="line">Writes to an image file</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>outputFileName</strong> : string</p>
<blockquote>
<div><p>name of the output file name</p>
</div></blockquote>
<p><strong>lonBorder</strong> : float</p>
<blockquote>
<div><p>10, horisontal border around patch (degrees of longitude)</p>
</div></blockquote>
<p><strong>latBorder</strong> : float</p>
<blockquote>
<div><p>10, vertical border around patch (degrees of latitude)</p>
</div></blockquote>
<p><strong>figureSize</strong> : tuple of two integers</p>
<blockquote>
<div><p>(6, 6), size of the generated figure in inches</p>
</div></blockquote>
<p><strong>dpi: int</strong></p>
<blockquote>
<div><p>50, resolution of the output figure (size 6,6 and dpi 50
produces 300 x 300 figure)</p>
</div></blockquote>
<p><strong>projection</strong> : string, one of Basemap projections</p>
<blockquote>
<div><p>&#8216;cyl&#8217;, projection of the map</p>
</div></blockquote>
<p><strong>resolution</strong> : string, resolution of the map</p>
<blockquote>
<div><div class="line-block">
<div class="line">&#8216;c&#8217;, crude</div>
<div class="line">&#8216;l&#8217;, low</div>
<div class="line">&#8216;i&#8217;, intermediate</div>
<div class="line">&#8216;h&#8217;, high</div>
<div class="line">&#8216;f&#8217;, full</div>
</div>
</div></blockquote>
<p><strong>continetsColor</strong> : string or any matplotlib color representation</p>
<blockquote>
<div><p>&#8216;coral&#8217;, color of continets</p>
</div></blockquote>
<p><strong>meridians</strong> : int</p>
<blockquote>
<div><p>10, number of meridians to draw</p>
</div></blockquote>
<p><strong>parallels</strong> : int</p>
<blockquote>
<div><p>10, number of parallels to draw</p>
</div></blockquote>
<p><strong>pColor</strong> : string or any matplotlib color representation</p>
<blockquote>
<div><p>&#8216;r&#8217;, color of the Domain patch</p>
</div></blockquote>
<p><strong>pLine</strong> : string or any matplotlib color representation</p>
<blockquote>
<div><p>&#8216;k&#8217;, color of the Domain outline</p>
</div></blockquote>
<p><strong>pAlpha</strong> : float 0 - 1</p>
<blockquote>
<div><p>0.5, transparency of Domain patch</p>
</div></blockquote>
<p><strong>padding</strong> : float</p>
<blockquote>
<div><p>0., width of white padding around the map</p>
</div></blockquote>
<p><strong>merLabels</strong> : list of 4 booleans</p>
<blockquote>
<div><p>where to put meridian labels, see also Basemap.drawmeridians()</p>
</div></blockquote>
<p><strong>parLables</strong> : list of 4 booleans</p>
<blockquote class="last">
<div><p>where to put parallel labels, see also Basemap.drawparallels()</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nansat.Nansat">
<em class="property">class </em><tt class="descclassname">nansat.</tt><tt class="descname">Nansat</tt><big>(</big><em>fileName=''</em>, <em>mapperName=''</em>, <em>domain=None</em>, <em>array=None</em>, <em>parameters=None</em>, <em>logLevel=30</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansat" title="Permalink to this definition">¶</a></dt>
<dd><p>Create Nansat object</p>
<dl class="docutils">
<dt>if &lt;fileName&gt; is given:</dt>
<dd>Open GDAL dataset,
Read metadata,
Generate GDAL VRT file with mapping of variables in memory
Create logger
Create Nansat object for perfroming high-level operations</dd>
<dt>if &lt;domain&gt; and &lt;array&gt; are given:</dt>
<dd>Create VRT object from data in &lt;array&gt;
Add geolocation from &lt;domain&gt;</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : string</p>
<blockquote>
<div><p>location of the file</p>
</div></blockquote>
<p><strong>mapperName</strong> : string, optional</p>
<blockquote>
<div><p>name of the mapper from nansat/mappers dir. E.g.
&#8216;ASAR&#8217;, &#8216;hirlam&#8217;, &#8216;merisL1&#8217;, &#8216;merisL2&#8217;, etc.</p>
</div></blockquote>
<p><strong>domain</strong> : Domain object</p>
<blockquote>
<div><p>Geo-reference of a new raster</p>
</div></blockquote>
<p><strong>array</strong> : numpy array</p>
<blockquote>
<div><p>Firts band of a new raster</p>
</div></blockquote>
<p><strong>parameters</strong> : dictionary</p>
<blockquote>
<div><p>Metadata for the 1st band of a new raster,e.g. name, wkv, units,...</p>
</div></blockquote>
<p><strong>logLevel</strong> : int, optional, default: logging.DEBUG (30)</p>
<blockquote>
<div><p>Level of logging. See: <a class="reference external" href="http://docs.python.org/howto/logging.html">http://docs.python.org/howto/logging.html</a></p>
</div></blockquote>
<p><strong>kwargs</strong> : additional arguments for mappers</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Creates:</th><td class="field-body"><p class="first"><strong>self.mapper</strong> : str</p>
<blockquote>
<div><p>name of the used mapper</p>
</div></blockquote>
<p><strong>self.fileName</strong> : file name</p>
<blockquote>
<div><p>set file name given by the argument</p>
</div></blockquote>
<p><strong>self.vrt</strong> : VRT object</p>
<blockquote>
<div><p>Wrapper around VRT file and GDAL dataset with satellite raster data</p>
</div></blockquote>
<p><strong>self.logger</strong> : logging.Logger</p>
<blockquote>
<div><p>logger for output debugging info</p>
</div></blockquote>
<p><strong>self.name</strong> : string</p>
<blockquote class="last">
<div><p>name of object (for writing KML)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>opens file for reading. Opening is lazy - no data is read at this
point, only metadata that describes the dataset and bands</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">Nansat</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
</pre></div>
</div>
<p>create an empty Nansat object. &lt;d&gt; is the Domain object which
describes the grid (projection, resolution and extent)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">Nansat</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
<p>create a Nansat object in memory with one band from input array &lt;a&gt;.
&lt;p&gt; is a dictionary with metadata for the band</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">Nansat</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">d</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">parameters</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
<p>fetch data from Nansat object from the first band</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>fetch data from the band which has name &#8216;band_name&#8217;</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="s">&#39;band_name&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansat.add_band" title="nansat.Nansat.add_band"><tt class="xref py py-obj docutils literal"><span class="pre">add_band</span></tt></a>(array[,&nbsp;parameters,&nbsp;nomem])</td>
<td>Add band from the array to self.vrt</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansat.add_bands" title="nansat.Nansat.add_bands"><tt class="xref py py-obj docutils literal"><span class="pre">add_bands</span></tt></a>(arrays[,&nbsp;parameters,&nbsp;nomem])</td>
<td>Add band from the array to self.vrt</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansat.azimuth_y" title="nansat.Nansat.azimuth_y"><tt class="xref py py-obj docutils literal"><span class="pre">azimuth_y</span></tt></a>([reductionFactor])</td>
<td>Calculate the azimuth of &#8216;upward&#8217; direction in each pixel</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansat.bands" title="nansat.Nansat.bands"><tt class="xref py py-obj docutils literal"><span class="pre">bands</span></tt></a>()</td>
<td>Make a dictionary with all metadata from all bands</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansat.crop" title="nansat.Nansat.crop"><tt class="xref py py-obj docutils literal"><span class="pre">crop</span></tt></a>([xOff,&nbsp;yOff,&nbsp;xSize,&nbsp;ySize,&nbsp;lonlim,&nbsp;latlim])</td>
<td>Crop Nansat object</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansat.export" title="nansat.Nansat.export"><tt class="xref py py-obj docutils literal"><span class="pre">export</span></tt></a>(fileName[,&nbsp;bands,&nbsp;rmMetadata,&nbsp;...])</td>
<td>Export Nansat object into netCDF or GTiff file</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansat.export2thredds" title="nansat.Nansat.export2thredds"><tt class="xref py py-obj docutils literal"><span class="pre">export2thredds</span></tt></a>(fileName[,&nbsp;bands,&nbsp;metadata,&nbsp;...])</td>
<td>Export data into a netCDF formatted for THREDDS server</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansat.get_GDALRasterBand" title="nansat.Nansat.get_GDALRasterBand"><tt class="xref py py-obj docutils literal"><span class="pre">get_GDALRasterBand</span></tt></a>([bandID])</td>
<td>Get a GDALRasterBand of a given Nansat object</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansat.get_border" title="nansat.Nansat.get_border"><tt class="xref py py-obj docutils literal"><span class="pre">get_border</span></tt></a>([nPoints])</td>
<td>Generate two vectors with values of lat/lon for the border of domain</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansat.get_border_geometry" title="nansat.Nansat.get_border_geometry"><tt class="xref py py-obj docutils literal"><span class="pre">get_border_geometry</span></tt></a>()</td>
<td>Get OGR Geometry of the border Polygon</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansat.get_border_postgis" title="nansat.Nansat.get_border_postgis"><tt class="xref py py-obj docutils literal"><span class="pre">get_border_postgis</span></tt></a>()</td>
<td>Get PostGIS formatted string of the border Polygon</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansat.get_border_wkt" title="nansat.Nansat.get_border_wkt"><tt class="xref py py-obj docutils literal"><span class="pre">get_border_wkt</span></tt></a>()</td>
<td>Creates string with WKT representation of the border polygon</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansat.get_corners" title="nansat.Nansat.get_corners"><tt class="xref py py-obj docutils literal"><span class="pre">get_corners</span></tt></a>()</td>
<td>Get coordinates of corners of the Domain</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansat.get_geolocation_grids" title="nansat.Nansat.get_geolocation_grids"><tt class="xref py py-obj docutils literal"><span class="pre">get_geolocation_grids</span></tt></a>([stepSize])</td>
<td>Get longitude and latitude grids representing the full data grid</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansat.get_metadata" title="nansat.Nansat.get_metadata"><tt class="xref py py-obj docutils literal"><span class="pre">get_metadata</span></tt></a>([key,&nbsp;bandID])</td>
<td>Get metadata from self.vrt.dataset</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansat.get_pixelsize_meters" title="nansat.Nansat.get_pixelsize_meters"><tt class="xref py py-obj docutils literal"><span class="pre">get_pixelsize_meters</span></tt></a>()</td>
<td>Returns the pixelsize (deltaX, deltaY) of the domain</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansat.get_time" title="nansat.Nansat.get_time"><tt class="xref py py-obj docutils literal"><span class="pre">get_time</span></tt></a>([bandID])</td>
<td>Get time for dataset and/or its bands</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansat.get_transect" title="nansat.Nansat.get_transect"><tt class="xref py py-obj docutils literal"><span class="pre">get_transect</span></tt></a>([points,&nbsp;bandList,&nbsp;latlon,&nbsp;...])</td>
<td>Get transect from two poins and retun the values by numpy array</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansat.has_band" title="nansat.Nansat.has_band"><tt class="xref py py-obj docutils literal"><span class="pre">has_band</span></tt></a>(band)</td>
<td>Check if self has band with name &lt;band&gt;</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansat.list_bands" title="nansat.Nansat.list_bands"><tt class="xref py py-obj docutils literal"><span class="pre">list_bands</span></tt></a>([doPrint])</td>
<td>Show band information of the given Nansat object</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansat.reproject" title="nansat.Nansat.reproject"><tt class="xref py py-obj docutils literal"><span class="pre">reproject</span></tt></a>([dstDomain,&nbsp;eResampleAlg,&nbsp;...])</td>
<td>Change projection of the object based on the given Domain</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansat.reproject_GCPs" title="nansat.Nansat.reproject_GCPs"><tt class="xref py py-obj docutils literal"><span class="pre">reproject_GCPs</span></tt></a>(srsString)</td>
<td>Reproject all GCPs to a new spatial reference system</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansat.resize" title="nansat.Nansat.resize"><tt class="xref py py-obj docutils literal"><span class="pre">resize</span></tt></a>([factor,&nbsp;width,&nbsp;height,&nbsp;pixelsize,&nbsp;...])</td>
<td>Proportional resize of the dataset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansat.set_metadata" title="nansat.Nansat.set_metadata"><tt class="xref py py-obj docutils literal"><span class="pre">set_metadata</span></tt></a>([key,&nbsp;value,&nbsp;bandID])</td>
<td>Set metadata to self.vrt.dataset</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansat.shape" title="nansat.Nansat.shape"><tt class="xref py py-obj docutils literal"><span class="pre">shape</span></tt></a>()</td>
<td>Return Numpy-like shape of Domain object (ySize, xSize)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansat.transform_points" title="nansat.Nansat.transform_points"><tt class="xref py py-obj docutils literal"><span class="pre">transform_points</span></tt></a>(colVector,&nbsp;rowVector[,&nbsp;...])</td>
<td>Transform given lists of X,Y coordinates into lon/lat or inverse</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansat.undo" title="nansat.Nansat.undo"><tt class="xref py py-obj docutils literal"><span class="pre">undo</span></tt></a>([steps])</td>
<td>Undo reproject, resize, add_band or crop of Nansat object</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansat.watermask" title="nansat.Nansat.watermask"><tt class="xref py py-obj docutils literal"><span class="pre">watermask</span></tt></a>([mod44path,&nbsp;dstDomain])</td>
<td>Create numpy array with watermask (water=1, land=0)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansat.write_figure" title="nansat.Nansat.write_figure"><tt class="xref py py-obj docutils literal"><span class="pre">write_figure</span></tt></a>([fileName,&nbsp;bands,&nbsp;clim,&nbsp;addDate])</td>
<td>Save a raster band to a figure in graphical format.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansat.write_geotiffimage" title="nansat.Nansat.write_geotiffimage"><tt class="xref py py-obj docutils literal"><span class="pre">write_geotiffimage</span></tt></a>(fileName[,&nbsp;bandID])</td>
<td>Writes an 8-bit GeoTiff image for a given band.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansat.write_kml" title="nansat.Nansat.write_kml"><tt class="xref py py-obj docutils literal"><span class="pre">write_kml</span></tt></a>([xmlFileName,&nbsp;kmlFileName])</td>
<td>Write KML file with domains</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansat.write_kml_image" title="nansat.Nansat.write_kml_image"><tt class="xref py py-obj docutils literal"><span class="pre">write_kml_image</span></tt></a>([kmlFileName,&nbsp;kmlFigureName])</td>
<td>Create KML file for already projected image</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansat.write_map" title="nansat.Nansat.write_map"><tt class="xref py py-obj docutils literal"><span class="pre">write_map</span></tt></a>(outputFileName[,&nbsp;lonVec,&nbsp;latVec,&nbsp;...])</td>
<td>Create an image with a map of the domain</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nansat.Nansat.add_band">
<tt class="descname">add_band</tt><big>(</big><em>array</em>, <em>parameters=None</em>, <em>nomem=False</em><big>)</big><a class="headerlink" href="#nansat.Nansat.add_band" title="Permalink to this definition">¶</a></dt>
<dd><p>Add band from the array to self.vrt</p>
<p>Create VRT object which contains VRT and RAW binary file and append it
to self.vrt.subVRTs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>array</strong> : ndarray</p>
<blockquote>
<div><p>band data</p>
</div></blockquote>
<p><strong>parameters</strong> : dictionary</p>
<blockquote>
<div><p>band metadata: wkv, name, etc. (or for several bands)</p>
</div></blockquote>
<p><strong>nomem</strong> : boolean, saves the vrt to a tempfile if nomem is True</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>Creates VRT object with VRT-file and RAW-file</strong></p>
<blockquote class="last">
<div><p>Adds band to the self.vrt</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>add new band from numpy array &lt;a&gt; with metadata &lt;p&gt; in memory
Shape of a should be equal to the shape of &lt;n&gt;</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_band</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
<p>add new band from an array &lt;a&gt; with metadata &lt;p&gt; but keep it
temporarli on disk intead of memory</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_band</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">nomem</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.add_bands">
<tt class="descname">add_bands</tt><big>(</big><em>arrays</em>, <em>parameters=None</em>, <em>nomem=False</em><big>)</big><a class="headerlink" href="#nansat.Nansat.add_bands" title="Permalink to this definition">¶</a></dt>
<dd><p>Add band from the array to self.vrt</p>
<p>Create VRT object which contains VRT and RAW binary file and append it
to self.vrt.subVRTs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>array</strong> : ndarray or list</p>
<blockquote>
<div><p>band data (or data for several bands)</p>
</div></blockquote>
<p><strong>parameters</strong> : dictionary or list</p>
<blockquote>
<div><p>band metadata: wkv, name, etc. (or for several bands)</p>
</div></blockquote>
<p><strong>nomem</strong> : boolean, saves the vrt to a tempfile if nomem is True</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>Creates VRT object with VRT-file and RAW-file</strong></p>
<blockquote class="last">
<div><p>Adds band to the self.vrt</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>add two new bands from numpy arrays &lt;a1&gt; and &lt;a2&gt; with metadata in
&#8216;p1&#8217; and &#8216;p2&#8217;</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_bands</span><span class="p">([</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">],</span> <span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.azimuth_y">
<tt class="descname">azimuth_y</tt><big>(</big><em>reductionFactor=1</em><big>)</big><a class="headerlink" href="#nansat.Nansat.azimuth_y" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the azimuth of &#8216;upward&#8217; direction in each pixel</p>
<p>Generaly speaking, azimuth is angle from the reference vector
(direction to North) to the chosen direction. Azimuth increases
clockwise from direction to North. <a class="reference external" href="http://en.wikipedia.org/wiki/Azimuth">http://en.wikipedia.org/wiki/Azimuth</a></p>
<p>Here we calcluate azimuth of &#8216;upward&#8217; direction.
&#8216;Upward&#8217; direction coincides with Y-axis direction (and hence is
opposite to the ROW-axis direction). For lon-lat (cylindrical,
Plate Caree) and Mercator projections &#8216;upward&#8217; direction coincides with
direction to North, hence azimuth is 0.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reductionFactor</strong> : integer</p>
<blockquote>
<div><p>factor by which the size of the output array is reduced</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>azimuth</strong> : numpy array</p>
<blockquote class="last">
<div><p>Values of azimuth in degrees in range 0 - 360</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.bands">
<tt class="descname">bands</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Nansat.bands" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a dictionary with all metadata from all bands</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>b</strong> : dictionary</p>
<blockquote class="last">
<div><p>key = N, value = dict with all band metadata</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.crop">
<tt class="descname">crop</tt><big>(</big><em>xOff=0</em>, <em>yOff=0</em>, <em>xSize=None</em>, <em>ySize=None</em>, <em>lonlim=None</em>, <em>latlim=None</em><big>)</big><a class="headerlink" href="#nansat.Nansat.crop" title="Permalink to this definition">¶</a></dt>
<dd><p>Crop Nansat object</p>
<p>Create superVRT, modify the Source Rectangle (SrcRect) and Destination
Rectangle (DstRect) tags in the VRT file for each band in order
to take only part of the original image,
create new GCPs or new GeoTransform for the cropped object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xOff</strong> : int</p>
<blockquote>
<div><p>pixel offset of subimage</p>
</div></blockquote>
<p><strong>yOff</strong> : int</p>
<blockquote>
<div><p>line offset of subimage</p>
</div></blockquote>
<p><strong>xSize</strong> : int</p>
<blockquote>
<div><p>width in pixels of subimage</p>
</div></blockquote>
<p><strong>ySize</strong> : int</p>
<blockquote>
<div><p>height in pizels of subimage</p>
</div></blockquote>
<p><strong>lonlim</strong> : [float, float]</p>
<blockquote>
<div><p>longitdal limits</p>
</div></blockquote>
<p><strong>latlim</strong> : [float, float]</p>
<blockquote>
<div><p>latitudal limits</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.vrt</strong> : VRT</p>
<blockquote>
<div><p>superVRT is created with modified SrcRect and DstRect</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>status</strong> : int</p>
<blockquote>
<div><div class="line-block">
<div class="line">0 - everyhting is OK, image is cropped</div>
<div class="line">1 - if crop is totally outside, image is NOT cropped</div>
<div class="line">2 - crop area is too large and crop is not needed</div>
</div>
</div></blockquote>
<p><strong>extent</strong> : (xOff, yOff, xSize, ySize)</p>
<blockquote class="last">
<div><div class="line-block">
<div class="line">xOff  - X offset in the original dataset</div>
<div class="line">yOff  - Y offset in the original dataset</div>
<div class="line">xSize - width of the new dataset</div>
<div class="line">ySize - height of the new dataset</div>
</div>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>crop a subimage of size 100x200 pix from X/Y offset 10, 20 pix</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">status</span><span class="p">,</span> <span class="n">extent</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
</pre></div>
</div>
<p>crop a subimage within the lon/lat limits</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">status</span><span class="p">,</span> <span class="n">extent</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">lonlim</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span> <span class="n">latlim</span><span class="o">=</span><span class="p">[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">60</span><span class="p">])</span>
</pre></div>
</div>
<p>crop a subimage interactively</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">status</span><span class="p">,</span> <span class="n">extent</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">crop</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.export">
<tt class="descname">export</tt><big>(</big><em>fileName</em>, <em>bands=None</em>, <em>rmMetadata=[]</em>, <em>addGeolocArray=True</em>, <em>addGCPs=True</em>, <em>driver='netCDF'</em>, <em>bottomup=False</em>, <em>options=None</em><big>)</big><a class="headerlink" href="#nansat.Nansat.export" title="Permalink to this definition">¶</a></dt>
<dd><p>Export Nansat object into netCDF or GTiff file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : str</p>
<blockquote>
<div><p>output file name</p>
</div></blockquote>
<p><strong>bands: list (default=None)</strong></p>
<blockquote>
<div><p>Specify band numbers to export.
If None, all bands are exported.</p>
</div></blockquote>
<p><strong>rmMetadata</strong> : list</p>
<blockquote>
<div><p>metadata names for removal before export.
e.g. [&#8216;name&#8217;, &#8216;colormap&#8217;, &#8216;source&#8217;, &#8216;sourceBands&#8217;]</p>
</div></blockquote>
<p><strong>addGeolocArray</strong> : bool</p>
<blockquote>
<div><p>add geolocation array datasets to exported file?</p>
</div></blockquote>
<p><strong>addGCPs</strong> : bool</p>
<blockquote>
<div><p>add GCPs to exported file?</p>
</div></blockquote>
<p><strong>driver</strong> : str</p>
<blockquote>
<div><p>Name of GDAL driver (format)</p>
</div></blockquote>
<p><strong>bottomup</strong> : bool</p>
<blockquote>
<div><div class="line-block">
<div class="line">False: Write swath-projected data with rows and columns organized
as in the original product.</div>
<div class="line">True:  Use the default behaviour of GDAL, which is to flip the rows</div>
</div>
</div></blockquote>
<p><strong>options</strong> : str or list</p>
<blockquote>
<div><p>GDAL export options in format of: &#8216;OPT=VAL&#8217;, or
[&#8216;OPT1=VAL1&#8217;, &#8216;OP2=&#8217;VAL2&#8217;]
See also <a class="reference external" href="http://www.gdal.org/frmt_netcdf.html">http://www.gdal.org/frmt_netcdf.html</a></p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>Create a netCDF file</strong></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>If number of bands is more than one,
serial numbers are added at the end of each band name.</p>
<p>It is possible to fix it by changing
line.4605 in GDAL/frmts/netcdf/netcdfdataset.cpp :</p>
<div class="line-block">
<div class="line">&#8216;if( nBands &gt; 1 ) sprintf(szBandName,&#8221;%s%d&#8221;,tmpMetadata,iBand);&#8217;</div>
<div class="line-block">
<div class="line">&#8211;&gt; &#8216;if( nBands &gt; 1 ) sprintf(szBandName,&#8221;%s&#8221;,tmpMetadata);&#8217;</div>
</div>
</div>
<p>CreateCopy fails in case the band name has special characters,
e.g. the slash in &#8216;HH/VV&#8217;.</p>
<p class="rubric">Examples</p>
<p>export all the bands into a netDCF 3 file</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">export</span><span class="p">(</span><span class="n">netcdfile</span><span class="p">)</span>
</pre></div>
</div>
<p>export all bands into a GeoTiff</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">export</span><span class="p">(</span><span class="n">driver</span><span class="o">=</span><span class="s">&#39;GTiff&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.export2thredds">
<tt class="descname">export2thredds</tt><big>(</big><em>fileName</em>, <em>bands=None</em>, <em>metadata=None</em>, <em>maskName=None</em>, <em>rmMetadata=[]</em>, <em>time=None</em>, <em>createdTime=None</em><big>)</big><a class="headerlink" href="#nansat.Nansat.export2thredds" title="Permalink to this definition">¶</a></dt>
<dd><p>Export data into a netCDF formatted for THREDDS server</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : str</p>
<blockquote>
<div><p>output file name</p>
</div></blockquote>
<p><strong>bands</strong> : dict</p>
<blockquote>
<div><div class="line-block">
<div class="line">{&#8216;band_name&#8217;: {&#8216;type&#8217;     : &#8216;&gt;i1&#8217;,</div>
<div class="line-block">
<div class="line">&#8216;scale&#8217;    : 0.1,</div>
<div class="line">&#8216;offset&#8217;   : 1000,</div>
<div class="line">&#8216;metaKey1&#8217; : &#8216;meta value 1&#8217;,</div>
<div class="line">&#8216;metaKey2&#8217; : &#8216;meta value 2&#8217;}}</div>
</div>
<div class="line">dictionary sets parameters for band creation</div>
<div class="line">&#8216;type&#8217; - string representation of data type in the output band</div>
<div class="line">&#8216;scale&#8217; - sets scale_factor and applies scaling</div>
<div class="line">&#8216;offset&#8217; - sets &#8216;scale_offset and applies offsetting
other entries (e.g. &#8216;units&#8217;: &#8216;K&#8217;) set other metadata</div>
</div>
</div></blockquote>
<p><strong>metadata</strong> : dict</p>
<blockquote>
<div><p>Glbal metadata to add</p>
</div></blockquote>
<p><strong>maskName: string</strong></p>
<blockquote>
<div><p>if data include a mask band: give the mask name.
Non-masked value is 64.
if None: no mask is added</p>
</div></blockquote>
<p><strong>rmMetadata</strong> : list</p>
<blockquote>
<div><p>unwanted metadata names which will be removed</p>
</div></blockquote>
<p><strong>time</strong> : list with datetime objects</p>
<blockquote>
<div><p>aqcuisition time of original data. That value will be in time dim</p>
</div></blockquote>
<p><strong>createdTime</strong> : datetime</p>
<blockquote class="last">
<div><p>date of creation. Will be in metadata &#8216;created&#8217;</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Nansat object (self) has to be projected (with valid GeoTransform and
valid Spatial reference information) but not wth GCPs</p>
<p class="rubric">Examples</p>
<p>create THREDDS formatted netcdf file with all bands and time variable</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">export2thredds</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
</pre></div>
</div>
<p>export only the first band and add global metadata</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">export2thredds</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">{</span><span class="s">&#39;description&#39;</span><span class="p">:</span> <span class="s">&#39;example&#39;</span><span class="p">})</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.get_GDALRasterBand">
<tt class="descname">get_GDALRasterBand</tt><big>(</big><em>bandID=1</em><big>)</big><a class="headerlink" href="#nansat.Nansat.get_GDALRasterBand" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a GDALRasterBand of a given Nansat object</p>
<div class="line-block">
<div class="line">If str is given find corresponding band number</div>
<div class="line">If int is given check if band with this number exists.</div>
<div class="line">Get a GDALRasterBand from vrt.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>bandID</strong> : serial number or string, optional (default is 1)</p>
<blockquote>
<div><div class="line-block">
<div class="line">if number - a band number of the band to fetch</div>
<div class="line">if string - bandID = {&#8216;name&#8217;: bandID}</div>
</div>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>GDALRasterBand</strong> : GDALRasterBand</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">get_GDALRasterBand</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">get_GDALRasterBand</span><span class="p">(</span><span class="s">&#39;sigma0&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.get_border">
<tt class="descname">get_border</tt><big>(</big><em>nPoints=10</em><big>)</big><a class="headerlink" href="#nansat.Nansat.get_border" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate two vectors with values of lat/lon for the border of domain</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>nPoints</strong> : int, optional</p>
<blockquote>
<div><p>Number of points on each border</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>lonVec, latVec</strong> : lists</p>
<blockquote class="last">
<div><p>vectors with lon/lat values for each point at the border</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.get_border_geometry">
<tt class="descname">get_border_geometry</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Nansat.get_border_geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Get OGR Geometry of the border Polygon</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>OGR Geometry</strong> : OGR Geometry (type Polygon)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.get_border_postgis">
<tt class="descname">get_border_postgis</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Nansat.get_border_postgis" title="Permalink to this definition">¶</a></dt>
<dd><p>Get PostGIS formatted string of the border Polygon</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>str</strong> : PolygonFromText (PolygonWKT)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.get_border_wkt">
<tt class="descname">get_border_wkt</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Nansat.get_border_wkt" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates string with WKT representation of the border polygon</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>WKTPolygon</strong> : string</p>
<blockquote class="last">
<div><p>string with WKT representation of the border polygon</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.get_corners">
<tt class="descname">get_corners</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Nansat.get_corners" title="Permalink to this definition">¶</a></dt>
<dd><p>Get coordinates of corners of the Domain</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>lonVec, latVec</strong> : lists</p>
<blockquote class="last">
<div><p>vectors with lon/lat values for each corner</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.get_geolocation_grids">
<tt class="descname">get_geolocation_grids</tt><big>(</big><em>stepSize=1</em><big>)</big><a class="headerlink" href="#nansat.Nansat.get_geolocation_grids" title="Permalink to this definition">¶</a></dt>
<dd><p>Get longitude and latitude grids representing the full data grid</p>
<div class="line-block">
<div class="line">If GEOLOCATION is not present in the self.vrt.dataset then grids
are generated by converting pixel/line of each pixel into lat/lon</div>
<div class="line">If GEOLOCATION is present in the self.vrt.dataset then grids are read
from the geolocation bands.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>stepSize</strong> : int</p>
<blockquote>
<div><p>Reduction factor if output is desired on a reduced grid size</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>longitude</strong> : numpy array</p>
<blockquote>
<div><p>grid with longitudes</p>
</div></blockquote>
<p><strong>latitude</strong> : numpy array</p>
<blockquote class="last">
<div><p>grid with latitudes</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.get_metadata">
<tt class="descname">get_metadata</tt><big>(</big><em>key=None</em>, <em>bandID=None</em><big>)</big><a class="headerlink" href="#nansat.Nansat.get_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Get metadata from self.vrt.dataset</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>key</strong> : string, optional</p>
<blockquote>
<div><p>name of the metadata key. If not givem all metadata is returned</p>
</div></blockquote>
<p><strong>bandID</strong> : int or str, optional</p>
<blockquote>
<div><div class="line-block">
<div class="line">number or name of band to get metadata from.</div>
<div class="line">If not given, global metadata is returned</div>
</div>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>string</strong> : string with metadata if key is given</p>
<p class="last"><strong>dictionary</strong> : dictionary with all metadata if key is not given</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.get_pixelsize_meters">
<tt class="descname">get_pixelsize_meters</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Nansat.get_pixelsize_meters" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pixelsize (deltaX, deltaY) of the domain</p>
<div class="line-block">
<div class="line">For projected domains, the exact result which is constant
over the domain is returned.</div>
<div class="line">For geographic (lon-lat) projections, or domains with no geotransform,
the haversine formula is used to calculate the pixel size
in the center of the domain.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>deltaX, deltaY</strong> : float</p>
<blockquote class="last">
<div><p>pixel size in X and Y directions given in meters</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.get_time">
<tt class="descname">get_time</tt><big>(</big><em>bandID=None</em><big>)</big><a class="headerlink" href="#nansat.Nansat.get_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Get time for dataset and/or its bands</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>bandID</strong> : int or str (default = None)</p>
<blockquote>
<div><p>band number or name</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>time</strong> : list with datetime objects for each band.</p>
<blockquote class="last">
<div><p>If time is the same for all bands, the list contains 1 item</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.get_transect">
<tt class="descname">get_transect</tt><big>(</big><em>points=None, bandList=[1], latlon=True, returnOGR=False, layerNum=0, smoothRadius=0, smoothAlg=0, transect=True, onlypixline=False, **kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansat.get_transect" title="Permalink to this definition">¶</a></dt>
<dd><p>Get transect from two poins and retun the values by numpy array</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>points</strong> : list with one or more points or shape file name</p>
<blockquote>
<div><div class="line-block">
<div class="line">i.e.</div>
<div class="line">[</div>
<div class="line-block">
<div class="line"># get all transect values</div>
<div class="line">[(lon_T1, lat_T1), (lon_T2, lat_T2), (lon_T3, lat_T3), ...]</div>
<div class="line"># get point values</div>
<div class="line">(lon_P1, lat_P1), (lon_P2, lat_P2), ...</div>
</div>
<div class="line">]</div>
<div class="line">or</div>
<div class="line">[</div>
<div class="line-block">
<div class="line"># get all transect values</div>
<div class="line">[(col_T1, row_T1), (col_T2, row_T2), (col_T3, row_T3), ...],</div>
<div class="line"># get point values</div>
<div class="line">(col_P1, row_P1), (col_P2, row_P2), ...</div>
</div>
<div class="line">]</div>
</div>
</div></blockquote>
<p><strong>bandList</strong> : list of int or string</p>
<blockquote>
<div><p>elements of the list are band number or band Name</p>
</div></blockquote>
<p><strong>latlon</strong> : bool</p>
<blockquote>
<div><div class="line-block">
<div class="line">If the points in lat/lon, then True.</div>
<div class="line">If the points in pixel/line, then False.</div>
</div>
</div></blockquote>
<p><strong>returnOGR</strong> : bool</p>
<blockquote>
<div><div class="line-block">
<div class="line">If True, then return numpy array</div>
<div class="line">If False, return OGR object</div>
</div>
</div></blockquote>
<p><strong>layerNum</strong> : int</p>
<blockquote>
<div><p>If shapefile is given as points, it is the number of the layer</p>
</div></blockquote>
<p><strong>smoothRadius</strong> : int</p>
<blockquote>
<div><p>If smootRadius is greater than 0, smooth every transect
pixel as the median or mean value in a circule with radius
equal to the given number.</p>
</div></blockquote>
<p><strong>smoothAlg</strong> : 0 or 1 for median or mean</p>
<p><strong>transect</strong> : bool</p>
<blockquote>
<div><div class="line-block">
<div class="line">used if a shape file name is given as the input.</div>
<div class="line">If True, return the transect. If False, return the points.</div>
</div>
</div></blockquote>
<p><strong>vmin, vmax</strong> : int (optional)</p>
<blockquote>
<div><p>minimum and maximum pixel values of an image shown
in case points is None.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>NansatOGR</strong> : nansatshape object (if retunOGR is True)</p>
<p><strong>transectDict</strong> : dictionary (if retunOGR is False)</p>
<blockquote>
<div><p>keys are band names.
Values are dictionaries of the transect values of each shape.</p>
</div></blockquote>
<p><strong>vectorsDict</strong> : dictionary (if retunOGR is False)</p>
<blockquote>
<div><p>keys are shape ID. values are dictionaries
with longitude and latitude lists of each shape.</p>
</div></blockquote>
<p><strong>pixlinCoordDic</strong> : dictionary (if retunOGR is False)</p>
<blockquote class="last">
<div><p>keys are shape ID. values are numpy array
with pixels and lines coordinates</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>If points are given from GUI,
it is possible to select multiple shapes by pressing any key</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.has_band">
<tt class="descname">has_band</tt><big>(</big><em>band</em><big>)</big><a class="headerlink" href="#nansat.Nansat.has_band" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if self has band with name &lt;band&gt;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>band</strong> : str</p>
<blockquote>
<div><p>name of the band to check</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>bool</strong> : if band exists or not</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.list_bands">
<tt class="descname">list_bands</tt><big>(</big><em>doPrint=True</em><big>)</big><a class="headerlink" href="#nansat.Nansat.list_bands" title="Permalink to this definition">¶</a></dt>
<dd><p>Show band information of the given Nansat object</p>
<p>Show serial number, longName, name and all parameters
for each band in the metadata of the given Nansat object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>doPrint</strong> : boolean, optional, default=True</p>
<blockquote>
<div><p>do print, otherwise it is returned as string</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>outString</strong> : String</p>
<blockquote class="last">
<div><p>formatted string with bands info</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.reproject">
<tt class="descname">reproject</tt><big>(</big><em>dstDomain=None</em>, <em>eResampleAlg=0</em>, <em>blockSize=None</em>, <em>WorkingDataType=None</em>, <em>tps=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansat.reproject" title="Permalink to this definition">¶</a></dt>
<dd><p>Change projection of the object based on the given Domain</p>
<p>Create superVRT from self.vrt with AutoCreateWarpedVRT() using
projection from the dstDomain.
Modify XML content of the warped vrt using the Domain parameters.
Generate warpedVRT and replace self.vrt with warpedVRT.
If current object spans from 0 to 360 and dstDomain is west of 0,
the object is shifted by 180 westwards.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dstDomain</strong> : domain</p>
<blockquote>
<div><p>destination Domain where projection and resolution are set</p>
</div></blockquote>
<p><strong>eResampleAlg</strong> : int (GDALResampleAlg)</p>
<blockquote>
<div><div class="line-block">
<div class="line">0 : NearestNeighbour</div>
<div class="line">1 : Bilinear</div>
<div class="line">2 : Cubic,</div>
<div class="line">3 : CubicSpline</div>
<div class="line">4 : Lancoz</div>
</div>
</div></blockquote>
<p><strong>blockSize</strong> : int</p>
<blockquote>
<div><p>size of blocks for resampling. Large value decrease speed
but increase accuracy at the edge</p>
</div></blockquote>
<p><strong>WorkingDataType</strong> : int (GDT_int, ...)</p>
<blockquote>
<div><p>type of data in bands. Shuold be integer for int32 bands</p>
</div></blockquote>
<p><strong>tps</strong> : bool</p>
<blockquote>
<div><p>Apply Thin Spline Transformation if source or destination has GCPs
Usage of TPS can also be triggered by setting self.vrt.tps=True
before calling to reproject.
This options has priority over self.vrt.tps</p>
</div></blockquote>
<p><strong>skip_gcps</strong> : int</p>
<blockquote>
<div><p>Using TPS can be very slow if the number of GCPs are large.
If this parameter is given, only every [skip_gcp] GCP is used,
improving calculation time at the cost of accuracy.
If not given explicitly, &#8216;skip_gcps&#8217; is fetched from the
metadata of self, or from dstDomain (as set by mapper or user).
[defaults to 1 if not specified, i.e. using all GCPs]</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.vrt</strong> : VRT object with dataset replaced to warpedVRT dataset</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="line-block">
<div class="line">Integer data is returnd by integer. Round off to decimal place.</div>
<div class="line">If you do not want to round off, convert the data types
to GDT_Float32, GDT_Float64, or GDT_CFloat32.</div>
</div>
<p>see also: <a class="reference external" href="http://www.gdal.org/gdalwarp.html">http://www.gdal.org/gdalwarp.html</a></p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.reproject_GCPs">
<tt class="descname">reproject_GCPs</tt><big>(</big><em>srsString</em><big>)</big><a class="headerlink" href="#nansat.Nansat.reproject_GCPs" title="Permalink to this definition">¶</a></dt>
<dd><p>Reproject all GCPs to a new spatial reference system</p>
<p>Necessary before warping an image if the given GCPs
are in a coordinate system which has a singularity
in (or near) the destination area (e.g. poles for lonlat GCPs)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>srsString</strong> : string</p>
<blockquote>
<div><p>SRS given as Proj4 string</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.vrt</strong> : Reprojects all GCPs to new SRS and updates GCPProjection</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.resize">
<tt class="descname">resize</tt><big>(</big><em>factor=1</em>, <em>width=None</em>, <em>height=None</em>, <em>pixelsize=None</em>, <em>eResampleAlg=-1</em><big>)</big><a class="headerlink" href="#nansat.Nansat.resize" title="Permalink to this definition">¶</a></dt>
<dd><p>Proportional resize of the dataset.</p>
<div class="line-block">
<div class="line">The dataset is resized as (xSize*factor, ySize*factor)</div>
<div class="line">If desired width, height or pixelsize is specified,
the scaling factor is calculated accordingly.</div>
<div class="line">If GCPs are given in a dataset, they are also rewritten.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>factor</strong> : float, optional, default=1</p>
<blockquote>
<div><div class="line-block">
<div class="line">Scaling factor for width and height</div>
<div class="line">&gt; 1 means increasing domain size</div>
<div class="line">&lt; 1 means decreasing domain size</div>
</div>
</div></blockquote>
<p><strong>width</strong> : int, optional</p>
<blockquote>
<div><p>Desired new width in pixels</p>
</div></blockquote>
<p><strong>height</strong> : int, optional</p>
<blockquote>
<div><p>Desired new height in pixels</p>
</div></blockquote>
<p><strong>pixelsize</strong> : float, optional</p>
<blockquote>
<div><div class="line-block">
<div class="line">Desired new pixelsize in meters (approximate).</div>
<div class="line">A factor is calculated from ratio of the</div>
<div class="line">current pixelsize to the desired pixelsize.</div>
</div>
</div></blockquote>
<p><strong>eResampleAlg</strong> : int (GDALResampleAlg), optional</p>
<blockquote>
<div><div class="line-block">
<div class="line">-1 : Average (default),</div>
<div class="line">0 : NearestNeighbour</div>
<div class="line">1 : Bilinear,</div>
<div class="line">2 : Cubic,</div>
<div class="line">3 : CubicSpline,</div>
<div class="line">4 : Lancoz</div>
</div>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.vrt.dataset</strong> : VRT dataset of VRT object</p>
<blockquote class="last">
<div><p>raster size are modified to downscaled size.
If GCPs are given in the dataset, they are also overwritten.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.set_metadata">
<tt class="descname">set_metadata</tt><big>(</big><em>key=''</em>, <em>value=''</em>, <em>bandID=None</em><big>)</big><a class="headerlink" href="#nansat.Nansat.set_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Set metadata to self.vrt.dataset</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>key</strong> : string or dictionary with strings</p>
<blockquote>
<div><p>name of the metadata, or dictionary with metadata names, values</p>
</div></blockquote>
<p><strong>value</strong> : string</p>
<blockquote>
<div><p>value of metadata</p>
</div></blockquote>
<p><strong>bandID</strong> : int or str</p>
<blockquote>
<div><p>number or name of band
Without : global metadata is set</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.vrt.dataset</strong> : sets metadata in GDAL current dataset</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.shape">
<tt class="descname">shape</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Nansat.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Numpy-like shape of Domain object (ySize, xSize)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>shape</strong> : tuple of two INT</p>
<blockquote class="last">
<div><p>Numpy-like shape of Domain object (ySize, xSize)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.transform_points">
<tt class="descname">transform_points</tt><big>(</big><em>colVector</em>, <em>rowVector</em>, <em>DstToSrc=0</em><big>)</big><a class="headerlink" href="#nansat.Nansat.transform_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform given lists of X,Y coordinates into lon/lat or inverse</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>colVector</strong> : lists</p>
<blockquote>
<div><p>X and Y coordinates in pixel/line or lon/lat  coordinate system</p>
</div></blockquote>
<p><strong>DstToSrc</strong> : 0 or 1</p>
<blockquote>
<div><p>0 - forward transform (pix/line =&gt; lon/lat)
1 - inverse transformation</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>X, Y</strong> : lists</p>
<blockquote class="last">
<div><p>X and Y coordinates in lon/lat or pixel/line coordinate system</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.undo">
<tt class="descname">undo</tt><big>(</big><em>steps=1</em><big>)</big><a class="headerlink" href="#nansat.Nansat.undo" title="Permalink to this definition">¶</a></dt>
<dd><p>Undo reproject, resize, add_band or crop of Nansat object</p>
<p>Restore the self.vrt from self.vrt.vrt</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>steps</strong> : int</p>
<blockquote>
<div><p>How many steps back to undo</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.vrt</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.watermask">
<tt class="descname">watermask</tt><big>(</big><em>mod44path=None</em>, <em>dstDomain=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansat.watermask" title="Permalink to this definition">¶</a></dt>
<dd><p>Create numpy array with watermask (water=1, land=0)</p>
<p>250 meters resolution watermask from MODIS 44W Product:
<a class="reference external" href="http://www.glcf.umd.edu/data/watermask/">http://www.glcf.umd.edu/data/watermask/</a></p>
<div class="line-block">
<div class="line">Watermask is stored as tiles in TIF(LZW) format and a VRT file</div>
<div class="line">All files are stored in one directory.</div>
<div class="line">A tarball with compressed TIF and VRT files should be additionally
downloaded from the Nansat wiki:</div>
<div class="line"><a class="reference external" href="https://svn.nersc.no/nansat/wiki/Nansat/Data/Watermask">https://svn.nersc.no/nansat/wiki/Nansat/Data/Watermask</a></div>
</div>
<div class="line-block">
<div class="line">The method :</div>
<div class="line">Gets the directory either from input parameter or from environment
variable MOD44WPATH</div>
<div class="line">Open Nansat object from the VRT file</div>
<div class="line">Reprojects the watermask onto the current object using reproject()
or reproject_on_jcps()</div>
<div class="line">Returns the reprojected Nansat object</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mod44path</strong> : string, optional, default=None</p>
<blockquote>
<div><p>path with MOD44W Products and a VRT file</p>
</div></blockquote>
<p><strong>dstDomain</strong> : Domain</p>
<blockquote>
<div><p>destination domain other than self</p>
</div></blockquote>
<p><strong>tps</strong> : Bool</p>
<blockquote>
<div><p>Use Thin Spline Transformation in reprojection of watermask?
See also Nansat.reproject()</p>
</div></blockquote>
<p><strong>skip_gcps</strong> : int</p>
<blockquote>
<div><p>Factor to reduce the number of GCPs by and increase speed
See also Nansat.reproject()</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>watermask</strong> : Nansat object with water mask in current projection</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>250 meters resolution watermask from MODIS 44W Product:
<a class="reference external" href="http://www.glcf.umd.edu/data/watermask/">http://www.glcf.umd.edu/data/watermask/</a></p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.write_figure">
<tt class="descname">write_figure</tt><big>(</big><em>fileName=None</em>, <em>bands=1</em>, <em>clim=None</em>, <em>addDate=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansat.write_figure" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a raster band to a figure in graphical format.</p>
<div class="line-block">
<div class="line">Get numpy array from the band(s) and band information specified
either by given band number or band id.</div>
<div class="line">If three bands are given, merge them and create PIL image.</div>
<div class="line">If one band is given, create indexed image</div>
<div class="line">Create Figure object and:</div>
<div class="line">Adjust the array brightness and contrast using the given min/max or
histogram.</div>
<div class="line">Apply logarithmic scaling of color tone.</div>
<div class="line">Generate and append legend.</div>
<div class="line">Save the PIL output image in PNG or any other graphical format.</div>
<div class="line">If the filename extension is &#8216;tif&#8217;, the figure file is converted
to GeoTiff</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : string, optional</p>
<blockquote>
<div><div class="line-block">
<div class="line">Output file name. if one of extensions &#8216;png&#8217;, &#8216;PNG&#8217;, &#8216;tif&#8217;,
&#8216;TIF&#8217;, &#8216;bmp&#8217;, &#8216;BMP&#8217;, &#8216;jpg&#8217;, &#8216;JPG&#8217;, &#8216;jpeg&#8217;, &#8216;JPEG&#8217; is included,
specified file is crated. otherwise, &#8216;png&#8217; file is created.</div>
<div class="line">if None, the figure object is returned.</div>
<div class="line">if True, the figure is shown</div>
</div>
</div></blockquote>
<p><strong>bands</strong> : integer or string or list (elements are integer or string),</p>
<blockquote>
<div><div class="line-block">
<div class="line">default = 1</div>
<div class="line">the size of the list has to be 1 or 3.</div>
<div class="line">if the size is 3, RGB image is created based on the three bands.</div>
<div class="line">Then the first element is Red, the second is Green,
and the third is Blue.</div>
</div>
</div></blockquote>
<p><strong>clim</strong> : list with two elements or &#8216;hist&#8217; to specify range of colormap</p>
<blockquote>
<div><div class="line-block">
<div class="line">None (default) : min/max values are fetched from WKV,
fallback-&#8216;hist&#8217;</div>
<div class="line">[min, max] : min and max are numbers, or
[[min, min, min], [max, max, max]]: three bands used</div>
<div class="line">&#8216;hist&#8217; : a histogram is used to calculate min and max values</div>
</div>
</div></blockquote>
<p><strong>addDate</strong> : boolean</p>
<blockquote>
<div><div class="line-block">
<div class="line">False (default) : no date will be aded to the caption</div>
<div class="line">True : the first time of the object will be added to the caption</div>
</div>
</div></blockquote>
<p><strong>**kwargs</strong> : parameters for Figure().</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>if fileName is specified, creates image file</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>Figure object</strong> : Figure object</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Write only indexed image, color limits from WKV or from histogram</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">write_figure</span><span class="p">(</span><span class="s">&#39;test.jpg&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Write only RGB image, color limits from histogram</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">write_figure</span><span class="p">(</span><span class="s">&#39;test_rgb_hist.jpg&#39;</span><span class="p">,</span> <span class="n">clim</span><span class="o">=</span><span class="s">&#39;hist&#39;</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
<p>Write indexed image, apply log scaling and gamma correction,
add legend and type in title &#8216;Title&#8217;, increase font size and put 15
tics</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">write_figure</span><span class="p">(</span><span class="s">&#39;r09_log3_leg.jpg&#39;</span><span class="p">,</span> <span class="n">logarithm</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">legend</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                <span class="n">gamma</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">titleString</span><span class="o">=</span><span class="s">&#39;Title&#39;</span><span class="p">,</span> <span class="n">fontSize</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                <span class="n">numOfTicks</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
</pre></div>
</div>
<p>Write an image to png with transparent Mask set to color
transparency=[0,0,0], following PIL alpha mask</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">write_figure</span><span class="p">(</span><span class="n">fileName</span><span class="o">=</span><span class="s">&#39;transparent.png&#39;</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
<span class="gp">&gt;&gt;&gt; </span>               <span class="n">mask_array</span><span class="o">=</span><span class="n">wmArray</span><span class="p">,</span> <span class="n">mask_lut</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]},</span>
<span class="gp">&gt;&gt;&gt; </span>               <span class="n">clim</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.15</span><span class="p">],</span> <span class="n">cmapName</span><span class="o">=</span><span class="s">&#39;gray&#39;</span><span class="p">,</span> <span class="n">transparency</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<dl class="docutils">
<dt>see also Figure() :</dt>
<dd><a class="reference external" href="http://www.scipy.org/Cookbook/Matplotlib/Show_colormaps">http://www.scipy.org/Cookbook/Matplotlib/Show_colormaps</a></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.write_geotiffimage">
<tt class="descname">write_geotiffimage</tt><big>(</big><em>fileName</em>, <em>bandID=1</em><big>)</big><a class="headerlink" href="#nansat.Nansat.write_geotiffimage" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes an 8-bit GeoTiff image for a given band.</p>
<div class="line-block">
<div class="line">The output GeoTiff image is convenient e.g. for display in a GIS tool.</div>
<div class="line">Colormap is fetched from the metadata item &#8216;colormap&#8217;.
Fallback colormap is &#8216;jet&#8217;.</div>
<div class="line">Color limits are fetched from the metadata item &#8216;minmax&#8217;.</div>
<div class="line">If &#8216;minmax&#8217; is not specified, min and max of raster is used.</div>
</div>
<div class="line-block">
<div class="line">The method can be replaced by using nansat.write_figure(),
however, write_figure uses PIL which does not allow
Tiff compression, giving much larger files</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : string</p>
<p class="last"><strong>bandID</strong> : integer or string(default = 1)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.write_kml">
<tt class="descname">write_kml</tt><big>(</big><em>xmlFileName=None</em>, <em>kmlFileName=None</em><big>)</big><a class="headerlink" href="#nansat.Nansat.write_kml" title="Permalink to this definition">¶</a></dt>
<dd><p>Write KML file with domains</p>
<p>Convert XML-file with domains into KML-file for GoogleEarth
or write KML-file with the current Domain</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xmlFileName</strong> : string, optional</p>
<blockquote>
<div><p>Name of the XML-file to convert. If only this value is given
- kmlFileName=xmlFileName+&#8217;.kml&#8217;</p>
</div></blockquote>
<p><strong>kmlFileName</strong> : string, optional</p>
<blockquote class="last">
<div><p>Name of the KML-file to generate from the current Domain</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.write_kml_image">
<tt class="descname">write_kml_image</tt><big>(</big><em>kmlFileName=None</em>, <em>kmlFigureName=None</em><big>)</big><a class="headerlink" href="#nansat.Nansat.write_kml_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Create KML file for already projected image</p>
<p>Write Domain Image into KML-file for GoogleEarth</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>kmlFileName</strong> : string, optional</p>
<blockquote>
<div><p>Name of the KML-file to generate from the current Domain</p>
</div></blockquote>
<p><strong>kmlFigureName</strong> : string, optional</p>
<blockquote class="last">
<div><p>Name of the projected image stored in .png format</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="line-block">
<div class="line">First of all, reproject an image into Lat/Lon WGS84
(Simple Cylindrical) projection</div>
<div class="line">1. Cancel previous reprojection</div>
<div class="line">2. Get corners of the image and the pixel resolution</div>
<div class="line">3. Create Domain with stereographic projection,
corner coordinates and resolution 1000m</div>
<div class="line">4. Reproject</div>
<div class="line">5. Write image</div>
<div class="line">6. Write KML for the image</div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">reproject</span><span class="p">()</span>  <span class="c"># 1.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">get_corners</span><span class="p">()</span>  <span class="c"># 2.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">srsString</span> <span class="o">=</span> <span class="s">&#39;+proj=latlong +datum=WGS84 +ellps=WGS84 +no_defs&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">extentString</span> <span class="o">=</span> <span class="s">&#39;-lle </span><span class="si">%f</span><span class="s"> </span><span class="si">%f</span><span class="s"> </span><span class="si">%f</span><span class="s"> </span><span class="si">%f</span><span class="s"> -ts 3000 3000&#39;</span>
<span class="gp">&gt;&gt;&gt; </span>                <span class="o">%</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">lons</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">lats</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">lons</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">lats</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">Domain</span><span class="p">(</span><span class="n">srs</span><span class="o">=</span><span class="n">srsString</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">extentString</span><span class="p">)</span>  <span class="c"># 3.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">reproject</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>  <span class="c"># 4.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">write_figure</span><span class="p">(</span><span class="n">fileName</span><span class="o">=</span><span class="n">figureName</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">clim</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.15</span><span class="p">],</span>
<span class="gp">&gt;&gt;&gt; </span>               <span class="n">cmapName</span><span class="o">=</span><span class="s">&#39;gray&#39;</span><span class="p">,</span> <span class="n">transparency</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c"># 5.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">write_kml_image</span><span class="p">(</span><span class="n">kmlFileName</span><span class="o">=</span><span class="n">oPath</span> <span class="o">+</span> <span class="n">fileName</span> <span class="o">+</span> <span class="s">&#39;.kml&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">kmlFigureName</span><span class="o">=</span><span class="n">figureName</span><span class="p">)</span>  <span class="c"># 6.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.write_map">
<tt class="descname">write_map</tt><big>(</big><em>outputFileName, lonVec=None, latVec=None, lonBorder=10.0, latBorder=10.0, figureSize=(6, 6), dpi=50, projection='cyl', resolution='c', continetsColor='coral', meridians=10, parallels=10, pColor='r', pLine='k', pAlpha=0.5, padding=0.0, merLabels=[False, False, False, False], parLabels=[False, False, False, False], pltshow=False</em><big>)</big><a class="headerlink" href="#nansat.Nansat.write_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an image with a map of the domain</p>
<div class="line-block">
<div class="line">Uses Basemap to create a World Map</div>
<div class="line">Adds a semitransparent patch with outline of the Domain</div>
<div class="line">Writes to an image file</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>outputFileName</strong> : string</p>
<blockquote>
<div><p>name of the output file name</p>
</div></blockquote>
<p><strong>lonBorder</strong> : float</p>
<blockquote>
<div><p>10, horisontal border around patch (degrees of longitude)</p>
</div></blockquote>
<p><strong>latBorder</strong> : float</p>
<blockquote>
<div><p>10, vertical border around patch (degrees of latitude)</p>
</div></blockquote>
<p><strong>figureSize</strong> : tuple of two integers</p>
<blockquote>
<div><p>(6, 6), size of the generated figure in inches</p>
</div></blockquote>
<p><strong>dpi: int</strong></p>
<blockquote>
<div><p>50, resolution of the output figure (size 6,6 and dpi 50
produces 300 x 300 figure)</p>
</div></blockquote>
<p><strong>projection</strong> : string, one of Basemap projections</p>
<blockquote>
<div><p>&#8216;cyl&#8217;, projection of the map</p>
</div></blockquote>
<p><strong>resolution</strong> : string, resolution of the map</p>
<blockquote>
<div><div class="line-block">
<div class="line">&#8216;c&#8217;, crude</div>
<div class="line">&#8216;l&#8217;, low</div>
<div class="line">&#8216;i&#8217;, intermediate</div>
<div class="line">&#8216;h&#8217;, high</div>
<div class="line">&#8216;f&#8217;, full</div>
</div>
</div></blockquote>
<p><strong>continetsColor</strong> : string or any matplotlib color representation</p>
<blockquote>
<div><p>&#8216;coral&#8217;, color of continets</p>
</div></blockquote>
<p><strong>meridians</strong> : int</p>
<blockquote>
<div><p>10, number of meridians to draw</p>
</div></blockquote>
<p><strong>parallels</strong> : int</p>
<blockquote>
<div><p>10, number of parallels to draw</p>
</div></blockquote>
<p><strong>pColor</strong> : string or any matplotlib color representation</p>
<blockquote>
<div><p>&#8216;r&#8217;, color of the Domain patch</p>
</div></blockquote>
<p><strong>pLine</strong> : string or any matplotlib color representation</p>
<blockquote>
<div><p>&#8216;k&#8217;, color of the Domain outline</p>
</div></blockquote>
<p><strong>pAlpha</strong> : float 0 - 1</p>
<blockquote>
<div><p>0.5, transparency of Domain patch</p>
</div></blockquote>
<p><strong>padding</strong> : float</p>
<blockquote>
<div><p>0., width of white padding around the map</p>
</div></blockquote>
<p><strong>merLabels</strong> : list of 4 booleans</p>
<blockquote>
<div><p>where to put meridian labels, see also Basemap.drawmeridians()</p>
</div></blockquote>
<p><strong>parLables</strong> : list of 4 booleans</p>
<blockquote class="last">
<div><p>where to put parallel labels, see also Basemap.drawparallels()</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nansat.Figure">
<em class="property">class </em><tt class="descclassname">nansat.</tt><tt class="descname">Figure</tt><big>(</big><em>nparray</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure" title="Permalink to this definition">¶</a></dt>
<dd><p>Set attributes</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>array</strong> : numpy array (2D or 3D)</p>
<blockquote>
<div><p>dataset from Nansat</p>
</div></blockquote>
<p><strong>cmin</strong> : number (int ot float) or [number, number, number]</p>
<blockquote>
<div><p>0, minimum value of varibale in the matrix to be shown</p>
</div></blockquote>
<p><strong>cmax</strong> : number (int ot float) or [number, number, number]</p>
<blockquote>
<div><p>1, minimum value of varibale in the matrix to be shown</p>
</div></blockquote>
<p><strong>gamma</strong> : float, &gt;0</p>
<blockquote>
<div><p>2, coefficient for tone curve udjustment</p>
</div></blockquote>
<p><strong>subsetArraySize</strong> : int</p>
<blockquote>
<div><p>100000, size of the subset array which is used to get histogram</p>
</div></blockquote>
<p><strong>numOfColor</strong> : int</p>
<blockquote>
<div><p>250, number of colors for use of the palette.
254th is black and 255th is white.</p>
</div></blockquote>
<p><strong>cmapName</strong> : string</p>
<blockquote>
<div><p>&#8216;jet&#8217;, name of Matplotlib colormaps
see &#8211;&gt; <a class="reference external" href="http://www.scipy.org/Cookbook/Matplotlib/Show_colormaps">http://www.scipy.org/Cookbook/Matplotlib/Show_colormaps</a></p>
</div></blockquote>
<p><strong>ratio</strong> : float, [0 1]</p>
<blockquote>
<div><p>1.0, ratio of pixels which are used to write the figure</p>
</div></blockquote>
<p><strong>numOfTicks</strong> : int</p>
<blockquote>
<div><p>5, number of ticks on a colorbar</p>
</div></blockquote>
<p><strong>titleString</strong> : string</p>
<blockquote>
<div><p>&#8216;&#8217;, title of legend (1st line)</p>
</div></blockquote>
<p><strong>caption</strong> : string</p>
<blockquote>
<div><p>&#8216;&#8217;, caption of the legend (2nd line, e.g. long name and units)</p>
</div></blockquote>
<p><strong>fontRatio</strong> : positive float</p>
<blockquote>
<div><p>1, factor for changing the fontSize.</p>
</div></blockquote>
<p><strong>fontSize</strong> : int</p>
<blockquote>
<div><p>12, size of the font of title, caption and ticks.
If not given, fontSize is calculated using fontRatio:
fontSize = height / 45 * fontRatio.
fontSize has priority over fontRatio</p>
</div></blockquote>
<p><strong>logarithm</strong> : boolean, defult = False</p>
<blockquote>
<div><p>If True, tone curve is used to convert pixel values.
If False, linear.</p>
</div></blockquote>
<p><strong>legend</strong> : boolean, default = False</p>
<blockquote>
<div><p>if True, information as textString, colorbar, longName and
units are added in the figure.</p>
</div></blockquote>
<p><strong>mask_array</strong> : 2D numpy array, int, the shape should be equal</p>
<blockquote>
<div><p>array.shape. If given this array is used for masking land,
clouds, etc on the output image. Value of the array are
indeces. LUT from mask_lut is used for coloring upon this
indeces.</p>
</div></blockquote>
<p><strong>mask_lut</strong> : dictionary</p>
<blockquote>
<div><p>Look-Up-Table with colors for masking land, clouds etc. Used
tgether with mask_array:
{0, [0,0,0], 1, [100,100,100], 2: [150,150,150], 3: [0,0,255]}
index 0 - will have black color</p>
<blockquote>
<div><p>1 - dark gray
2 - light gray
3 - blue</p>
</div></blockquote>
</div></blockquote>
<p><strong>logoFileName</strong> : string</p>
<blockquote>
<div><p>name of the file with logo</p>
</div></blockquote>
<p><strong>logoLocation</strong> : list of two int, default = [0,0]</p>
<blockquote>
<div><p>X and Y offset of the image
If positive - offset is from left, upper edge
If Negative - from right, lower edge
Offset is calculated from the entire image legend inclusive</p>
</div></blockquote>
<p><strong>logoSize</strong> : list of two int</p>
<blockquote>
<div><p>desired X,Y size of logo. If None - original size is used</p>
</div></blockquote>
<p><strong>latGrid</strong> : numpy array</p>
<blockquote>
<div><p>full size array with latitudes. For adding lat/lon grid lines</p>
</div></blockquote>
<p><strong>lonGrid</strong> : numpy array</p>
<blockquote>
<div><p>full size array with longitudes. For adding lat/lon grid lines</p>
</div></blockquote>
<p><strong>nGridLines</strong> : int</p>
<blockquote>
<div><p>number of lat/lon grid lines to show</p>
</div></blockquote>
<p><strong>latlonLabels</strong> : int</p>
<blockquote>
<div><p>number of lat/lon labels to show along each side.</p>
</div></blockquote>
<p><strong>transparency</strong> : int</p>
<blockquote>
<div><p>transparency of the image background(mask), set for PIL alpha
mask in Figure.save()</p>
</div></blockquote>
<p><strong>default</strong> : None</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.sizeX, self.sizeY</strong> : int</p>
<blockquote>
<div><p>width and height of the image</p>
</div></blockquote>
<p><strong>self.pilImg</strong> : PIL image</p>
<blockquote>
<div><p>figure</p>
</div></blockquote>
<p><strong>self.pilImgLegend</strong> : PIL image</p>
<blockquote>
<div><p>if pilImgLegend is None, legend is not added to the figure
if it is replaced, pilImgLegend includes text string, color-bar,
longName and units.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first"><strong>LEGEND_HEIGHT</strong> : float, [0 1]</p>
<blockquote>
<div><p>0.1, legend height relative to image height</p>
</div></blockquote>
<p><strong>CBAR_HEIGHTMIN</strong> : int</p>
<blockquote>
<div><p>5, minimum colorbar height, pixels</p>
</div></blockquote>
<p><strong>CBAR_HEIGHT</strong> : float, [0 1]</p>
<blockquote>
<div><p>0.15,  colorbar height relative to image height</p>
</div></blockquote>
<p><strong>CBAR_WIDTH</strong> : float [0 1]</p>
<blockquote>
<div><p>0.8, colorbar width  relative to legend width</p>
</div></blockquote>
<p><strong>CBAR_LOCATION_X</strong> : float [0 1]</p>
<blockquote>
<div><p>0.1, colorbar offset X  relative to legend width</p>
</div></blockquote>
<p><strong>CBAR_LOCATION_Y</strong> : float [0 1]</p>
<blockquote>
<div><p>0.5,  colorbar offset Y  relative to legend height</p>
</div></blockquote>
<p><strong>CBTICK_LOC_ADJUST_X</strong> : int</p>
<blockquote>
<div><p>5,  colorbar tick label offset X, pixels</p>
</div></blockquote>
<p><strong>CBTICK_LOC_ADJUST_Y</strong> : int</p>
<blockquote>
<div><p>3,  colorbar tick label offset Y, pixels</p>
</div></blockquote>
<p><strong>CAPTION_LOCATION_X</strong> : float, [0 1]</p>
<blockquote>
<div><p>0.1, caption offset X relative to legend width</p>
</div></blockquote>
<p><strong>CAPTION_LOCATION_Y</strong> : float, [0 1]</p>
<blockquote>
<div><p>0.1, caption offset Y relative to legend height</p>
</div></blockquote>
<p><strong>TITLE_LOCATION_X</strong> : float, [0 1]</p>
<blockquote>
<div><p>0.1, title offset X relative to legend width</p>
</div></blockquote>
<p><strong>TITLE_LOCATION_Y :</strong></p>
<blockquote>
<div><p>0.3, title  offset Y relative to legend height</p>
</div></blockquote>
<p><strong>DEFAULT_EXTENSION</strong> : string</p>
<blockquote class="last">
<div><p>&#8216;.png&#8217;</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="55%" />
<col width="45%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>fontSize</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>latGrid</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>logoFileName</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>logoSize</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>lonGrid</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>mask_array</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>mask_lut</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>palette</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>pilImg</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>pilImgLegend</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>transparency</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Figure.add_latlon_grids" title="nansat.Figure.add_latlon_grids"><tt class="xref py py-obj docutils literal"><span class="pre">add_latlon_grids</span></tt></a>(**kwargs)</td>
<td>Add lat/lon grid lines into the PIL image</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Figure.add_latlon_labels" title="nansat.Figure.add_latlon_labels"><tt class="xref py py-obj docutils literal"><span class="pre">add_latlon_labels</span></tt></a>(**kwargs)</td>
<td>Add lat/lon labels along upper and left side</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Figure.add_logo" title="nansat.Figure.add_logo"><tt class="xref py py-obj docutils literal"><span class="pre">add_logo</span></tt></a>(**kwargs)</td>
<td>Insert logo into the PIL image</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Figure.apply_logarithm" title="nansat.Figure.apply_logarithm"><tt class="xref py py-obj docutils literal"><span class="pre">apply_logarithm</span></tt></a>(**kwargs)</td>
<td>Apply a tone curve to the array</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Figure.apply_mask" title="nansat.Figure.apply_mask"><tt class="xref py py-obj docutils literal"><span class="pre">apply_mask</span></tt></a>(**kwargs)</td>
<td>Apply mask for coloring land, clouds, etc</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Figure.clim_from_histogram" title="nansat.Figure.clim_from_histogram"><tt class="xref py py-obj docutils literal"><span class="pre">clim_from_histogram</span></tt></a>(**kwargs)</td>
<td>Estimate min and max pixel values from histogram</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Figure.clip" title="nansat.Figure.clip"><tt class="xref py py-obj docutils literal"><span class="pre">clip</span></tt></a>(**kwargs)</td>
<td>Convert self.array to values between cmin and cmax</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Figure.convert_palettesize" title="nansat.Figure.convert_palettesize"><tt class="xref py py-obj docutils literal"><span class="pre">convert_palettesize</span></tt></a>(**kwargs)</td>
<td>Convert self.array to palette color size in uint8</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Figure.create_legend" title="nansat.Figure.create_legend"><tt class="xref py py-obj docutils literal"><span class="pre">create_legend</span></tt></a>(**kwargs)</td>
<td>self.legend is replaced from None to PIL image</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Figure.create_pilImage" title="nansat.Figure.create_pilImage"><tt class="xref py py-obj docutils literal"><span class="pre">create_pilImage</span></tt></a>(**kwargs)</td>
<td>self.create_pilImage is replaced from None to PIL image</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Figure.process" title="nansat.Figure.process"><tt class="xref py py-obj docutils literal"><span class="pre">process</span></tt></a>(**kwargs)</td>
<td>Do all common operations for preparation of a figure for saving</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Figure.save" title="nansat.Figure.save"><tt class="xref py py-obj docutils literal"><span class="pre">save</span></tt></a>(fileName,&nbsp;**kwargs)</td>
<td>Save self.pilImg to a physical file</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nansat.Figure.add_latlon_grids">
<tt class="descname">add_latlon_grids</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure.add_latlon_grids" title="Permalink to this definition">¶</a></dt>
<dd><p>Add lat/lon grid lines into the PIL image</p>
<div class="line-block">
<div class="line">Compute step of the grid</div>
<div class="line">Make matrices with binarized lat/lon</div>
<div class="line">Find edge (make line)</div>
<div class="line">Convert to maks</div>
<div class="line">Add mask to PIL</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>**kwargs</strong> : dictionary</p>
<blockquote>
<div><p>Any of Figure.__init__() parameters</p>
</div></blockquote>
<p><strong>latGrid</strong> : numpy array</p>
<blockquote>
<div><p>array with values of latitudes</p>
</div></blockquote>
<p><strong>lonGrid</strong> : numpy array</p>
<blockquote>
<div><p>array with values of longitudes</p>
</div></blockquote>
<p><strong>nGridLines</strong> : int</p>
<blockquote>
<div><p>number of lines to draw</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.pilImg</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Figure.add_latlon_labels">
<tt class="descname">add_latlon_labels</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure.add_latlon_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Add lat/lon labels along upper and left side</p>
<div class="line-block">
<div class="line">Compute step of lables</div>
<div class="line">Get lat/lon for these labels from latGrid, lonGrid</div>
<div class="line">Print lables to PIL</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>**kwargs</strong> : dictionary</p>
<blockquote>
<div><p>Any of Figure.__init__() parameters</p>
</div></blockquote>
<p><strong>latGrid</strong> : numpy array</p>
<p><strong>lonGrid</strong> : numpy array</p>
<p><strong>latlonLabels</strong> : int</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.pilImg</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Figure.add_logo">
<tt class="descname">add_logo</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure.add_logo" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert logo into the PIL image</p>
<div class="line-block">
<div class="line">Read logo from file as PIL</div>
<div class="line">Resize to the given size</div>
<div class="line">Pan using the given location</div>
<div class="line">Paste into pilImg</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>**kwargs</strong> : dictionary</p>
<blockquote>
<div><p>Any of Figure.__init__() parameters</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.pilImg</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Figure.apply_logarithm">
<tt class="descname">apply_logarithm</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure.apply_logarithm" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a tone curve to the array</p>
<p>After the normalization of the values from 0 to 1, logarithm is
applied. Then the values are converted to the normal scale.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>**kwargs</strong> : dictionary</p>
<blockquote>
<div><p>Any of Figure.__init__() parameters</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.array</strong> : numpy array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Figure.apply_mask">
<tt class="descname">apply_mask</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure.apply_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply mask for coloring land, clouds, etc</p>
<p>If mask_array and mask_lut are provided as input parameters.
The pixels in self.array which have index equal to mask_lut kay
in mask_array will have color equal to mask_lut value</p>
<p>apply_mask should be called only after convert_palettesize
(i.e. to uint8 data)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>**kwargs</strong> : dictionary</p>
<blockquote>
<div><p>Any of Figure.__init__() parameters</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.array</strong> : numpy array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Figure.clim_from_histogram">
<tt class="descname">clim_from_histogram</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure.clim_from_histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate min and max pixel values from histogram</p>
<div class="line-block">
<div class="line">if ratio=1.0, simply the minimum and maximum values are returned.</div>
<div class="line">if 0 &lt; ratio &lt; 1.0, get the histogram of the pixel values.</div>
<div class="line">Then get rid of (1.0-ratio)/2 from the both sides and
return the minimum and maximum values.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>**kwargs</strong> : dictionary</p>
<blockquote>
<div><p>Any of Figure.__init__() parameters</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>clim</strong> : numpy array 2D ((3x2) or (1x2))</p>
<blockquote class="last">
<div><p>minimum and maximum pixel values for each band</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Figure.clip">
<tt class="descname">clip</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure.clip" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert self.array to values between cmin and cmax</p>
<div class="line-block">
<div class="line">if pixel value &lt; cmin, replaced to cmin.</div>
<div class="line">if pixel value &gt; cmax, replaced to cmax.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>**kwargs</strong> : dictionary</p>
<blockquote>
<div><p>Any of Figure.__init__() parameters</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.array</strong> : numpy array</p>
<p class="last"><strong>self.cmin, self.cmax</strong> : allowed min/max values</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Figure.convert_palettesize">
<tt class="descname">convert_palettesize</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure.convert_palettesize" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert self.array to palette color size in uint8</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>**kwargs</strong> : dictionary</p>
<blockquote>
<div><p>Any of Figure.__init__() parameters</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.array</strong> : numpy array (=&gt;uint8)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Figure.create_legend">
<tt class="descname">create_legend</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure.create_legend" title="Permalink to this definition">¶</a></dt>
<dd><p>self.legend is replaced from None to PIL image</p>
<p>PIL image includes colorbar, caption, and titleString.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>**kwargs</strong> : dictionary</p>
<blockquote>
<div><p>Any of Figure.__init__() parameters</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.legend</strong> : PIL image</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Figure.create_pilImage">
<tt class="descname">create_pilImage</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure.create_pilImage" title="Permalink to this definition">¶</a></dt>
<dd><p>self.create_pilImage is replaced from None to PIL image</p>
<div class="line-block">
<div class="line">If three images are given, create a image with RGB mode.</div>
<div class="line-block">
<div class="line">if self.pilImgLegend is not None, it is pasted.</div>
</div>
<div class="line">If one image is given, create a image with P(palette) mode.</div>
<div class="line-block">
<div class="line">if self.pilImgLegend is not None,
self.array is extended before create the pilImag and
then paste pilImgLegend onto it.</div>
</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>**kwargs</strong> : dictionary</p>
<blockquote>
<div><p>Any of Figure.__init__() parameters</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.pilImg</strong> : PIL image</p>
<blockquote>
<div><p>PIL image with / without the legend</p>
</div></blockquote>
<p class="last"><strong>self.array</strong> : replace to None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Figure.process">
<tt class="descname">process</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure.process" title="Permalink to this definition">¶</a></dt>
<dd><p>Do all common operations for preparation of a figure for saving</p>
<ol class="arabic simple">
<li>Modify default values of parameters by the provided ones (if any)</li>
<li>Clip to min/max</li>
<li>Apply logarithm if required</li>
<li>Convert data to uint8</li>
<li>Create palette</li>
<li>Apply mask for colouring land, clouds, etc if required</li>
<li>Create legend if required</li>
<li>Create PIL image</li>
<li>Add logo if required</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>**kwargs</strong> : dictionary</p>
<blockquote>
<div><p>Any of Figure.__init__() parameters</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.d</strong></p>
<p><strong>self.array</strong></p>
<p><strong>self.palette</strong></p>
<p><strong>self.pilImgLegend</strong></p>
<p class="last"><strong>self.pilImg</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Figure.save">
<tt class="descname">save</tt><big>(</big><em>fileName</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save self.pilImg to a physical file</p>
<p>If given extension is JPG, convert the image mode from Palette to RGB</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : string</p>
<blockquote>
<div><p>name of outputfile</p>
</div></blockquote>
<p><strong>Any of Figure.__init__() parameters</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.pilImg</strong> : None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nansat.Nansatmap">
<em class="property">class </em><tt class="descclassname">nansat.</tt><tt class="descname">Nansatmap</tt><big>(</big><em>domain</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Set attributes</p>
<p>Get proj4 from the given domain and convert the proj4 projection to
the basemap projection.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>domain</strong> : domain object</p>
<p><strong>kwargs</strong> : dictionary</p>
<blockquote>
<div><p>parameters that are used for all operations.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.fig</strong> : figure</p>
<blockquote>
<div><p>matplotlib.pyplot.figure</p>
</div></blockquote>
<p><strong>self.colorbar</strong> : boolean</p>
<blockquote>
<div><p>if colorbar is True, it is possible to put colorbar.
e.g. contour_plots(contour_style=&#8217;fill&#8217;), put_color()</p>
</div></blockquote>
<p><strong>self.mpl</strong> : list</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>elements are matplotlib.contour.QuadContourSet instance,</dt>
<dd><p class="first last">matplotlib.quiver.Quiver instance or
matplotlib.collections.QuadMesh object</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>see also : <a class="reference external" href="http://matplotlib.org/basemap/api/basemap_api.html">http://matplotlib.org/basemap/api/basemap_api.html</a></p>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="62%" />
<col width="38%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>colorbar</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>convolve_weights</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>lat</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>lon</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>x</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>y</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">__call__</span></tt>(x,&nbsp;y[,&nbsp;inverse])</td>
<td>Calling a Basemap class instance with the arguments lon, lat will convert lon/lat (in degrees) to x/y map projection coordinates (in meters).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.add_colorbar" title="nansat.Nansatmap.add_colorbar"><tt class="xref py py-obj docutils literal"><span class="pre">add_colorbar</span></tt></a>([fontsize])</td>
<td>Add color bar</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.arcgisimage" title="nansat.Nansatmap.arcgisimage"><tt class="xref py py-obj docutils literal"><span class="pre">arcgisimage</span></tt></a>([server,&nbsp;service,&nbsp;xpixels,&nbsp;...])</td>
<td>Retrieve an image using the ArcGIS Server REST API and display it on the map.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.barbs" title="nansat.Nansatmap.barbs"><tt class="xref py py-obj docutils literal"><span class="pre">barbs</span></tt></a>(x,&nbsp;y,&nbsp;u,&nbsp;v,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Make a wind barb plot (u, v) with on the map.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.bluemarble" title="nansat.Nansatmap.bluemarble"><tt class="xref py py-obj docutils literal"><span class="pre">bluemarble</span></tt></a>([ax,&nbsp;scale])</td>
<td>display blue marble image (from <a class="reference external" href="http://visibleearth.nasa.gov">http://visibleearth.nasa.gov</a>)</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">cmap</span></tt></td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.contour" title="nansat.Nansatmap.contour"><tt class="xref py py-obj docutils literal"><span class="pre">contour</span></tt></a>(data[,&nbsp;v,&nbsp;smooth,&nbsp;mode,&nbsp;label])</td>
<td>Draw lined contour plots</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.contourf" title="nansat.Nansatmap.contourf"><tt class="xref py py-obj docutils literal"><span class="pre">contourf</span></tt></a>(data[,&nbsp;v,&nbsp;smooth,&nbsp;mode])</td>
<td>Draw filled contour plots</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.draw_continents" title="nansat.Nansatmap.draw_continents"><tt class="xref py py-obj docutils literal"><span class="pre">draw_continents</span></tt></a>(**kwargs)</td>
<td>Draw continents</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.drawcoastlines" title="nansat.Nansatmap.drawcoastlines"><tt class="xref py py-obj docutils literal"><span class="pre">drawcoastlines</span></tt></a>([linewidth,&nbsp;linestyle,&nbsp;...])</td>
<td>Draw coastlines.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.drawcounties" title="nansat.Nansatmap.drawcounties"><tt class="xref py py-obj docutils literal"><span class="pre">drawcounties</span></tt></a>([linewidth,&nbsp;linestyle,&nbsp;color,&nbsp;...])</td>
<td>Draw county boundaries in US.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.drawcountries" title="nansat.Nansatmap.drawcountries"><tt class="xref py py-obj docutils literal"><span class="pre">drawcountries</span></tt></a>([linewidth,&nbsp;linestyle,&nbsp;color,&nbsp;...])</td>
<td>Draw country boundaries.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.drawgreatcircle" title="nansat.Nansatmap.drawgreatcircle"><tt class="xref py py-obj docutils literal"><span class="pre">drawgreatcircle</span></tt></a>(lon1,&nbsp;lat1,&nbsp;lon2,&nbsp;lat2[,&nbsp;del_s])</td>
<td>Draw a great circle on the map from the longitude-latitude</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.drawgrid" title="nansat.Nansatmap.drawgrid"><tt class="xref py py-obj docutils literal"><span class="pre">drawgrid</span></tt></a>([fontsize,&nbsp;lat_num,&nbsp;lon_num,&nbsp;...])</td>
<td>Draw and label parallels (lat and lon lines) for values (in degrees)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.drawlsmask" title="nansat.Nansatmap.drawlsmask"><tt class="xref py py-obj docutils literal"><span class="pre">drawlsmask</span></tt></a>([land_color,&nbsp;ocean_color,&nbsp;...])</td>
<td>Draw land-sea mask image.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.drawmapboundary" title="nansat.Nansatmap.drawmapboundary"><tt class="xref py py-obj docutils literal"><span class="pre">drawmapboundary</span></tt></a>([color,&nbsp;linewidth,&nbsp;...])</td>
<td>draw boundary around map projection region, optionally</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.drawmapscale" title="nansat.Nansatmap.drawmapscale"><tt class="xref py py-obj docutils literal"><span class="pre">drawmapscale</span></tt></a>(lon,&nbsp;lat,&nbsp;lon0,&nbsp;lat0,&nbsp;length[,&nbsp;...])</td>
<td>Draw a map scale at <tt class="docutils literal"><span class="pre">lon,lat</span></tt> of length <tt class="docutils literal"><span class="pre">length</span></tt> representing distance in the map projection coordinates at <tt class="docutils literal"><span class="pre">lon0,lat0</span></tt>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.drawmeridians" title="nansat.Nansatmap.drawmeridians"><tt class="xref py py-obj docutils literal"><span class="pre">drawmeridians</span></tt></a>(meridians[,&nbsp;color,&nbsp;linewidth,&nbsp;...])</td>
<td>Draw and label meridians (longitude lines) for values (in degrees) given in the sequence <tt class="docutils literal"><span class="pre">meridians</span></tt>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.drawparallels" title="nansat.Nansatmap.drawparallels"><tt class="xref py py-obj docutils literal"><span class="pre">drawparallels</span></tt></a>(circles[,&nbsp;color,&nbsp;linewidth,&nbsp;...])</td>
<td>Draw and label parallels (latitude lines) for values (in degrees) given in the sequence <tt class="docutils literal"><span class="pre">circles</span></tt>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.drawrivers" title="nansat.Nansatmap.drawrivers"><tt class="xref py py-obj docutils literal"><span class="pre">drawrivers</span></tt></a>([linewidth,&nbsp;linestyle,&nbsp;color,&nbsp;...])</td>
<td>Draw major rivers.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.drawstates" title="nansat.Nansatmap.drawstates"><tt class="xref py py-obj docutils literal"><span class="pre">drawstates</span></tt></a>([linewidth,&nbsp;linestyle,&nbsp;color,&nbsp;...])</td>
<td>Draw state boundaries in Americas.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.etopo" title="nansat.Nansatmap.etopo"><tt class="xref py py-obj docutils literal"><span class="pre">etopo</span></tt></a>([ax,&nbsp;scale])</td>
<td>display etopo relief image (from</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.fillcontinents" title="nansat.Nansatmap.fillcontinents"><tt class="xref py py-obj docutils literal"><span class="pre">fillcontinents</span></tt></a>([color,&nbsp;lake_color,&nbsp;ax,&nbsp;...])</td>
<td>Fill continents.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.gcpoints" title="nansat.Nansatmap.gcpoints"><tt class="xref py py-obj docutils literal"><span class="pre">gcpoints</span></tt></a>(lon1,&nbsp;lat1,&nbsp;lon2,&nbsp;lat2,&nbsp;npoints)</td>
<td>compute <tt class="docutils literal"><span class="pre">points</span></tt> points along a great circle with endpoints</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.hexbin" title="nansat.Nansatmap.hexbin"><tt class="xref py py-obj docutils literal"><span class="pre">hexbin</span></tt></a>(x,&nbsp;y,&nbsp;**kwargs)</td>
<td>Make a hexagonal binning plot of x versus y, where x, y are 1-D sequences of the same length, N.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.imshow" title="nansat.Nansatmap.imshow"><tt class="xref py py-obj docutils literal"><span class="pre">imshow</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>Display an image over the map (see matplotlib.pyplot.imshow documentation).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.is_land" title="nansat.Nansatmap.is_land"><tt class="xref py py-obj docutils literal"><span class="pre">is_land</span></tt></a>(xpt,&nbsp;ypt)</td>
<td>Returns True if the given x,y point (in projection coordinates) is over land, False otherwise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.makegrid" title="nansat.Nansatmap.makegrid"><tt class="xref py py-obj docutils literal"><span class="pre">makegrid</span></tt></a>(nx,&nbsp;ny[,&nbsp;returnxy])</td>
<td>return arrays of shape (ny,nx) containing lon,lat coordinates of</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.nightshade" title="nansat.Nansatmap.nightshade"><tt class="xref py py-obj docutils literal"><span class="pre">nightshade</span></tt></a>(date[,&nbsp;color,&nbsp;delta,&nbsp;alpha,&nbsp;ax,&nbsp;...])</td>
<td>Shade the regions of the map that are in darkness at the time specifed by <tt class="docutils literal"><span class="pre">date</span></tt>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.pcolor" title="nansat.Nansatmap.pcolor"><tt class="xref py py-obj docutils literal"><span class="pre">pcolor</span></tt></a>(x,&nbsp;y,&nbsp;data,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Make a pseudo-color plot over the map (see matplotlib.pyplot.pcolor documentation).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.pcolormesh" title="nansat.Nansatmap.pcolormesh"><tt class="xref py py-obj docutils literal"><span class="pre">pcolormesh</span></tt></a>(data,&nbsp;**kwargs)</td>
<td>Make a pseudo-color plot over the map</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.plot" title="nansat.Nansatmap.plot"><tt class="xref py py-obj docutils literal"><span class="pre">plot</span></tt></a>(x,&nbsp;y,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Draw lines and/or markers on the map (see matplotlib.pyplot.plot documentation).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.quiver" title="nansat.Nansatmap.quiver"><tt class="xref py py-obj docutils literal"><span class="pre">quiver</span></tt></a>(dataX,&nbsp;dataY[,&nbsp;step,&nbsp;quivectors])</td>
<td>Draw quiver plots</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.readshapefile" title="nansat.Nansatmap.readshapefile"><tt class="xref py py-obj docutils literal"><span class="pre">readshapefile</span></tt></a>(shapefile,&nbsp;name[,&nbsp;drawbounds,&nbsp;...])</td>
<td>Read in shape file, optionally draw boundaries on map.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.rotate_vector" title="nansat.Nansatmap.rotate_vector"><tt class="xref py py-obj docutils literal"><span class="pre">rotate_vector</span></tt></a>(uin,&nbsp;vin,&nbsp;lons,&nbsp;lats[,&nbsp;returnxy])</td>
<td>Rotate a vector field (<tt class="docutils literal"><span class="pre">uin,vin</span></tt>) on a rectilinear grid with longitudes = <tt class="docutils literal"><span class="pre">lons</span></tt> and latitudes = <tt class="docutils literal"><span class="pre">lats</span></tt> from geographical (lat/lon) into map projection (x/y) coordinates.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.save" title="nansat.Nansatmap.save"><tt class="xref py py-obj docutils literal"><span class="pre">save</span></tt></a>(fileName[,&nbsp;landmask])</td>
<td>Draw continents and save</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.scatter" title="nansat.Nansatmap.scatter"><tt class="xref py py-obj docutils literal"><span class="pre">scatter</span></tt></a>(x,&nbsp;y,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Plot points with markers on the map (see matplotlib.pyplot.scatter documentation).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.set_axes_limits" title="nansat.Nansatmap.set_axes_limits"><tt class="xref py py-obj docutils literal"><span class="pre">set_axes_limits</span></tt></a>([ax])</td>
<td>Final step in Basemap method wrappers of Axes plotting methods:</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.shadedrelief" title="nansat.Nansatmap.shadedrelief"><tt class="xref py py-obj docutils literal"><span class="pre">shadedrelief</span></tt></a>([ax,&nbsp;scale])</td>
<td>display shaded relief image (from <a class="reference external" href="http://www.shadedrelief.com">http://www.shadedrelief.com</a>)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.shiftdata" title="nansat.Nansatmap.shiftdata"><tt class="xref py py-obj docutils literal"><span class="pre">shiftdata</span></tt></a>(lonsin[,&nbsp;datain,&nbsp;lon_0])</td>
<td>Shift longitudes (and optionally data) so that they match map projection region.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.smooth" title="nansat.Nansatmap.smooth"><tt class="xref py py-obj docutils literal"><span class="pre">smooth</span></tt></a>(idata,&nbsp;mode,&nbsp;**kwargs)</td>
<td>Smooth data for contour() and contourf()</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.streamplot" title="nansat.Nansatmap.streamplot"><tt class="xref py py-obj docutils literal"><span class="pre">streamplot</span></tt></a>(x,&nbsp;y,&nbsp;u,&nbsp;v,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Draws streamlines of a vector flow.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.tissot" title="nansat.Nansatmap.tissot"><tt class="xref py py-obj docutils literal"><span class="pre">tissot</span></tt></a>(lon_0,&nbsp;lat_0,&nbsp;radius_deg,&nbsp;npts[,&nbsp;ax])</td>
<td>Draw a polygon centered at <tt class="docutils literal"><span class="pre">lon_0,lat_0</span></tt>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.transform_scalar" title="nansat.Nansatmap.transform_scalar"><tt class="xref py py-obj docutils literal"><span class="pre">transform_scalar</span></tt></a>(datin,&nbsp;lons,&nbsp;lats,&nbsp;nx,&nbsp;ny)</td>
<td>Interpolate a scalar field (<tt class="docutils literal"><span class="pre">datin</span></tt>) from a lat/lon grid with longitudes = <tt class="docutils literal"><span class="pre">lons</span></tt> and latitudes = <tt class="docutils literal"><span class="pre">lats</span></tt> to a <tt class="docutils literal"><span class="pre">ny</span></tt> by <tt class="docutils literal"><span class="pre">nx</span></tt> map projection grid.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.transform_vector" title="nansat.Nansatmap.transform_vector"><tt class="xref py py-obj docutils literal"><span class="pre">transform_vector</span></tt></a>(uin,&nbsp;vin,&nbsp;lons,&nbsp;lats,&nbsp;nx,&nbsp;ny)</td>
<td>Rotate and interpolate a vector field (<tt class="docutils literal"><span class="pre">uin,vin</span></tt>) from a lat/lon grid with longitudes = <tt class="docutils literal"><span class="pre">lons</span></tt> and latitudes = <tt class="docutils literal"><span class="pre">lats</span></tt> to a <tt class="docutils literal"><span class="pre">ny</span></tt> by <tt class="docutils literal"><span class="pre">nx</span></tt> map projection grid.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Nansatmap.warpimage" title="nansat.Nansatmap.warpimage"><tt class="xref py py-obj docutils literal"><span class="pre">warpimage</span></tt></a>([image,&nbsp;scale])</td>
<td>Display an image (filename given by <tt class="docutils literal"><span class="pre">image</span></tt> keyword) as a map background.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Nansatmap.wmsimage" title="nansat.Nansatmap.wmsimage"><tt class="xref py py-obj docutils literal"><span class="pre">wmsimage</span></tt></a>(server[,&nbsp;xpixels,&nbsp;ypixels,&nbsp;format,&nbsp;...])</td>
<td>Retrieve an image using from a WMS server using the Open Geospatial Consortium (OGC) standard interface and display on the map.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nansat.Nansatmap.add_colorbar">
<tt class="descname">add_colorbar</tt><big>(</big><em>fontsize=6</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.add_colorbar" title="Permalink to this definition">¶</a></dt>
<dd><p>Add color bar</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fontsize</strong> : int</p>
<blockquote>
<div><p>Parameters for matplotlib.pyplot.colorbar</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.fig</strong> : Adds colorbar</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.arcgisimage">
<tt class="descname">arcgisimage</tt><big>(</big><em>server='http://server.arcgisonline.com/ArcGIS'</em>, <em>service='ESRI_Imagery_World_2D'</em>, <em>xpixels=400</em>, <em>ypixels=None</em>, <em>dpi=96</em>, <em>verbose=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.arcgisimage" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve an image using the ArcGIS Server REST API and display it on
the map. In order to use this method, the Basemap instance must be
created using the <tt class="docutils literal"><span class="pre">epsg</span></tt> keyword to define the map projection, unless
the <tt class="docutils literal"><span class="pre">cyl</span></tt> projection is used (in which case the epsg code 4326 is
assumed).</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keywords</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>server</td>
<td>web map server URL (default
<a class="reference external" href="http://server.arcgisonline.com/ArcGIS">http://server.arcgisonline.com/ArcGIS</a>).</td>
</tr>
<tr class="row-odd"><td>service</td>
<td>service (image type) hosted on server (default
ESRI_Imagery_World_2D, which is NASA &#8216;Blue Marble&#8217;
image).</td>
</tr>
<tr class="row-even"><td>xpixels</td>
<td>requested number of image pixels in x-direction
(default 400).</td>
</tr>
<tr class="row-odd"><td>ypixels</td>
<td>requested number of image pixels in y-direction.
Default (None) is to infer the number from
from xpixels and the aspect ratio of the
map projection region.</td>
</tr>
<tr class="row-even"><td>dpi</td>
<td>The device resolution of the exported image (dots per
inch, default 96).</td>
</tr>
<tr class="row-odd"><td>verbose</td>
<td>if True, print URL used to retrieve image (default
False).</td>
</tr>
</tbody>
</table>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>returns a matplotlib.image.AxesImage instance.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.barbs">
<tt class="descname">barbs</tt><big>(</big><em>x</em>, <em>y</em>, <em>u</em>, <em>v</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.barbs" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a wind barb plot (u, v) with on the map.
(see matplotlib.pyplot.barbs documentation).</p>
<p>If <tt class="docutils literal"><span class="pre">latlon</span></tt> keyword is set to True, x,y are intrepreted as
longitude and latitude in degrees.  Data and longitudes are
automatically shifted to match map projection region for cylindrical
and pseudocylindrical projections, and x,y are transformed to map
projection coordinates. If <tt class="docutils literal"><span class="pre">latlon</span></tt> is False (default), x and y
are assumed to be map projection coordinates.</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>Other *args and **kwargs passed on to matplotlib.pyplot.barbs</p>
<p>Returns two matplotlib.axes.Barbs instances, one for the Northern
Hemisphere and one for the Southern Hemisphere.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.bluemarble">
<tt class="descname">bluemarble</tt><big>(</big><em>ax=None</em>, <em>scale=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.bluemarble" title="Permalink to this definition">¶</a></dt>
<dd><p>display blue marble image (from <a class="reference external" href="http://visibleearth.nasa.gov">http://visibleearth.nasa.gov</a>)
as map background.
Default image size is 5400x2700, which can be quite slow and
use quite a bit of memory.  The <tt class="docutils literal"><span class="pre">scale</span></tt> keyword can be used
to downsample the image (<tt class="docutils literal"><span class="pre">scale=0.5</span></tt> downsamples to 2700x1350).</p>
<p>**kwargs passed on to <a class="reference internal" href="#nansat.Nansatmap.imshow" title="nansat.Nansatmap.imshow"><tt class="xref py py-meth docutils literal"><span class="pre">imshow()</span></tt></a>.</p>
<p>returns a matplotlib.image.AxesImage instance.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.contour">
<tt class="descname">contour</tt><big>(</big><em>data</em>, <em>v=None</em>, <em>smooth=False</em>, <em>mode='gaussian'</em>, <em>label=True</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.contour" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw lined contour plots</p>
<p>If smooth is True, data is smoothed. Then draw lined contour.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : numpy 2D array</p>
<blockquote>
<div><p>Input data</p>
</div></blockquote>
<p><strong>v</strong> : list with values</p>
<blockquote>
<div><p>draw contour lines at the values specified in sequence v</p>
</div></blockquote>
<p><strong>smooth</strong> : Boolean</p>
<blockquote>
<div><p>Apply smoothing?</p>
</div></blockquote>
<p><strong>mode</strong> : string</p>
<blockquote>
<div><div class="line-block">
<div class="line">mname of smoothing algorithm to apply</div>
<div class="line">e.g.) &#8216;gaussian&#8217;, &#8216;spline&#8217;, &#8216;fourier&#8217;, &#8216;convolve&#8217;</div>
</div>
</div></blockquote>
<p><strong>label</strong> : boolean</p>
<blockquote>
<div><p>Add lables?</p>
</div></blockquote>
<p><strong>**kwargs:</strong></p>
<blockquote>
<div><div class="line-block">
<div class="line">Optional parameters for Nansatmap.smooth()</div>
<div class="line">Optional parameters for pyplot.contour().</div>
<div class="line">Optional parameters for pyplot.clabel()</div>
</div>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.mpl</strong> : list</p>
<blockquote class="last">
<div><p>append QuadContourSet instance</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.contourf">
<tt class="descname">contourf</tt><big>(</big><em>data</em>, <em>v=None</em>, <em>smooth=False</em>, <em>mode='gaussian'</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.contourf" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw filled contour plots</p>
<p>If smooth is True, data is smoothed. Then draw filled contour.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : numpy 2D array</p>
<blockquote>
<div><p>Input data</p>
</div></blockquote>
<p><strong>v</strong> : list with values</p>
<blockquote>
<div><p>draw contour lines at the values specified in sequence v</p>
</div></blockquote>
<p><strong>smooth</strong> : Boolean</p>
<blockquote>
<div><p>Apply smoothing?</p>
</div></blockquote>
<p><strong>mode</strong> : string</p>
<blockquote>
<div><div class="line-block">
<div class="line">name of smoothing algorithm to apply</div>
<div class="line">e.g.) &#8216;gaussian&#8217;, &#8216;spline&#8217;, &#8216;fourier&#8217;, &#8216;convolve&#8217;</div>
</div>
</div></blockquote>
<p><strong>**kwargs:</strong></p>
<blockquote>
<div><div class="line-block">
<div class="line">cmap : colormap (e.g. cm.jet)</div>
<div class="line">Optional parameters for Nansatmap.smooth()</div>
<div class="line">Optional parameters for pyplot.contourf().</div>
</div>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.mpl</strong> : list</p>
<blockquote class="last">
<div><p>append QuadContourSet instance</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.draw_continents">
<tt class="descname">draw_continents</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.draw_continents" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw continents</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>**kwargs</strong> : Parameters for basemap.fillcontinents</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.drawcoastlines">
<tt class="descname">drawcoastlines</tt><big>(</big><em>linewidth=1.0</em>, <em>linestyle='solid'</em>, <em>color='k'</em>, <em>antialiased=1</em>, <em>ax=None</em>, <em>zorder=None</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.drawcoastlines" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw coastlines.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>linewidth</td>
<td>coastline width (default 1.)</td>
</tr>
<tr class="row-odd"><td>linestyle</td>
<td>coastline linestyle (default solid)</td>
</tr>
<tr class="row-even"><td>color</td>
<td>coastline color (default black)</td>
</tr>
<tr class="row-odd"><td>antialiased</td>
<td>antialiasing switch for coastlines (default True).</td>
</tr>
<tr class="row-even"><td>ax</td>
<td>axes instance (overrides default axes instance)</td>
</tr>
<tr class="row-odd"><td>zorder</td>
<td>sets the zorder for the coastlines (if not specified,
uses default zorder for
matplotlib.patches.LineCollections).</td>
</tr>
</tbody>
</table>
<p>returns a matplotlib.patches.LineCollection object.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.drawcounties">
<tt class="descname">drawcounties</tt><big>(</big><em>linewidth=0.1</em>, <em>linestyle='solid'</em>, <em>color='k'</em>, <em>antialiased=1</em>, <em>ax=None</em>, <em>zorder=None</em>, <em>drawbounds=False</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.drawcounties" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw county boundaries in US. The county boundary shapefile
originates with the NOAA Coastal Geospatial Data Project
(<a class="reference external" href="http://coastalgeospatial.noaa.gov/data_gis.html">http://coastalgeospatial.noaa.gov/data_gis.html</a>).</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>linewidth</td>
<td>county boundary line width (default 0.1)</td>
</tr>
<tr class="row-odd"><td>linestyle</td>
<td>coastline linestyle (default solid)</td>
</tr>
<tr class="row-even"><td>color</td>
<td>county boundary line color (default black)</td>
</tr>
<tr class="row-odd"><td>antialiased</td>
<td>antialiasing switch for county boundaries
(default True).</td>
</tr>
<tr class="row-even"><td>ax</td>
<td>axes instance (overrides default axes instance)</td>
</tr>
<tr class="row-odd"><td>zorder</td>
<td>sets the zorder for the county boundaries (if not
specified, uses default zorder for
matplotlib.patches.LineCollections).</td>
</tr>
</tbody>
</table>
<p>returns a matplotlib.patches.LineCollection object.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.drawcountries">
<tt class="descname">drawcountries</tt><big>(</big><em>linewidth=0.5</em>, <em>linestyle='solid'</em>, <em>color='k'</em>, <em>antialiased=1</em>, <em>ax=None</em>, <em>zorder=None</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.drawcountries" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw country boundaries.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>linewidth</td>
<td>country boundary line width (default 0.5)</td>
</tr>
<tr class="row-odd"><td>linestyle</td>
<td>coastline linestyle (default solid)</td>
</tr>
<tr class="row-even"><td>color</td>
<td>country boundary line color (default black)</td>
</tr>
<tr class="row-odd"><td>antialiased</td>
<td>antialiasing switch for country boundaries (default
True).</td>
</tr>
<tr class="row-even"><td>ax</td>
<td>axes instance (overrides default axes instance)</td>
</tr>
<tr class="row-odd"><td>zorder</td>
<td>sets the zorder for the country boundaries (if not
specified uses default zorder for
matplotlib.patches.LineCollections).</td>
</tr>
</tbody>
</table>
<p>returns a matplotlib.patches.LineCollection object.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.drawgreatcircle">
<tt class="descname">drawgreatcircle</tt><big>(</big><em>lon1</em>, <em>lat1</em>, <em>lon2</em>, <em>lat2</em>, <em>del_s=100.0</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.drawgreatcircle" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a great circle on the map from the longitude-latitude
pair <tt class="docutils literal"><span class="pre">lon1,lat1</span></tt> to <tt class="docutils literal"><span class="pre">lon2,lat2</span></tt></p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>del_s</td>
<td>points on great circle computed every del_s kilometers
(default 100).</td>
</tr>
<tr class="row-odd"><td>**kwargs</td>
<td>other keyword arguments are passed on to <a class="reference internal" href="#nansat.Nansatmap.plot" title="nansat.Nansatmap.plot"><tt class="xref py py-meth docutils literal"><span class="pre">plot()</span></tt></a>
method of Basemap instance.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Cannot handle situations in which the great circle intersects
the edge of the map projection domain, and then re-enters the domain.</p>
</div>
<p>Returns a matplotlib.lines.Line2D object.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.drawgrid">
<tt class="descname">drawgrid</tt><big>(</big><em>fontsize=10, lat_num=5, lon_num=5, lat_labels=[True, False, False, False], lon_labels=[False, False, True, False]</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.drawgrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw and label parallels (lat and lon lines) for values (in degrees)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fontsize</strong> : int</p>
<p><strong>lat_num</strong> : int</p>
<blockquote>
<div><p>Number of latitude lables</p>
</div></blockquote>
<p><strong>lon_num :</strong></p>
<blockquote>
<div><p>Number of longitude lables</p>
</div></blockquote>
<p><strong>lat_labels</strong> : list of Bool</p>
<blockquote>
<div><p>Location of latitude labels</p>
</div></blockquote>
<p><strong>lon_labels</strong> : list of Bool</p>
<blockquote class="last">
<div><p>Location of longitude labels</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>See also: Basemap.drawparallels(), Basemap.drawmeridians()</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.drawlsmask">
<tt class="descname">drawlsmask</tt><big>(</big><em>land_color='0.8'</em>, <em>ocean_color='w'</em>, <em>lsmask=None</em>, <em>lsmask_lons=None</em>, <em>lsmask_lats=None</em>, <em>lakes=True</em>, <em>resolution='l'</em>, <em>grid=5</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.drawlsmask" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw land-sea mask image.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The land-sea mask image cannot be overlaid on top
of other images, due to limitations in matplotlib image handling
(you can&#8217;t specify the zorder of an image).</p>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keywords</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>land_color</td>
<td>desired land color (color name or rgba tuple).
Default gray (&#8220;0.8&#8221;).</td>
</tr>
<tr class="row-odd"><td>ocean_color</td>
<td>desired water color (color name or rgba tuple).
Default white.</td>
</tr>
<tr class="row-even"><td>lsmask</td>
<td>An array of 0&#8217;s for ocean pixels, 1&#8217;s for
land pixels and 2&#8217;s for lake/pond pixels.
Default is None
(default 5-minute resolution land-sea mask is used).</td>
</tr>
<tr class="row-odd"><td>lakes</td>
<td>Plot lakes and ponds (Default True)</td>
</tr>
<tr class="row-even"><td>lsmask_lons</td>
<td>1d array of longitudes for lsmask (ignored
if lsmask is None). Longitudes must be ordered
from -180 W eastward.</td>
</tr>
<tr class="row-odd"><td>lsmask_lats</td>
<td>1d array of latitudes for lsmask (ignored
if lsmask is None). Latitudes must be ordered
from -90 S northward.</td>
</tr>
<tr class="row-even"><td>resolution</td>
<td>gshhs coastline resolution used to define land/sea
mask (default &#8216;l&#8217;, available &#8216;c&#8217;,&#8217;l&#8217;,&#8217;i&#8217;,&#8217;h&#8217; or &#8216;f&#8217;)</td>
</tr>
<tr class="row-odd"><td>grid</td>
<td>land/sea mask grid spacing in minutes (Default 5;
10, 2.5 and 1.25 are also available).</td>
</tr>
<tr class="row-even"><td>**kwargs</td>
<td>extra keyword arguments passed on to
<a class="reference internal" href="#nansat.Nansatmap.imshow" title="nansat.Nansatmap.imshow"><tt class="xref py py-meth docutils literal"><span class="pre">imshow()</span></tt></a></td>
</tr>
</tbody>
</table>
<p>If any of the lsmask, lsmask_lons or lsmask_lats keywords are not
set, the built in GSHHS land-sea mask datasets are used.</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>returns a matplotlib.image.AxesImage instance.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.drawmapboundary">
<tt class="descname">drawmapboundary</tt><big>(</big><em>color='k'</em>, <em>linewidth=1.0</em>, <em>fill_color=None</em>, <em>zorder=None</em>, <em>ax=None</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.drawmapboundary" title="Permalink to this definition">¶</a></dt>
<dd><p>draw boundary around map projection region, optionally
filling interior of region.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>linewidth</td>
<td>line width for boundary (default 1.)</td>
</tr>
<tr class="row-odd"><td>color</td>
<td>color of boundary line (default black)</td>
</tr>
<tr class="row-even"><td>fill_color</td>
<td>fill the map region background with this
color (default is to fill with axis
background color). If set to the string
&#8216;none&#8217;, no filling is done.</td>
</tr>
<tr class="row-odd"><td>zorder</td>
<td>sets the zorder for filling map background
(default 0).</td>
</tr>
<tr class="row-even"><td>ax</td>
<td>axes instance to use
(default None, use default axes instance).</td>
</tr>
</tbody>
</table>
<p>returns matplotlib.collections.PatchCollection representing map boundary.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.drawmapscale">
<tt class="descname">drawmapscale</tt><big>(</big><em>lon</em>, <em>lat</em>, <em>lon0</em>, <em>lat0</em>, <em>length</em>, <em>barstyle='simple'</em>, <em>units='km'</em>, <em>fontsize=9</em>, <em>yoffset=None</em>, <em>labelstyle='simple'</em>, <em>fontcolor='k'</em>, <em>fillcolor1='w'</em>, <em>fillcolor2='k'</em>, <em>ax=None</em>, <em>format='%d'</em>, <em>zorder=None</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.drawmapscale" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a map scale at <tt class="docutils literal"><span class="pre">lon,lat</span></tt> of length <tt class="docutils literal"><span class="pre">length</span></tt>
representing distance in the map
projection coordinates at <tt class="docutils literal"><span class="pre">lon0,lat0</span></tt>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keywords</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>units</td>
<td>the units of the length argument (Default km).</td>
</tr>
<tr class="row-odd"><td>barstyle</td>
<td><tt class="docutils literal"><span class="pre">simple</span></tt> or <tt class="docutils literal"><span class="pre">fancy</span></tt> (roughly corresponding
to the styles provided by Generic Mapping Tools).
Default <tt class="docutils literal"><span class="pre">simple</span></tt>.</td>
</tr>
<tr class="row-even"><td>fontsize</td>
<td>for map scale annotations, default 9.</td>
</tr>
<tr class="row-odd"><td>color</td>
<td>for map scale annotations, default black.</td>
</tr>
<tr class="row-even"><td>labelstype</td>
<td><tt class="docutils literal"><span class="pre">simple</span></tt> (default) or <tt class="docutils literal"><span class="pre">fancy</span></tt>.  For
<tt class="docutils literal"><span class="pre">fancy</span></tt> the map scale factor (ratio betwee
the actual distance and map projection distance
at lon0,lat0) and the value of lon0,lat0 are also
displayed on the top of the scale bar. For
<tt class="docutils literal"><span class="pre">simple</span></tt>, just the units are display on top
and the distance below the scale bar.
If equal to False, plot an empty label.</td>
</tr>
<tr class="row-odd"><td>format</td>
<td>a string formatter to format numeric values</td>
</tr>
<tr class="row-even"><td>yoffset</td>
<td>yoffset controls how tall the scale bar is,
and how far the annotations are offset from the
scale bar.  Default is 0.02 times the height of
the map (0.02*(self.ymax-self.ymin)).</td>
</tr>
<tr class="row-odd"><td>fillcolor1(2)</td>
<td>colors of the alternating filled regions
(default white and black).  Only relevant for
&#8216;fancy&#8217; barstyle.</td>
</tr>
<tr class="row-even"><td>zorder</td>
<td>sets the zorder for the map scale.</td>
</tr>
</tbody>
</table>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.drawmeridians">
<tt class="descname">drawmeridians</tt><big>(</big><em>meridians, color='k', linewidth=1.0, zorder=None, dashes=[1, 1], labels=[0, 0, 0, 0], labelstyle=None, fmt='%g', xoffset=None, yoffset=None, ax=None, latmax=None, **kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.drawmeridians" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw and label meridians (longitude lines) for values (in degrees)
given in the sequence <tt class="docutils literal"><span class="pre">meridians</span></tt>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>color</td>
<td>color to draw meridians (default black).</td>
</tr>
<tr class="row-odd"><td>linewidth</td>
<td>line width for meridians (default 1.)</td>
</tr>
<tr class="row-even"><td>zorder</td>
<td>sets the zorder for meridians (if not specified,
uses default zorder for matplotlib.lines.Line2D
objects).</td>
</tr>
<tr class="row-odd"><td>dashes</td>
<td>dash pattern for meridians (default [1,1], i.e.
1 pixel on, 1 pixel off).</td>
</tr>
<tr class="row-even"><td>labels</td>
<td>list of 4 values (default [0,0,0,0]) that control
whether meridians are labelled where they intersect
the left, right, top or bottom of the plot. For
example labels=[1,0,0,1] will cause meridians
to be labelled where they intersect the left and
and bottom of the plot, but not the right and top.</td>
</tr>
<tr class="row-odd"><td>labelstyle</td>
<td>if set to &#8220;+/-&#8221;, east and west longitudes are
labelled with &#8220;+&#8221; and &#8220;-&#8221;, otherwise they are
labelled with &#8220;E&#8221; and &#8220;W&#8221;.</td>
</tr>
<tr class="row-even"><td>fmt</td>
<td>a format string to format the meridian labels
(default &#8216;%g&#8217;) <strong>or</strong> a function that takes a
longitude value in degrees as it&#8217;s only argument
and returns a formatted string.</td>
</tr>
<tr class="row-odd"><td>xoffset</td>
<td>label offset from edge of map in x-direction
(default is 0.01 times width of map in map
projection coordinates).</td>
</tr>
<tr class="row-even"><td>yoffset</td>
<td>label offset from edge of map in y-direction
(default is 0.01 times height of map in map
projection coordinates).</td>
</tr>
<tr class="row-odd"><td>ax</td>
<td>axes instance (overrides default axes instance)</td>
</tr>
<tr class="row-even"><td>latmax</td>
<td>absolute value of latitude to which meridians are drawn
(default is 80).</td>
</tr>
<tr class="row-odd"><td>**kwargs</td>
<td>additional keyword arguments controlling text
for labels that are passed on to
the text method of the axes instance (see
matplotlib.pyplot.text documentation).</td>
</tr>
</tbody>
</table>
<p>returns a dictionary whose keys are the meridian values, and
whose values are tuples containing lists of the
matplotlib.lines.Line2D and matplotlib.text.Text instances
associated with each meridian. Deleting an item from the
dictionary removes the correpsonding meridian from the plot.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.drawparallels">
<tt class="descname">drawparallels</tt><big>(</big><em>circles, color='k', linewidth=1.0, zorder=None, dashes=[1, 1], labels=[0, 0, 0, 0], labelstyle=None, fmt='%g', xoffset=None, yoffset=None, ax=None, latmax=None, **kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.drawparallels" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw and label parallels (latitude lines) for values (in degrees)
given in the sequence <tt class="docutils literal"><span class="pre">circles</span></tt>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>color</td>
<td>color to draw parallels (default black).</td>
</tr>
<tr class="row-odd"><td>linewidth</td>
<td>line width for parallels (default 1.)</td>
</tr>
<tr class="row-even"><td>zorder</td>
<td>sets the zorder for parallels (if not specified,
uses default zorder for matplotlib.lines.Line2D
objects).</td>
</tr>
<tr class="row-odd"><td>dashes</td>
<td>dash pattern for parallels (default [1,1], i.e.
1 pixel on, 1 pixel off).</td>
</tr>
<tr class="row-even"><td>labels</td>
<td>list of 4 values (default [0,0,0,0]) that control
whether parallels are labelled where they intersect
the left, right, top or bottom of the plot. For
example labels=[1,0,0,1] will cause parallels
to be labelled where they intersect the left and
and bottom of the plot, but not the right and top.</td>
</tr>
<tr class="row-odd"><td>labelstyle</td>
<td>if set to &#8220;+/-&#8221;, north and south latitudes are
labelled with &#8220;+&#8221; and &#8220;-&#8221;, otherwise they are
labelled with &#8220;N&#8221; and &#8220;S&#8221;.</td>
</tr>
<tr class="row-even"><td>fmt</td>
<td>a format string to format the parallel labels
(default &#8216;%g&#8217;) <strong>or</strong> a function that takes a
latitude value in degrees as it&#8217;s only argument
and returns a formatted string.</td>
</tr>
<tr class="row-odd"><td>xoffset</td>
<td>label offset from edge of map in x-direction
(default is 0.01 times width of map in map
projection coordinates).</td>
</tr>
<tr class="row-even"><td>yoffset</td>
<td>label offset from edge of map in y-direction
(default is 0.01 times height of map in map
projection coordinates).</td>
</tr>
<tr class="row-odd"><td>ax</td>
<td>axes instance (overrides default axes instance)</td>
</tr>
<tr class="row-even"><td>latmax</td>
<td>absolute value of latitude to which meridians are drawn
(default is 80).</td>
</tr>
<tr class="row-odd"><td>**kwargs</td>
<td>additional keyword arguments controlling text
for labels that are passed on to
the text method of the axes instance (see
matplotlib.pyplot.text documentation).</td>
</tr>
</tbody>
</table>
<p>returns a dictionary whose keys are the parallel values, and
whose values are tuples containing lists of the
matplotlib.lines.Line2D and matplotlib.text.Text instances
associated with each parallel. Deleting an item from the
dictionary removes the corresponding parallel from the plot.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.drawrivers">
<tt class="descname">drawrivers</tt><big>(</big><em>linewidth=0.5</em>, <em>linestyle='solid'</em>, <em>color='k'</em>, <em>antialiased=1</em>, <em>ax=None</em>, <em>zorder=None</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.drawrivers" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw major rivers.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>linewidth</td>
<td>river boundary line width (default 0.5)</td>
</tr>
<tr class="row-odd"><td>linestyle</td>
<td>coastline linestyle (default solid)</td>
</tr>
<tr class="row-even"><td>color</td>
<td>river boundary line color (default black)</td>
</tr>
<tr class="row-odd"><td>antialiased</td>
<td>antialiasing switch for river boundaries (default
True).</td>
</tr>
<tr class="row-even"><td>ax</td>
<td>axes instance (overrides default axes instance)</td>
</tr>
<tr class="row-odd"><td>zorder</td>
<td>sets the zorder for the rivers (if not
specified uses default zorder for
matplotlib.patches.LineCollections).</td>
</tr>
</tbody>
</table>
<p>returns a matplotlib.patches.LineCollection object.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.drawstates">
<tt class="descname">drawstates</tt><big>(</big><em>linewidth=0.5</em>, <em>linestyle='solid'</em>, <em>color='k'</em>, <em>antialiased=1</em>, <em>ax=None</em>, <em>zorder=None</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.drawstates" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw state boundaries in Americas.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>linewidth</td>
<td>state boundary line width (default 0.5)</td>
</tr>
<tr class="row-odd"><td>linestyle</td>
<td>coastline linestyle (default solid)</td>
</tr>
<tr class="row-even"><td>color</td>
<td>state boundary line color (default black)</td>
</tr>
<tr class="row-odd"><td>antialiased</td>
<td>antialiasing switch for state boundaries
(default True).</td>
</tr>
<tr class="row-even"><td>ax</td>
<td>axes instance (overrides default axes instance)</td>
</tr>
<tr class="row-odd"><td>zorder</td>
<td>sets the zorder for the state boundaries (if not
specified, uses default zorder for
matplotlib.patches.LineCollections).</td>
</tr>
</tbody>
</table>
<p>returns a matplotlib.patches.LineCollection object.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.etopo">
<tt class="descname">etopo</tt><big>(</big><em>ax=None</em>, <em>scale=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.etopo" title="Permalink to this definition">¶</a></dt>
<dd><p>display etopo relief image (from
<a class="reference external" href="http://www.ngdc.noaa.gov/mgg/global/global.html">http://www.ngdc.noaa.gov/mgg/global/global.html</a>)
as map background.
Default image size is 5400x2700, which can be quite slow and
use quite a bit of memory.  The <tt class="docutils literal"><span class="pre">scale</span></tt> keyword can be used
to downsample the image (<tt class="docutils literal"><span class="pre">scale=0.5</span></tt> downsamples to 5400x2700).</p>
<p>**kwargs passed on to <a class="reference internal" href="#nansat.Nansatmap.imshow" title="nansat.Nansatmap.imshow"><tt class="xref py py-meth docutils literal"><span class="pre">imshow()</span></tt></a>.</p>
<p>returns a matplotlib.image.AxesImage instance.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.fillcontinents">
<tt class="descname">fillcontinents</tt><big>(</big><em>color='0.8'</em>, <em>lake_color=None</em>, <em>ax=None</em>, <em>zorder=None</em>, <em>alpha=None</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.fillcontinents" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill continents.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>color</td>
<td>color to fill continents (default gray).</td>
</tr>
<tr class="row-odd"><td>lake_color</td>
<td>color to fill inland lakes (default axes background).</td>
</tr>
<tr class="row-even"><td>ax</td>
<td>axes instance (overrides default axes instance).</td>
</tr>
<tr class="row-odd"><td>zorder</td>
<td>sets the zorder for the continent polygons (if not
specified, uses default zorder for a Polygon patch).
Set to zero if you want to paint over the filled
continents).</td>
</tr>
<tr class="row-even"><td>alpha</td>
<td>sets alpha transparency for continent polygons</td>
</tr>
</tbody>
</table>
<p>After filling continents, lakes are re-filled with
axis background color.</p>
<p>returns a list of matplotlib.patches.Polygon objects.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.gcpoints">
<tt class="descname">gcpoints</tt><big>(</big><em>lon1</em>, <em>lat1</em>, <em>lon2</em>, <em>lat2</em>, <em>npoints</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.gcpoints" title="Permalink to this definition">¶</a></dt>
<dd><p>compute <tt class="docutils literal"><span class="pre">points</span></tt> points along a great circle with endpoints
<tt class="docutils literal"><span class="pre">(lon1,lat1)</span></tt> and <tt class="docutils literal"><span class="pre">(lon2,lat2)</span></tt>.</p>
<p>Returns arrays x,y with map projection coordinates.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.hexbin">
<tt class="descname">hexbin</tt><big>(</big><em>x</em>, <em>y</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.hexbin" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a hexagonal binning plot of x versus y, where x, y are 1-D
sequences of the same length, N. If C is None (the default), this is a
histogram of the number of occurences of the observations at
(x[i],y[i]).</p>
<p>If C is specified, it specifies values at the coordinate (x[i],y[i]).
These values are accumulated for each hexagonal bin and then reduced
according to reduce_C_function, which defaults to the numpy mean function
(np.mean). (If C is specified, it must also be a 1-D sequence of the
same length as x and y.)</p>
<p>x, y and/or C may be masked arrays, in which case only unmasked points
will be plotted.</p>
<p>(see matplotlib.pyplot.hexbin documentation).</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>Other **kwargs passed on to matplotlib.pyplot.hexbin</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.imshow">
<tt class="descname">imshow</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.imshow" title="Permalink to this definition">¶</a></dt>
<dd><p>Display an image over the map
(see matplotlib.pyplot.imshow documentation).</p>
<p><tt class="docutils literal"><span class="pre">extent</span></tt> and <tt class="docutils literal"><span class="pre">origin</span></tt> keywords set automatically so image
will be drawn over map region.</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>Other **kwargs passed on to matplotlib.pyplot.plot.</p>
<p>returns an matplotlib.image.AxesImage instance.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.is_land">
<tt class="descname">is_land</tt><big>(</big><em>xpt</em>, <em>ypt</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.is_land" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the given x,y point (in projection coordinates) is
over land, False otherwise.  The definition of land is based upon
the GSHHS coastline polygons associated with the class instance.
Points over lakes inside land regions are not counted as land points.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.makegrid">
<tt class="descname">makegrid</tt><big>(</big><em>nx</em>, <em>ny</em>, <em>returnxy=False</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.makegrid" title="Permalink to this definition">¶</a></dt>
<dd><p>return arrays of shape (ny,nx) containing lon,lat coordinates of
an equally spaced native projection grid.</p>
<p>If <tt class="docutils literal"><span class="pre">returnxy</span> <span class="pre">=</span> <span class="pre">True</span></tt>, the x,y values of the grid are returned also.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.nightshade">
<tt class="descname">nightshade</tt><big>(</big><em>date</em>, <em>color='k'</em>, <em>delta=0.25</em>, <em>alpha=0.5</em>, <em>ax=None</em>, <em>zorder=2</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.nightshade" title="Permalink to this definition">¶</a></dt>
<dd><p>Shade the regions of the map that are in darkness at the time
specifed by <tt class="docutils literal"><span class="pre">date</span></tt>.  <tt class="docutils literal"><span class="pre">date</span></tt> is a datetime instance,
assumed to be UTC.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keywords</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>color</td>
<td>color to shade night regions (default black).</td>
</tr>
<tr class="row-odd"><td>delta</td>
<td>day/night terminator is computed with a
a resolution of <tt class="docutils literal"><span class="pre">delta</span></tt> degrees (default 0.25).</td>
</tr>
<tr class="row-even"><td>alpha</td>
<td>alpha transparency for shading (default 0.5, so
map background shows through).</td>
</tr>
<tr class="row-odd"><td>zorder</td>
<td>zorder for shading (default 2).</td>
</tr>
</tbody>
</table>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>returns a matplotlib.contour.ContourSet instance.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.pcolor">
<tt class="descname">pcolor</tt><big>(</big><em>x</em>, <em>y</em>, <em>data</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.pcolor" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a pseudo-color plot over the map
(see matplotlib.pyplot.pcolor documentation).</p>
<p>If <tt class="docutils literal"><span class="pre">latlon</span></tt> keyword is set to True, x,y are intrepreted as
longitude and latitude in degrees.  Data and longitudes are
automatically shifted to match map projection region for cylindrical
and pseudocylindrical projections, and x,y are transformed to map
projection coordinates. If <tt class="docutils literal"><span class="pre">latlon</span></tt> is False (default), x and y
are assumed to be map projection coordinates.</p>
<p>If x or y are outside projection limb (i.e. they have values &gt; 1.e20)
they will be convert to masked arrays with those values masked.
As a result, those values will not be plotted.</p>
<p>If <tt class="docutils literal"><span class="pre">tri</span></tt> is set to <tt class="docutils literal"><span class="pre">True</span></tt>, an unstructured grid is assumed
(x,y,data must be 1-d) and matplotlib.pyplot.tricolor is used.</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>Other **kwargs passed on to matplotlib.pyplot.pcolor (or tricolor if
<tt class="docutils literal"><span class="pre">tri=True</span></tt>).</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.pcolormesh">
<tt class="descname">pcolormesh</tt><big>(</big><em>data</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.pcolormesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a pseudo-color plot over the map</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : numpy 2D array</p>
<blockquote>
<div><p>Input data</p>
</div></blockquote>
<p><strong>**kwargs:</strong></p>
<blockquote>
<div><p>Parameters for Basemap.pcolormesh (e.g. vmin, vmax)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.mpl</strong> : list</p>
<blockquote class="last">
<div><p>append matplotlib.collections.QuadMesh object</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.plot">
<tt class="descname">plot</tt><big>(</big><em>x</em>, <em>y</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw lines and/or markers on the map
(see matplotlib.pyplot.plot documentation).</p>
<p>If <tt class="docutils literal"><span class="pre">latlon</span></tt> keyword is set to True, x,y are intrepreted as
longitude and latitude in degrees.  Data and longitudes are
automatically shifted to match map projection region for cylindrical
and pseudocylindrical projections, and x,y are transformed to map
projection coordinates. If <tt class="docutils literal"><span class="pre">latlon</span></tt> is False (default), x and y
are assumed to be map projection coordinates.</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>Other **kwargs passed on to matplotlib.pyplot.plot.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.quiver">
<tt class="descname">quiver</tt><big>(</big><em>dataX</em>, <em>dataY</em>, <em>step=None</em>, <em>quivectors=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.quiver" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw quiver plots</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dataX</strong> :  numpy array</p>
<blockquote>
<div><p>Input data with X-component</p>
</div></blockquote>
<p><strong>dataY</strong> :  numpy array</p>
<blockquote>
<div><p>Input data with Y-component</p>
</div></blockquote>
<p><strong>step</strong> : int or (int, int)</p>
<blockquote>
<div><p>Skip &lt;step&gt; pixels along both dimentions(alternative to quivectors)</p>
</div></blockquote>
<p><strong>quivectors</strong> : int or (int,int)</p>
<blockquote>
<div><p>Number of vectors along both dimentions</p>
</div></blockquote>
<p><strong>**kwargs</strong> : Parameters for Basemap.quiver()</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.mpl</strong> : list</p>
<blockquote class="last">
<div><p>append matplotlib.quiver.Quiver instance</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.readshapefile">
<tt class="descname">readshapefile</tt><big>(</big><em>shapefile</em>, <em>name</em>, <em>drawbounds=True</em>, <em>zorder=None</em>, <em>linewidth=0.5</em>, <em>color='k'</em>, <em>antialiased=1</em>, <em>ax=None</em>, <em>default_encoding='utf-8'</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.readshapefile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read in shape file, optionally draw boundaries on map.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>Assumes shapes are 2D</li>
<li>only works for Point, MultiPoint, Polyline and Polygon shapes.</li>
<li>vertices/points must be in geographic (lat/lon) coordinates.</li>
</ul>
</div>
<p>Mandatory Arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Argument</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>shapefile</td>
<td>path to shapefile components.  Example:
shapefile=&#8217;/home/jeff/esri/world_borders&#8217; assumes
that world_borders.shp, world_borders.shx and
world_borders.dbf live in /home/jeff/esri.</td>
</tr>
<tr class="row-odd"><td>name</td>
<td>name for Basemap attribute to hold the shapefile
vertices or points in map projection
coordinates. Class attribute name+&#8217;_info&#8217; is a list
of dictionaries, one for each shape, containing
attributes of each shape from dbf file, For
example, if name=&#8217;counties&#8217;, self.counties
will be a list of x,y vertices for each shape in
map projection  coordinates and self.counties_info
will be a list of dictionaries with shape
attributes.  Rings in individual Polygon
shapes are split out into separate polygons, and
additional keys &#8216;RINGNUM&#8217; and &#8216;SHAPENUM&#8217; are added
to the shape attribute dictionary.</td>
</tr>
</tbody>
</table>
<p>The following optional keyword arguments are only relevant for Polyline
and Polygon shape types, for Point and MultiPoint shapes they are
ignored.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>drawbounds</td>
<td>draw boundaries of shapes (default True).</td>
</tr>
<tr class="row-odd"><td>zorder</td>
<td>shape boundary zorder (if not specified,
default for mathplotlib.lines.LineCollection
is used).</td>
</tr>
<tr class="row-even"><td>linewidth</td>
<td>shape boundary line width (default 0.5)</td>
</tr>
<tr class="row-odd"><td>color</td>
<td>shape boundary line color (default black)</td>
</tr>
<tr class="row-even"><td>antialiased</td>
<td>antialiasing switch for shape boundaries
(default True).</td>
</tr>
<tr class="row-odd"><td>ax</td>
<td>axes instance (overrides default axes instance)</td>
</tr>
</tbody>
</table>
<p>A tuple (num_shapes, type, min, max) containing shape file info
is returned.
num_shapes is the number of shapes, type is the type code (one of
the SHPT* constants defined in the shapelib module, see
<a class="reference external" href="http://shapelib.maptools.org/shp_api.html">http://shapelib.maptools.org/shp_api.html</a>) and min and
max are 4-element lists with the minimum and maximum values of the
vertices. If <tt class="docutils literal"><span class="pre">drawbounds=True</span></tt> a
matplotlib.patches.LineCollection object is appended to the tuple.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.rotate_vector">
<tt class="descname">rotate_vector</tt><big>(</big><em>uin</em>, <em>vin</em>, <em>lons</em>, <em>lats</em>, <em>returnxy=False</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.rotate_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate a vector field (<tt class="docutils literal"><span class="pre">uin,vin</span></tt>) on a rectilinear grid
with longitudes = <tt class="docutils literal"><span class="pre">lons</span></tt> and latitudes = <tt class="docutils literal"><span class="pre">lats</span></tt> from
geographical (lat/lon) into map projection (x/y) coordinates.</p>
<p>Differs from transform_vector in that no interpolation is done.
The vector is returned on the same grid, but rotated into
x,y coordinates.</p>
<p>The input vector field is defined in spherical coordinates (it
has eastward and northward components) while the output
vector field is rotated to map projection coordinates (relative
to x and y). The magnitude of the vector is preserved.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Arguments</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>uin, vin</td>
<td>input vector field on a lat/lon grid.</td>
</tr>
<tr class="row-odd"><td>lons, lats</td>
<td>Arrays containing longitudes and latitudes
(in degrees) of input data in increasing order.
For non-cylindrical projections (those other than
<tt class="docutils literal"><span class="pre">cyl</span></tt>, <tt class="docutils literal"><span class="pre">merc</span></tt>, <tt class="docutils literal"><span class="pre">cyl</span></tt>, <tt class="docutils literal"><span class="pre">gall</span></tt> and <tt class="docutils literal"><span class="pre">mill</span></tt>) lons
must fit within range -180 to 180.</td>
</tr>
</tbody>
</table>
<p>Returns <tt class="docutils literal"><span class="pre">uout,</span> <span class="pre">vout</span></tt> (rotated vector field).
If the optional keyword argument
<tt class="docutils literal"><span class="pre">returnxy</span></tt> is True (default is False),
returns <tt class="docutils literal"><span class="pre">uout,vout,x,y</span></tt> (where <tt class="docutils literal"><span class="pre">x,y</span></tt> are the map projection
coordinates of the grid defined by <tt class="docutils literal"><span class="pre">lons,lats</span></tt>).</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.save">
<tt class="descname">save</tt><big>(</big><em>fileName</em>, <em>landmask=True</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw continents and save</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : string</p>
<blockquote>
<div><p>name of outputfile</p>
</div></blockquote>
<p><strong>landmask</strong> : Boolean</p>
<blockquote>
<div><p>Draw landmask?</p>
</div></blockquote>
<p class="last"><strong>**kwargs</strong> : Parameters for basemap.fillcontinents</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.scatter">
<tt class="descname">scatter</tt><big>(</big><em>x</em>, <em>y</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.scatter" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot points with markers on the map
(see matplotlib.pyplot.scatter documentation).</p>
<p>If <tt class="docutils literal"><span class="pre">latlon</span></tt> keyword is set to True, x,y are intrepreted as
longitude and latitude in degrees.  Data and longitudes are
automatically shifted to match map projection region for cylindrical
and pseudocylindrical projections, and x,y are transformed to map
projection coordinates. If <tt class="docutils literal"><span class="pre">latlon</span></tt> is False (default), x and y
are assumed to be map projection coordinates.</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axes instance.</p>
<p>Other **kwargs passed on to matplotlib.pyplot.scatter.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.set_axes_limits">
<tt class="descname">set_axes_limits</tt><big>(</big><em>ax=None</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.set_axes_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Final step in Basemap method wrappers of Axes plotting methods:</p>
<p>Set axis limits, fix aspect ratio for map domain using current
or specified axes instance.  This is done only once per axes
instance.</p>
<p>In interactive mode, this method always calls draw_if_interactive
before returning.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.shadedrelief">
<tt class="descname">shadedrelief</tt><big>(</big><em>ax=None</em>, <em>scale=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.shadedrelief" title="Permalink to this definition">¶</a></dt>
<dd><p>display shaded relief image (from <a class="reference external" href="http://www.shadedrelief.com">http://www.shadedrelief.com</a>)
as map background.
Default image size is 10800x5400, which can be quite slow and
use quite a bit of memory.  The <tt class="docutils literal"><span class="pre">scale</span></tt> keyword can be used
to downsample the image (<tt class="docutils literal"><span class="pre">scale=0.5</span></tt> downsamples to 5400x2700).</p>
<p>**kwargs passed on to <a class="reference internal" href="#nansat.Nansatmap.imshow" title="nansat.Nansatmap.imshow"><tt class="xref py py-meth docutils literal"><span class="pre">imshow()</span></tt></a>.</p>
<p>returns a matplotlib.image.AxesImage instance.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.shiftdata">
<tt class="descname">shiftdata</tt><big>(</big><em>lonsin</em>, <em>datain=None</em>, <em>lon_0=None</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.shiftdata" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift longitudes (and optionally data) so that they match map projection region.
Only valid for cylindrical/pseudo-cylindrical global projections and data
on regular lat/lon grids. longitudes and data can be 1-d or 2-d, if 2-d
it is assumed longitudes are 2nd (rightmost) dimension.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Arguments</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>lonsin</td>
<td>original 1-d or 2-d longitudes.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keywords</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>datain</td>
<td>original 1-d or 2-d data. Default None.</td>
</tr>
<tr class="row-odd"><td>lon_0</td>
<td>center of map projection region. Defaut None,
given by current map projection.</td>
</tr>
</tbody>
</table>
<p>if datain given, returns <tt class="docutils literal"><span class="pre">dataout,lonsout</span></tt> (data and longitudes shifted to fit in interval
[lon_0-180,lon_0+180]), otherwise just returns longitudes.  If
transformed longitudes lie outside map projection region, data is
masked and longitudes are set to 1.e30.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.smooth">
<tt class="descname">smooth</tt><big>(</big><em>idata</em>, <em>mode</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.smooth" title="Permalink to this definition">¶</a></dt>
<dd><p>Smooth data for contour() and contourf()</p>
<p>idata is smoothed by convolve, fourier_gaussian, spline or
gaussian (default). If contour_mode is &#8216;convolve&#8217; and weight is None,
the weight matrix is created automatically.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>idata</strong> : numpy 2D array</p>
<blockquote>
<div><p>Input data</p>
</div></blockquote>
<p><strong>mode</strong> : string</p>
<blockquote>
<div><p>&#8216;convolve&#8217;,&#8217;fourier&#8217;,&#8217;spline&#8217; or &#8216;gaussian&#8217;</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>odata</strong> : numpy 2D array</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>See also : <a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/ndimage.html">http://docs.scipy.org/doc/scipy/reference/ndimage.html</a></p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.streamplot">
<tt class="descname">streamplot</tt><big>(</big><em>x</em>, <em>y</em>, <em>u</em>, <em>v</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.streamplot" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws streamlines of a vector flow.
(see matplotlib.pyplot.streamplot documentation).</p>
<p>If <tt class="docutils literal"><span class="pre">latlon</span></tt> keyword is set to True, x,y are intrepreted as
longitude and latitude in degrees.  Data and longitudes are
automatically shifted to match map projection region for cylindrical
and pseudocylindrical projections, and x,y are transformed to map
projection coordinates. If <tt class="docutils literal"><span class="pre">latlon</span></tt> is False (default), x and y
are assumed to be map projection coordinates.</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>Other *args and **kwargs passed on to matplotlib.pyplot.streamplot.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.tissot">
<tt class="descname">tissot</tt><big>(</big><em>lon_0</em>, <em>lat_0</em>, <em>radius_deg</em>, <em>npts</em>, <em>ax=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.tissot" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a polygon centered at <tt class="docutils literal"><span class="pre">lon_0,lat_0</span></tt>.  The polygon
approximates a circle on the surface of the earth with radius
<tt class="docutils literal"><span class="pre">radius_deg</span></tt> degrees latitude along longitude <tt class="docutils literal"><span class="pre">lon_0</span></tt>,
made up of <tt class="docutils literal"><span class="pre">npts</span></tt> vertices.
The polygon represents a Tissot&#8217;s indicatrix
(<a class="reference external" href="http://en.wikipedia.org/wiki/Tissot's_Indicatrix">http://en.wikipedia.org/wiki/Tissot&#8217;s_Indicatrix</a>),
which when drawn on a map shows the distortion
inherent in the map projection.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Cannot handle situations in which the polygon intersects
the edge of the map projection domain, and then re-enters the domain.</p>
</div>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>Other **kwargs passed on to matplotlib.patches.Polygon.</p>
<p>returns a matplotlib.patches.Polygon object.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.transform_scalar">
<tt class="descname">transform_scalar</tt><big>(</big><em>datin</em>, <em>lons</em>, <em>lats</em>, <em>nx</em>, <em>ny</em>, <em>returnxy=False</em>, <em>checkbounds=False</em>, <em>order=1</em>, <em>masked=False</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.transform_scalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate a scalar field (<tt class="docutils literal"><span class="pre">datin</span></tt>) from a lat/lon grid with
longitudes = <tt class="docutils literal"><span class="pre">lons</span></tt> and latitudes = <tt class="docutils literal"><span class="pre">lats</span></tt> to a <tt class="docutils literal"><span class="pre">ny</span></tt> by <tt class="docutils literal"><span class="pre">nx</span></tt>
map projection grid.  Typically used to transform data to
map projection coordinates for plotting on a map with
the <a class="reference internal" href="#nansat.Nansatmap.imshow" title="nansat.Nansatmap.imshow"><tt class="xref py py-meth docutils literal"><span class="pre">imshow()</span></tt></a>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Argument</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>datin</td>
<td>input data on a lat/lon grid.</td>
</tr>
<tr class="row-odd"><td>lons, lats</td>
<td>rank-1 arrays containing longitudes and latitudes
(in degrees) of input data in increasing order.
For non-cylindrical projections (those other than
<tt class="docutils literal"><span class="pre">cyl</span></tt>, <tt class="docutils literal"><span class="pre">merc</span></tt>, <tt class="docutils literal"><span class="pre">cea</span></tt>, <tt class="docutils literal"><span class="pre">gall</span></tt> and <tt class="docutils literal"><span class="pre">mill</span></tt>) lons
must fit within range -180 to 180.</td>
</tr>
<tr class="row-even"><td>nx, ny</td>
<td>The size of the output regular grid in map
projection coordinates</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>returnxy</td>
<td>If True, the x and y values of the map
projection grid are also returned (Default False).</td>
</tr>
<tr class="row-odd"><td>checkbounds</td>
<td>If True, values of lons and lats are checked to see
that they lie within the map projection region.
Default is False, and data outside map projection
region is clipped to values on boundary.</td>
</tr>
<tr class="row-even"><td>masked</td>
<td>If True, interpolated data is returned as a masked
array with values outside map projection region
masked (Default False).</td>
</tr>
<tr class="row-odd"><td>order</td>
<td>0 for nearest-neighbor interpolation, 1 for
bilinear, 3 for cubic spline (Default 1).
Cubic spline interpolation requires scipy.ndimage.</td>
</tr>
</tbody>
</table>
<p>Returns <tt class="docutils literal"><span class="pre">datout</span></tt> (data on map projection grid).
If returnxy=True, returns <tt class="docutils literal"><span class="pre">data,x,y</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.transform_vector">
<tt class="descname">transform_vector</tt><big>(</big><em>uin</em>, <em>vin</em>, <em>lons</em>, <em>lats</em>, <em>nx</em>, <em>ny</em>, <em>returnxy=False</em>, <em>checkbounds=False</em>, <em>order=1</em>, <em>masked=False</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.transform_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate and interpolate a vector field (<tt class="docutils literal"><span class="pre">uin,vin</span></tt>) from a
lat/lon grid with longitudes = <tt class="docutils literal"><span class="pre">lons</span></tt> and latitudes = <tt class="docutils literal"><span class="pre">lats</span></tt>
to a <tt class="docutils literal"><span class="pre">ny</span></tt> by <tt class="docutils literal"><span class="pre">nx</span></tt> map projection grid.</p>
<p>The input vector field is defined in spherical coordinates (it
has eastward and northward components) while the output
vector field is rotated to map projection coordinates (relative
to x and y). The magnitude of the vector is preserved.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Arguments</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>uin, vin</td>
<td>input vector field on a lat/lon grid.</td>
</tr>
<tr class="row-odd"><td>lons, lats</td>
<td>rank-1 arrays containing longitudes and latitudes
(in degrees) of input data in increasing order.
For non-cylindrical projections (those other than
<tt class="docutils literal"><span class="pre">cyl</span></tt>, <tt class="docutils literal"><span class="pre">merc</span></tt>, <tt class="docutils literal"><span class="pre">cea</span></tt>, <tt class="docutils literal"><span class="pre">gall</span></tt> and <tt class="docutils literal"><span class="pre">mill</span></tt>) lons
must fit within range -180 to 180.</td>
</tr>
<tr class="row-even"><td>nx, ny</td>
<td>The size of the output regular grid in map
projection coordinates</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>returnxy</td>
<td>If True, the x and y values of the map
projection grid are also returned (Default False).</td>
</tr>
<tr class="row-odd"><td>checkbounds</td>
<td>If True, values of lons and lats are checked to see
that they lie within the map projection region.
Default is False, and data outside map projection
region is clipped to values on boundary.</td>
</tr>
<tr class="row-even"><td>masked</td>
<td>If True, interpolated data is returned as a masked
array with values outside map projection region
masked (Default False).</td>
</tr>
<tr class="row-odd"><td>order</td>
<td>0 for nearest-neighbor interpolation, 1 for
bilinear, 3 for cubic spline (Default 1).
Cubic spline interpolation requires scipy.ndimage.</td>
</tr>
</tbody>
</table>
<p>Returns <tt class="docutils literal"><span class="pre">uout,</span> <span class="pre">vout</span></tt> (vector field on map projection grid).
If returnxy=True, returns <tt class="docutils literal"><span class="pre">uout,vout,x,y</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.warpimage">
<tt class="descname">warpimage</tt><big>(</big><em>image='bluemarble'</em>, <em>scale=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.warpimage" title="Permalink to this definition">¶</a></dt>
<dd><p>Display an image (filename given by <tt class="docutils literal"><span class="pre">image</span></tt> keyword) as a map background.
If image is a URL (starts with &#8216;http&#8217;), it is downloaded to a temp
file using urllib.urlretrieve.</p>
<p>Default (if <tt class="docutils literal"><span class="pre">image</span></tt> not specified) is to display
&#8216;blue marble next generation&#8217; image from <a class="reference external" href="http://visibleearth.nasa.gov/">http://visibleearth.nasa.gov/</a>.</p>
<p>Specified image must have pixels covering the whole globe in a regular
lat/lon grid, starting and -180W and the South Pole.
Works with the global images from
<a class="reference external" href="http://earthobservatory.nasa.gov/Features/BlueMarble/BlueMarble_monthlies.php">http://earthobservatory.nasa.gov/Features/BlueMarble/BlueMarble_monthlies.php</a>.</p>
<p>The <tt class="docutils literal"><span class="pre">scale</span></tt> keyword can be used to downsample (rescale) the image.
Values less than 1.0 will speed things up at the expense of image
resolution.</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>**kwargs passed on to <a class="reference internal" href="#nansat.Nansatmap.imshow" title="nansat.Nansatmap.imshow"><tt class="xref py py-meth docutils literal"><span class="pre">imshow()</span></tt></a>.</p>
<p>returns a matplotlib.image.AxesImage instance.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.wmsimage">
<tt class="descname">wmsimage</tt><big>(</big><em>server</em>, <em>xpixels=400</em>, <em>ypixels=None</em>, <em>format='png'</em>, <em>verbose=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.wmsimage" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve an image using from a WMS server using the
Open Geospatial Consortium (OGC) standard interface
and display on the map. Requires OWSLib
(<a class="reference external" href="http://pypi.python.org/pypi/OWSLib">http://pypi.python.org/pypi/OWSLib</a>).
In order to use this method, the Basemap instance must be
created using the <tt class="docutils literal"><span class="pre">epsg</span></tt> keyword to define the map projection, unless
the <tt class="docutils literal"><span class="pre">cyl</span></tt> projection is used (in which case the epsg code 4326 is
assumed).</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keywords</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>server</td>
<td>WMS server URL.</td>
</tr>
<tr class="row-odd"><td>xpixels</td>
<td>requested number of image pixels in x-direction
(default 400).</td>
</tr>
<tr class="row-even"><td>ypixels</td>
<td>requested number of image pixels in y-direction.
Default (None) is to infer the number from
from xpixels and the aspect ratio of the
map projection region.</td>
</tr>
<tr class="row-odd"><td>format</td>
<td>desired image format (default &#8216;png&#8217;)</td>
</tr>
<tr class="row-even"><td>verbose</td>
<td>if True, print WMS server info (default
False).</td>
</tr>
<tr class="row-odd"><td>**kwargs</td>
<td>extra keyword arguments passed on to
OWSLib.wms.WebMapService.getmap.</td>
</tr>
</tbody>
</table>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>returns a matplotlib.image.AxesImage instance.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nansat.Mosaic">
<em class="property">class </em><tt class="descclassname">nansat.</tt><tt class="descname">Mosaic</tt><big>(</big><em>fileName=''</em>, <em>mapperName=''</em>, <em>domain=None</em>, <em>array=None</em>, <em>parameters=None</em>, <em>logLevel=30</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Mosaic" title="Permalink to this definition">¶</a></dt>
<dd><p>Create Nansat object</p>
<dl class="docutils">
<dt>if &lt;fileName&gt; is given:</dt>
<dd>Open GDAL dataset,
Read metadata,
Generate GDAL VRT file with mapping of variables in memory
Create logger
Create Nansat object for perfroming high-level operations</dd>
<dt>if &lt;domain&gt; and &lt;array&gt; are given:</dt>
<dd>Create VRT object from data in &lt;array&gt;
Add geolocation from &lt;domain&gt;</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : string</p>
<blockquote>
<div><p>location of the file</p>
</div></blockquote>
<p><strong>mapperName</strong> : string, optional</p>
<blockquote>
<div><p>name of the mapper from nansat/mappers dir. E.g.
&#8216;ASAR&#8217;, &#8216;hirlam&#8217;, &#8216;merisL1&#8217;, &#8216;merisL2&#8217;, etc.</p>
</div></blockquote>
<p><strong>domain</strong> : Domain object</p>
<blockquote>
<div><p>Geo-reference of a new raster</p>
</div></blockquote>
<p><strong>array</strong> : numpy array</p>
<blockquote>
<div><p>Firts band of a new raster</p>
</div></blockquote>
<p><strong>parameters</strong> : dictionary</p>
<blockquote>
<div><p>Metadata for the 1st band of a new raster,e.g. name, wkv, units,...</p>
</div></blockquote>
<p><strong>logLevel</strong> : int, optional, default: logging.DEBUG (30)</p>
<blockquote>
<div><p>Level of logging. See: <a class="reference external" href="http://docs.python.org/howto/logging.html">http://docs.python.org/howto/logging.html</a></p>
</div></blockquote>
<p><strong>kwargs</strong> : additional arguments for mappers</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Creates:</th><td class="field-body"><p class="first"><strong>self.mapper</strong> : str</p>
<blockquote>
<div><p>name of the used mapper</p>
</div></blockquote>
<p><strong>self.fileName</strong> : file name</p>
<blockquote>
<div><p>set file name given by the argument</p>
</div></blockquote>
<p><strong>self.vrt</strong> : VRT object</p>
<blockquote>
<div><p>Wrapper around VRT file and GDAL dataset with satellite raster data</p>
</div></blockquote>
<p><strong>self.logger</strong> : logging.Logger</p>
<blockquote>
<div><p>logger for output debugging info</p>
</div></blockquote>
<p><strong>self.name</strong> : string</p>
<blockquote class="last">
<div><p>name of object (for writing KML)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>opens file for reading. Opening is lazy - no data is read at this
point, only metadata that describes the dataset and bands</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">Nansat</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
</pre></div>
</div>
<p>create an empty Nansat object. &lt;d&gt; is the Domain object which
describes the grid (projection, resolution and extent)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">Nansat</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
<p>create a Nansat object in memory with one band from input array &lt;a&gt;.
&lt;p&gt; is a dictionary with metadata for the band</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">Nansat</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">d</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">parameters</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
<p>fetch data from Nansat object from the first band</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>fetch data from the band which has name &#8216;band_name&#8217;</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="s">&#39;band_name&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.add_band" title="nansat.Mosaic.add_band"><tt class="xref py py-obj docutils literal"><span class="pre">add_band</span></tt></a>(array[,&nbsp;parameters,&nbsp;nomem])</td>
<td>Add band from the array to self.vrt</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Mosaic.add_bands" title="nansat.Mosaic.add_bands"><tt class="xref py py-obj docutils literal"><span class="pre">add_bands</span></tt></a>(arrays[,&nbsp;parameters,&nbsp;nomem])</td>
<td>Add band from the array to self.vrt</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.average" title="nansat.Mosaic.average"><tt class="xref py py-obj docutils literal"><span class="pre">average</span></tt></a>([files,&nbsp;bands,&nbsp;doReproject,&nbsp;...])</td>
<td>Memory-friendly, multithreaded mosaicing(averaging) of input files</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Mosaic.azimuth_y" title="nansat.Mosaic.azimuth_y"><tt class="xref py py-obj docutils literal"><span class="pre">azimuth_y</span></tt></a>([reductionFactor])</td>
<td>Calculate the azimuth of &#8216;upward&#8217; direction in each pixel</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.bands" title="nansat.Mosaic.bands"><tt class="xref py py-obj docutils literal"><span class="pre">bands</span></tt></a>()</td>
<td>Make a dictionary with all metadata from all bands</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Mosaic.crop" title="nansat.Mosaic.crop"><tt class="xref py py-obj docutils literal"><span class="pre">crop</span></tt></a>([xOff,&nbsp;yOff,&nbsp;xSize,&nbsp;ySize,&nbsp;lonlim,&nbsp;latlim])</td>
<td>Crop Nansat object</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.export" title="nansat.Mosaic.export"><tt class="xref py py-obj docutils literal"><span class="pre">export</span></tt></a>(fileName[,&nbsp;bands,&nbsp;rmMetadata,&nbsp;...])</td>
<td>Export Nansat object into netCDF or GTiff file</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Mosaic.export2thredds" title="nansat.Mosaic.export2thredds"><tt class="xref py py-obj docutils literal"><span class="pre">export2thredds</span></tt></a>(fileName[,&nbsp;bands,&nbsp;metadata,&nbsp;...])</td>
<td>Export data into a netCDF formatted for THREDDS server</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.get_GDALRasterBand" title="nansat.Mosaic.get_GDALRasterBand"><tt class="xref py py-obj docutils literal"><span class="pre">get_GDALRasterBand</span></tt></a>([bandID])</td>
<td>Get a GDALRasterBand of a given Nansat object</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Mosaic.get_border" title="nansat.Mosaic.get_border"><tt class="xref py py-obj docutils literal"><span class="pre">get_border</span></tt></a>([nPoints])</td>
<td>Generate two vectors with values of lat/lon for the border of domain</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.get_border_geometry" title="nansat.Mosaic.get_border_geometry"><tt class="xref py py-obj docutils literal"><span class="pre">get_border_geometry</span></tt></a>()</td>
<td>Get OGR Geometry of the border Polygon</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Mosaic.get_border_postgis" title="nansat.Mosaic.get_border_postgis"><tt class="xref py py-obj docutils literal"><span class="pre">get_border_postgis</span></tt></a>()</td>
<td>Get PostGIS formatted string of the border Polygon</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.get_border_wkt" title="nansat.Mosaic.get_border_wkt"><tt class="xref py py-obj docutils literal"><span class="pre">get_border_wkt</span></tt></a>()</td>
<td>Creates string with WKT representation of the border polygon</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Mosaic.get_corners" title="nansat.Mosaic.get_corners"><tt class="xref py py-obj docutils literal"><span class="pre">get_corners</span></tt></a>()</td>
<td>Get coordinates of corners of the Domain</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.get_geolocation_grids" title="nansat.Mosaic.get_geolocation_grids"><tt class="xref py py-obj docutils literal"><span class="pre">get_geolocation_grids</span></tt></a>([stepSize])</td>
<td>Get longitude and latitude grids representing the full data grid</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Mosaic.get_metadata" title="nansat.Mosaic.get_metadata"><tt class="xref py py-obj docutils literal"><span class="pre">get_metadata</span></tt></a>([key,&nbsp;bandID])</td>
<td>Get metadata from self.vrt.dataset</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.get_pixelsize_meters" title="nansat.Mosaic.get_pixelsize_meters"><tt class="xref py py-obj docutils literal"><span class="pre">get_pixelsize_meters</span></tt></a>()</td>
<td>Returns the pixelsize (deltaX, deltaY) of the domain</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Mosaic.get_time" title="nansat.Mosaic.get_time"><tt class="xref py py-obj docutils literal"><span class="pre">get_time</span></tt></a>([bandID])</td>
<td>Get time for dataset and/or its bands</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.get_transect" title="nansat.Mosaic.get_transect"><tt class="xref py py-obj docutils literal"><span class="pre">get_transect</span></tt></a>([points,&nbsp;bandList,&nbsp;latlon,&nbsp;...])</td>
<td>Get transect from two poins and retun the values by numpy array</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Mosaic.has_band" title="nansat.Mosaic.has_band"><tt class="xref py py-obj docutils literal"><span class="pre">has_band</span></tt></a>(band)</td>
<td>Check if self has band with name &lt;band&gt;</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.latest" title="nansat.Mosaic.latest"><tt class="xref py py-obj docutils literal"><span class="pre">latest</span></tt></a>([files,&nbsp;bands,&nbsp;doReproject,&nbsp;maskName])</td>
<td>Mosaic by adding the latest image on top without averaging</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Mosaic.list_bands" title="nansat.Mosaic.list_bands"><tt class="xref py py-obj docutils literal"><span class="pre">list_bands</span></tt></a>([doPrint])</td>
<td>Show band information of the given Nansat object</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.median" title="nansat.Mosaic.median"><tt class="xref py py-obj docutils literal"><span class="pre">median</span></tt></a>([files,&nbsp;bands,&nbsp;doReproject,&nbsp;maskName])</td>
<td>Calculate median of input bands</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Mosaic.nClass" title="nansat.Mosaic.nClass"><tt class="xref py py-obj docutils literal"><span class="pre">nClass</span></tt></a></td>
<td>alias of <a class="reference internal" href="#nansat.Nansat" title="nansat.Nansat"><tt class="xref py py-class docutils literal"><span class="pre">Nansat</span></tt></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.reproject" title="nansat.Mosaic.reproject"><tt class="xref py py-obj docutils literal"><span class="pre">reproject</span></tt></a>([dstDomain,&nbsp;eResampleAlg,&nbsp;...])</td>
<td>Change projection of the object based on the given Domain</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Mosaic.reproject_GCPs" title="nansat.Mosaic.reproject_GCPs"><tt class="xref py py-obj docutils literal"><span class="pre">reproject_GCPs</span></tt></a>(srsString)</td>
<td>Reproject all GCPs to a new spatial reference system</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.resize" title="nansat.Mosaic.resize"><tt class="xref py py-obj docutils literal"><span class="pre">resize</span></tt></a>([factor,&nbsp;width,&nbsp;height,&nbsp;pixelsize,&nbsp;...])</td>
<td>Proportional resize of the dataset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Mosaic.set_metadata" title="nansat.Mosaic.set_metadata"><tt class="xref py py-obj docutils literal"><span class="pre">set_metadata</span></tt></a>([key,&nbsp;value,&nbsp;bandID])</td>
<td>Set metadata to self.vrt.dataset</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.shape" title="nansat.Mosaic.shape"><tt class="xref py py-obj docutils literal"><span class="pre">shape</span></tt></a>()</td>
<td>Return Numpy-like shape of Domain object (ySize, xSize)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Mosaic.transform_points" title="nansat.Mosaic.transform_points"><tt class="xref py py-obj docutils literal"><span class="pre">transform_points</span></tt></a>(colVector,&nbsp;rowVector[,&nbsp;...])</td>
<td>Transform given lists of X,Y coordinates into lon/lat or inverse</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.undo" title="nansat.Mosaic.undo"><tt class="xref py py-obj docutils literal"><span class="pre">undo</span></tt></a>([steps])</td>
<td>Undo reproject, resize, add_band or crop of Nansat object</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Mosaic.watermask" title="nansat.Mosaic.watermask"><tt class="xref py py-obj docutils literal"><span class="pre">watermask</span></tt></a>([mod44path,&nbsp;dstDomain])</td>
<td>Create numpy array with watermask (water=1, land=0)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.write_figure" title="nansat.Mosaic.write_figure"><tt class="xref py py-obj docutils literal"><span class="pre">write_figure</span></tt></a>([fileName,&nbsp;bands,&nbsp;clim,&nbsp;addDate])</td>
<td>Save a raster band to a figure in graphical format.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Mosaic.write_geotiffimage" title="nansat.Mosaic.write_geotiffimage"><tt class="xref py py-obj docutils literal"><span class="pre">write_geotiffimage</span></tt></a>(fileName[,&nbsp;bandID])</td>
<td>Writes an 8-bit GeoTiff image for a given band.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.write_kml" title="nansat.Mosaic.write_kml"><tt class="xref py py-obj docutils literal"><span class="pre">write_kml</span></tt></a>([xmlFileName,&nbsp;kmlFileName])</td>
<td>Write KML file with domains</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.Mosaic.write_kml_image" title="nansat.Mosaic.write_kml_image"><tt class="xref py py-obj docutils literal"><span class="pre">write_kml_image</span></tt></a>([kmlFileName,&nbsp;kmlFigureName])</td>
<td>Create KML file for already projected image</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.Mosaic.write_map" title="nansat.Mosaic.write_map"><tt class="xref py py-obj docutils literal"><span class="pre">write_map</span></tt></a>(outputFileName[,&nbsp;lonVec,&nbsp;latVec,&nbsp;...])</td>
<td>Create an image with a map of the domain</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nansat.Mosaic.add_band">
<tt class="descname">add_band</tt><big>(</big><em>array</em>, <em>parameters=None</em>, <em>nomem=False</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.add_band" title="Permalink to this definition">¶</a></dt>
<dd><p>Add band from the array to self.vrt</p>
<p>Create VRT object which contains VRT and RAW binary file and append it
to self.vrt.subVRTs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>array</strong> : ndarray</p>
<blockquote>
<div><p>band data</p>
</div></blockquote>
<p><strong>parameters</strong> : dictionary</p>
<blockquote>
<div><p>band metadata: wkv, name, etc. (or for several bands)</p>
</div></blockquote>
<p><strong>nomem</strong> : boolean, saves the vrt to a tempfile if nomem is True</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>Creates VRT object with VRT-file and RAW-file</strong></p>
<blockquote class="last">
<div><p>Adds band to the self.vrt</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>add new band from numpy array &lt;a&gt; with metadata &lt;p&gt; in memory
Shape of a should be equal to the shape of &lt;n&gt;</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_band</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
<p>add new band from an array &lt;a&gt; with metadata &lt;p&gt; but keep it
temporarli on disk intead of memory</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_band</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">nomem</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.add_bands">
<tt class="descname">add_bands</tt><big>(</big><em>arrays</em>, <em>parameters=None</em>, <em>nomem=False</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.add_bands" title="Permalink to this definition">¶</a></dt>
<dd><p>Add band from the array to self.vrt</p>
<p>Create VRT object which contains VRT and RAW binary file and append it
to self.vrt.subVRTs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>array</strong> : ndarray or list</p>
<blockquote>
<div><p>band data (or data for several bands)</p>
</div></blockquote>
<p><strong>parameters</strong> : dictionary or list</p>
<blockquote>
<div><p>band metadata: wkv, name, etc. (or for several bands)</p>
</div></blockquote>
<p><strong>nomem</strong> : boolean, saves the vrt to a tempfile if nomem is True</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>Creates VRT object with VRT-file and RAW-file</strong></p>
<blockquote class="last">
<div><p>Adds band to the self.vrt</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>add two new bands from numpy arrays &lt;a1&gt; and &lt;a2&gt; with metadata in
&#8216;p1&#8217; and &#8216;p2&#8217;</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_bands</span><span class="p">([</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">],</span> <span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.average">
<tt class="descname">average</tt><big>(</big><em>files=[], bands=[1], doReproject=True, maskName='mask', threads=1, **kwargs</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.average" title="Permalink to this definition">¶</a></dt>
<dd><p>Memory-friendly, multithreaded mosaicing(averaging) of input files</p>
<p>Convert all input files into Nansat objects, reproject onto the
Domain of the current object, get bands, from each object,
calculate average and STD, add averaged bands (and STD) to the current
object.</p>
<p>average() tries to get band &#8216;mask&#8217; from the input files. The mask
should have the following coding:</p>
<blockquote>
<div><div class="line-block">
<div class="line">0 : nodata</div>
<div class="line">1 : clouds</div>
<div class="line">2 : land</div>
<div class="line">64 : valid pixel</div>
</div>
</div></blockquote>
<p>If it gets that band (which can be provided by some mappers or Nansat
childs, e.g.  ModisL2Image) it uses it to select averagable pixels
(i.e. where mask == 64).
If it cannot locate the band &#8216;mask&#8217; is assumes that all pixels are
averagebale except for thouse out of swath after reprojection.</p>
<p>average() adds bands to the object, so it works only with empty, or
non-projected objects</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>files</strong> : list</p>
<blockquote>
<div><p>list of input files</p>
</div></blockquote>
<p><strong>bands</strong> : list</p>
<blockquote>
<div><p>list of names/band_numbers to be processed</p>
</div></blockquote>
<p><strong>doReproject</strong> : boolean, [True]</p>
<blockquote>
<div><p>reproject input files?</p>
</div></blockquote>
<p><strong>maskName</strong> : str, [&#8216;mask&#8217;]</p>
<blockquote>
<div><p>name of the mask in input files</p>
</div></blockquote>
<p><strong>nClass</strong> : child of Nansat, [Nansat]</p>
<blockquote>
<div><p>This class is used to read input files</p>
</div></blockquote>
<p><strong>threads</strong> : int</p>
<blockquote>
<div><p>number of parallel processes to use</p>
</div></blockquote>
<p><strong>eResampleAlg</strong> : int, [0]</p>
<blockquote>
<div><p>agorithm for reprojection, see Nansat.reproject()</p>
</div></blockquote>
<p><strong>period</strong> : [datetime0, datetime1]</p>
<blockquote class="last">
<div><p>Start and stop datetime objects from pyhon datetime.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.azimuth_y">
<tt class="descname">azimuth_y</tt><big>(</big><em>reductionFactor=1</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.azimuth_y" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the azimuth of &#8216;upward&#8217; direction in each pixel</p>
<p>Generaly speaking, azimuth is angle from the reference vector
(direction to North) to the chosen direction. Azimuth increases
clockwise from direction to North. <a class="reference external" href="http://en.wikipedia.org/wiki/Azimuth">http://en.wikipedia.org/wiki/Azimuth</a></p>
<p>Here we calcluate azimuth of &#8216;upward&#8217; direction.
&#8216;Upward&#8217; direction coincides with Y-axis direction (and hence is
opposite to the ROW-axis direction). For lon-lat (cylindrical,
Plate Caree) and Mercator projections &#8216;upward&#8217; direction coincides with
direction to North, hence azimuth is 0.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reductionFactor</strong> : integer</p>
<blockquote>
<div><p>factor by which the size of the output array is reduced</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>azimuth</strong> : numpy array</p>
<blockquote class="last">
<div><p>Values of azimuth in degrees in range 0 - 360</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.bands">
<tt class="descname">bands</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Mosaic.bands" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a dictionary with all metadata from all bands</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>b</strong> : dictionary</p>
<blockquote class="last">
<div><p>key = N, value = dict with all band metadata</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.crop">
<tt class="descname">crop</tt><big>(</big><em>xOff=0</em>, <em>yOff=0</em>, <em>xSize=None</em>, <em>ySize=None</em>, <em>lonlim=None</em>, <em>latlim=None</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.crop" title="Permalink to this definition">¶</a></dt>
<dd><p>Crop Nansat object</p>
<p>Create superVRT, modify the Source Rectangle (SrcRect) and Destination
Rectangle (DstRect) tags in the VRT file for each band in order
to take only part of the original image,
create new GCPs or new GeoTransform for the cropped object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xOff</strong> : int</p>
<blockquote>
<div><p>pixel offset of subimage</p>
</div></blockquote>
<p><strong>yOff</strong> : int</p>
<blockquote>
<div><p>line offset of subimage</p>
</div></blockquote>
<p><strong>xSize</strong> : int</p>
<blockquote>
<div><p>width in pixels of subimage</p>
</div></blockquote>
<p><strong>ySize</strong> : int</p>
<blockquote>
<div><p>height in pizels of subimage</p>
</div></blockquote>
<p><strong>lonlim</strong> : [float, float]</p>
<blockquote>
<div><p>longitdal limits</p>
</div></blockquote>
<p><strong>latlim</strong> : [float, float]</p>
<blockquote>
<div><p>latitudal limits</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.vrt</strong> : VRT</p>
<blockquote>
<div><p>superVRT is created with modified SrcRect and DstRect</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>status</strong> : int</p>
<blockquote>
<div><div class="line-block">
<div class="line">0 - everyhting is OK, image is cropped</div>
<div class="line">1 - if crop is totally outside, image is NOT cropped</div>
<div class="line">2 - crop area is too large and crop is not needed</div>
</div>
</div></blockquote>
<p><strong>extent</strong> : (xOff, yOff, xSize, ySize)</p>
<blockquote class="last">
<div><div class="line-block">
<div class="line">xOff  - X offset in the original dataset</div>
<div class="line">yOff  - Y offset in the original dataset</div>
<div class="line">xSize - width of the new dataset</div>
<div class="line">ySize - height of the new dataset</div>
</div>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>crop a subimage of size 100x200 pix from X/Y offset 10, 20 pix</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">status</span><span class="p">,</span> <span class="n">extent</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
</pre></div>
</div>
<p>crop a subimage within the lon/lat limits</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">status</span><span class="p">,</span> <span class="n">extent</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">lonlim</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span> <span class="n">latlim</span><span class="o">=</span><span class="p">[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">60</span><span class="p">])</span>
</pre></div>
</div>
<p>crop a subimage interactively</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">status</span><span class="p">,</span> <span class="n">extent</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">crop</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.export">
<tt class="descname">export</tt><big>(</big><em>fileName</em>, <em>bands=None</em>, <em>rmMetadata=[]</em>, <em>addGeolocArray=True</em>, <em>addGCPs=True</em>, <em>driver='netCDF'</em>, <em>bottomup=False</em>, <em>options=None</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.export" title="Permalink to this definition">¶</a></dt>
<dd><p>Export Nansat object into netCDF or GTiff file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : str</p>
<blockquote>
<div><p>output file name</p>
</div></blockquote>
<p><strong>bands: list (default=None)</strong></p>
<blockquote>
<div><p>Specify band numbers to export.
If None, all bands are exported.</p>
</div></blockquote>
<p><strong>rmMetadata</strong> : list</p>
<blockquote>
<div><p>metadata names for removal before export.
e.g. [&#8216;name&#8217;, &#8216;colormap&#8217;, &#8216;source&#8217;, &#8216;sourceBands&#8217;]</p>
</div></blockquote>
<p><strong>addGeolocArray</strong> : bool</p>
<blockquote>
<div><p>add geolocation array datasets to exported file?</p>
</div></blockquote>
<p><strong>addGCPs</strong> : bool</p>
<blockquote>
<div><p>add GCPs to exported file?</p>
</div></blockquote>
<p><strong>driver</strong> : str</p>
<blockquote>
<div><p>Name of GDAL driver (format)</p>
</div></blockquote>
<p><strong>bottomup</strong> : bool</p>
<blockquote>
<div><div class="line-block">
<div class="line">False: Write swath-projected data with rows and columns organized
as in the original product.</div>
<div class="line">True:  Use the default behaviour of GDAL, which is to flip the rows</div>
</div>
</div></blockquote>
<p><strong>options</strong> : str or list</p>
<blockquote>
<div><p>GDAL export options in format of: &#8216;OPT=VAL&#8217;, or
[&#8216;OPT1=VAL1&#8217;, &#8216;OP2=&#8217;VAL2&#8217;]
See also <a class="reference external" href="http://www.gdal.org/frmt_netcdf.html">http://www.gdal.org/frmt_netcdf.html</a></p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>Create a netCDF file</strong></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>If number of bands is more than one,
serial numbers are added at the end of each band name.</p>
<p>It is possible to fix it by changing
line.4605 in GDAL/frmts/netcdf/netcdfdataset.cpp :</p>
<div class="line-block">
<div class="line">&#8216;if( nBands &gt; 1 ) sprintf(szBandName,&#8221;%s%d&#8221;,tmpMetadata,iBand);&#8217;</div>
<div class="line-block">
<div class="line">&#8211;&gt; &#8216;if( nBands &gt; 1 ) sprintf(szBandName,&#8221;%s&#8221;,tmpMetadata);&#8217;</div>
</div>
</div>
<p>CreateCopy fails in case the band name has special characters,
e.g. the slash in &#8216;HH/VV&#8217;.</p>
<p class="rubric">Examples</p>
<p>export all the bands into a netDCF 3 file</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">export</span><span class="p">(</span><span class="n">netcdfile</span><span class="p">)</span>
</pre></div>
</div>
<p>export all bands into a GeoTiff</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">export</span><span class="p">(</span><span class="n">driver</span><span class="o">=</span><span class="s">&#39;GTiff&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.export2thredds">
<tt class="descname">export2thredds</tt><big>(</big><em>fileName</em>, <em>bands=None</em>, <em>metadata=None</em>, <em>maskName=None</em>, <em>rmMetadata=[]</em>, <em>time=None</em>, <em>createdTime=None</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.export2thredds" title="Permalink to this definition">¶</a></dt>
<dd><p>Export data into a netCDF formatted for THREDDS server</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : str</p>
<blockquote>
<div><p>output file name</p>
</div></blockquote>
<p><strong>bands</strong> : dict</p>
<blockquote>
<div><div class="line-block">
<div class="line">{&#8216;band_name&#8217;: {&#8216;type&#8217;     : &#8216;&gt;i1&#8217;,</div>
<div class="line-block">
<div class="line">&#8216;scale&#8217;    : 0.1,</div>
<div class="line">&#8216;offset&#8217;   : 1000,</div>
<div class="line">&#8216;metaKey1&#8217; : &#8216;meta value 1&#8217;,</div>
<div class="line">&#8216;metaKey2&#8217; : &#8216;meta value 2&#8217;}}</div>
</div>
<div class="line">dictionary sets parameters for band creation</div>
<div class="line">&#8216;type&#8217; - string representation of data type in the output band</div>
<div class="line">&#8216;scale&#8217; - sets scale_factor and applies scaling</div>
<div class="line">&#8216;offset&#8217; - sets &#8216;scale_offset and applies offsetting
other entries (e.g. &#8216;units&#8217;: &#8216;K&#8217;) set other metadata</div>
</div>
</div></blockquote>
<p><strong>metadata</strong> : dict</p>
<blockquote>
<div><p>Glbal metadata to add</p>
</div></blockquote>
<p><strong>maskName: string</strong></p>
<blockquote>
<div><p>if data include a mask band: give the mask name.
Non-masked value is 64.
if None: no mask is added</p>
</div></blockquote>
<p><strong>rmMetadata</strong> : list</p>
<blockquote>
<div><p>unwanted metadata names which will be removed</p>
</div></blockquote>
<p><strong>time</strong> : list with datetime objects</p>
<blockquote>
<div><p>aqcuisition time of original data. That value will be in time dim</p>
</div></blockquote>
<p><strong>createdTime</strong> : datetime</p>
<blockquote class="last">
<div><p>date of creation. Will be in metadata &#8216;created&#8217;</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Nansat object (self) has to be projected (with valid GeoTransform and
valid Spatial reference information) but not wth GCPs</p>
<p class="rubric">Examples</p>
<p>create THREDDS formatted netcdf file with all bands and time variable</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">export2thredds</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
</pre></div>
</div>
<p>export only the first band and add global metadata</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">export2thredds</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">{</span><span class="s">&#39;description&#39;</span><span class="p">:</span> <span class="s">&#39;example&#39;</span><span class="p">})</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.get_GDALRasterBand">
<tt class="descname">get_GDALRasterBand</tt><big>(</big><em>bandID=1</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.get_GDALRasterBand" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a GDALRasterBand of a given Nansat object</p>
<div class="line-block">
<div class="line">If str is given find corresponding band number</div>
<div class="line">If int is given check if band with this number exists.</div>
<div class="line">Get a GDALRasterBand from vrt.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>bandID</strong> : serial number or string, optional (default is 1)</p>
<blockquote>
<div><div class="line-block">
<div class="line">if number - a band number of the band to fetch</div>
<div class="line">if string - bandID = {&#8216;name&#8217;: bandID}</div>
</div>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>GDALRasterBand</strong> : GDALRasterBand</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">get_GDALRasterBand</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">get_GDALRasterBand</span><span class="p">(</span><span class="s">&#39;sigma0&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.get_border">
<tt class="descname">get_border</tt><big>(</big><em>nPoints=10</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.get_border" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate two vectors with values of lat/lon for the border of domain</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>nPoints</strong> : int, optional</p>
<blockquote>
<div><p>Number of points on each border</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>lonVec, latVec</strong> : lists</p>
<blockquote class="last">
<div><p>vectors with lon/lat values for each point at the border</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.get_border_geometry">
<tt class="descname">get_border_geometry</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Mosaic.get_border_geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Get OGR Geometry of the border Polygon</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>OGR Geometry</strong> : OGR Geometry (type Polygon)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.get_border_postgis">
<tt class="descname">get_border_postgis</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Mosaic.get_border_postgis" title="Permalink to this definition">¶</a></dt>
<dd><p>Get PostGIS formatted string of the border Polygon</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>str</strong> : PolygonFromText (PolygonWKT)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.get_border_wkt">
<tt class="descname">get_border_wkt</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Mosaic.get_border_wkt" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates string with WKT representation of the border polygon</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>WKTPolygon</strong> : string</p>
<blockquote class="last">
<div><p>string with WKT representation of the border polygon</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.get_corners">
<tt class="descname">get_corners</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Mosaic.get_corners" title="Permalink to this definition">¶</a></dt>
<dd><p>Get coordinates of corners of the Domain</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>lonVec, latVec</strong> : lists</p>
<blockquote class="last">
<div><p>vectors with lon/lat values for each corner</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.get_geolocation_grids">
<tt class="descname">get_geolocation_grids</tt><big>(</big><em>stepSize=1</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.get_geolocation_grids" title="Permalink to this definition">¶</a></dt>
<dd><p>Get longitude and latitude grids representing the full data grid</p>
<div class="line-block">
<div class="line">If GEOLOCATION is not present in the self.vrt.dataset then grids
are generated by converting pixel/line of each pixel into lat/lon</div>
<div class="line">If GEOLOCATION is present in the self.vrt.dataset then grids are read
from the geolocation bands.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>stepSize</strong> : int</p>
<blockquote>
<div><p>Reduction factor if output is desired on a reduced grid size</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>longitude</strong> : numpy array</p>
<blockquote>
<div><p>grid with longitudes</p>
</div></blockquote>
<p><strong>latitude</strong> : numpy array</p>
<blockquote class="last">
<div><p>grid with latitudes</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.get_metadata">
<tt class="descname">get_metadata</tt><big>(</big><em>key=None</em>, <em>bandID=None</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.get_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Get metadata from self.vrt.dataset</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>key</strong> : string, optional</p>
<blockquote>
<div><p>name of the metadata key. If not givem all metadata is returned</p>
</div></blockquote>
<p><strong>bandID</strong> : int or str, optional</p>
<blockquote>
<div><div class="line-block">
<div class="line">number or name of band to get metadata from.</div>
<div class="line">If not given, global metadata is returned</div>
</div>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>string</strong> : string with metadata if key is given</p>
<p class="last"><strong>dictionary</strong> : dictionary with all metadata if key is not given</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.get_pixelsize_meters">
<tt class="descname">get_pixelsize_meters</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Mosaic.get_pixelsize_meters" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pixelsize (deltaX, deltaY) of the domain</p>
<div class="line-block">
<div class="line">For projected domains, the exact result which is constant
over the domain is returned.</div>
<div class="line">For geographic (lon-lat) projections, or domains with no geotransform,
the haversine formula is used to calculate the pixel size
in the center of the domain.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>deltaX, deltaY</strong> : float</p>
<blockquote class="last">
<div><p>pixel size in X and Y directions given in meters</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.get_time">
<tt class="descname">get_time</tt><big>(</big><em>bandID=None</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.get_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Get time for dataset and/or its bands</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>bandID</strong> : int or str (default = None)</p>
<blockquote>
<div><p>band number or name</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>time</strong> : list with datetime objects for each band.</p>
<blockquote class="last">
<div><p>If time is the same for all bands, the list contains 1 item</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.get_transect">
<tt class="descname">get_transect</tt><big>(</big><em>points=None, bandList=[1], latlon=True, returnOGR=False, layerNum=0, smoothRadius=0, smoothAlg=0, transect=True, onlypixline=False, **kwargs</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.get_transect" title="Permalink to this definition">¶</a></dt>
<dd><p>Get transect from two poins and retun the values by numpy array</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>points</strong> : list with one or more points or shape file name</p>
<blockquote>
<div><div class="line-block">
<div class="line">i.e.</div>
<div class="line">[</div>
<div class="line-block">
<div class="line"># get all transect values</div>
<div class="line">[(lon_T1, lat_T1), (lon_T2, lat_T2), (lon_T3, lat_T3), ...]</div>
<div class="line"># get point values</div>
<div class="line">(lon_P1, lat_P1), (lon_P2, lat_P2), ...</div>
</div>
<div class="line">]</div>
<div class="line">or</div>
<div class="line">[</div>
<div class="line-block">
<div class="line"># get all transect values</div>
<div class="line">[(col_T1, row_T1), (col_T2, row_T2), (col_T3, row_T3), ...],</div>
<div class="line"># get point values</div>
<div class="line">(col_P1, row_P1), (col_P2, row_P2), ...</div>
</div>
<div class="line">]</div>
</div>
</div></blockquote>
<p><strong>bandList</strong> : list of int or string</p>
<blockquote>
<div><p>elements of the list are band number or band Name</p>
</div></blockquote>
<p><strong>latlon</strong> : bool</p>
<blockquote>
<div><div class="line-block">
<div class="line">If the points in lat/lon, then True.</div>
<div class="line">If the points in pixel/line, then False.</div>
</div>
</div></blockquote>
<p><strong>returnOGR</strong> : bool</p>
<blockquote>
<div><div class="line-block">
<div class="line">If True, then return numpy array</div>
<div class="line">If False, return OGR object</div>
</div>
</div></blockquote>
<p><strong>layerNum</strong> : int</p>
<blockquote>
<div><p>If shapefile is given as points, it is the number of the layer</p>
</div></blockquote>
<p><strong>smoothRadius</strong> : int</p>
<blockquote>
<div><p>If smootRadius is greater than 0, smooth every transect
pixel as the median or mean value in a circule with radius
equal to the given number.</p>
</div></blockquote>
<p><strong>smoothAlg</strong> : 0 or 1 for median or mean</p>
<p><strong>transect</strong> : bool</p>
<blockquote>
<div><div class="line-block">
<div class="line">used if a shape file name is given as the input.</div>
<div class="line">If True, return the transect. If False, return the points.</div>
</div>
</div></blockquote>
<p><strong>vmin, vmax</strong> : int (optional)</p>
<blockquote>
<div><p>minimum and maximum pixel values of an image shown
in case points is None.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>NansatOGR</strong> : nansatshape object (if retunOGR is True)</p>
<p><strong>transectDict</strong> : dictionary (if retunOGR is False)</p>
<blockquote>
<div><p>keys are band names.
Values are dictionaries of the transect values of each shape.</p>
</div></blockquote>
<p><strong>vectorsDict</strong> : dictionary (if retunOGR is False)</p>
<blockquote>
<div><p>keys are shape ID. values are dictionaries
with longitude and latitude lists of each shape.</p>
</div></blockquote>
<p><strong>pixlinCoordDic</strong> : dictionary (if retunOGR is False)</p>
<blockquote class="last">
<div><p>keys are shape ID. values are numpy array
with pixels and lines coordinates</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>If points are given from GUI,
it is possible to select multiple shapes by pressing any key</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.has_band">
<tt class="descname">has_band</tt><big>(</big><em>band</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.has_band" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if self has band with name &lt;band&gt;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>band</strong> : str</p>
<blockquote>
<div><p>name of the band to check</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>bool</strong> : if band exists or not</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.latest">
<tt class="descname">latest</tt><big>(</big><em>files=[], bands=[1], doReproject=True, maskName='mask', **kwargs</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.latest" title="Permalink to this definition">¶</a></dt>
<dd><p>Mosaic by adding the latest image on top without averaging</p>
<p>Uses Nansat.get_time() to estimate time of each input file;
Sorts images by aquisition time;
Creates date_index band - with mask of coverage of each frame;
Uses date_index to fill bands of self only with the latest data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>files</strong> : list</p>
<blockquote>
<div><p>list of input files</p>
</div></blockquote>
<p><strong>bands</strong> : list</p>
<blockquote>
<div><p>list of names/band_numbers to be processed</p>
</div></blockquote>
<p><strong>doReproject</strong> : boolean, [True]</p>
<blockquote>
<div><p>reproject input files?</p>
</div></blockquote>
<p><strong>maskName</strong> : str, [&#8216;mask&#8217;]</p>
<blockquote>
<div><p>name of the mask in input files</p>
</div></blockquote>
<p><strong>nClass</strong> : child of Nansat, [Nansat]</p>
<blockquote>
<div><p>This class is used to read input files</p>
</div></blockquote>
<p><strong>eResampleAlg</strong> : int, [0]</p>
<blockquote>
<div><p>agorithm for reprojection, see Nansat.reproject()</p>
</div></blockquote>
<p><strong>period</strong> : [datetime0, datetime1]</p>
<blockquote class="last">
<div><p>Start and stop datetime objects from pyhon datetime.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.list_bands">
<tt class="descname">list_bands</tt><big>(</big><em>doPrint=True</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.list_bands" title="Permalink to this definition">¶</a></dt>
<dd><p>Show band information of the given Nansat object</p>
<p>Show serial number, longName, name and all parameters
for each band in the metadata of the given Nansat object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>doPrint</strong> : boolean, optional, default=True</p>
<blockquote>
<div><p>do print, otherwise it is returned as string</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>outString</strong> : String</p>
<blockquote class="last">
<div><p>formatted string with bands info</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.median">
<tt class="descname">median</tt><big>(</big><em>files=[], bands=[1], doReproject=True, maskName='mask', **kwargs</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.median" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate median of input bands</p>
<p>Memory and CPU greedy method. Generates 3D cube from bands of
all input images and calculates median. Adds median bands to self</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>files</strong> : list</p>
<blockquote>
<div><p>list of input files</p>
</div></blockquote>
<p><strong>bands</strong> : list</p>
<blockquote>
<div><p>list of names/band_numbers to be processed</p>
</div></blockquote>
<p><strong>doReproject</strong> : boolean, [True]</p>
<blockquote>
<div><p>reproject input files?</p>
</div></blockquote>
<p><strong>maskName</strong> : str, [&#8216;mask&#8217;]</p>
<blockquote>
<div><p>name of the mask in input files</p>
</div></blockquote>
<p><strong>nClass</strong> : child of Nansat, [Nansat]</p>
<blockquote>
<div><p>This class is used to read input files</p>
</div></blockquote>
<p><strong>eResampleAlg</strong> : int, [0]</p>
<blockquote>
<div><p>agorithm for reprojection, see Nansat.reproject()</p>
</div></blockquote>
<p><strong>period</strong> : [datetime0, datetime1]</p>
<blockquote class="last">
<div><p>Start and stop datetime objects from pyhon datetime.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="nansat.Mosaic.nClass">
<tt class="descname">nClass</tt><a class="headerlink" href="#nansat.Mosaic.nClass" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#nansat.Nansat" title="nansat.Nansat"><tt class="xref py py-class docutils literal"><span class="pre">Nansat</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.reproject">
<tt class="descname">reproject</tt><big>(</big><em>dstDomain=None</em>, <em>eResampleAlg=0</em>, <em>blockSize=None</em>, <em>WorkingDataType=None</em>, <em>tps=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.reproject" title="Permalink to this definition">¶</a></dt>
<dd><p>Change projection of the object based on the given Domain</p>
<p>Create superVRT from self.vrt with AutoCreateWarpedVRT() using
projection from the dstDomain.
Modify XML content of the warped vrt using the Domain parameters.
Generate warpedVRT and replace self.vrt with warpedVRT.
If current object spans from 0 to 360 and dstDomain is west of 0,
the object is shifted by 180 westwards.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dstDomain</strong> : domain</p>
<blockquote>
<div><p>destination Domain where projection and resolution are set</p>
</div></blockquote>
<p><strong>eResampleAlg</strong> : int (GDALResampleAlg)</p>
<blockquote>
<div><div class="line-block">
<div class="line">0 : NearestNeighbour</div>
<div class="line">1 : Bilinear</div>
<div class="line">2 : Cubic,</div>
<div class="line">3 : CubicSpline</div>
<div class="line">4 : Lancoz</div>
</div>
</div></blockquote>
<p><strong>blockSize</strong> : int</p>
<blockquote>
<div><p>size of blocks for resampling. Large value decrease speed
but increase accuracy at the edge</p>
</div></blockquote>
<p><strong>WorkingDataType</strong> : int (GDT_int, ...)</p>
<blockquote>
<div><p>type of data in bands. Shuold be integer for int32 bands</p>
</div></blockquote>
<p><strong>tps</strong> : bool</p>
<blockquote>
<div><p>Apply Thin Spline Transformation if source or destination has GCPs
Usage of TPS can also be triggered by setting self.vrt.tps=True
before calling to reproject.
This options has priority over self.vrt.tps</p>
</div></blockquote>
<p><strong>skip_gcps</strong> : int</p>
<blockquote>
<div><p>Using TPS can be very slow if the number of GCPs are large.
If this parameter is given, only every [skip_gcp] GCP is used,
improving calculation time at the cost of accuracy.
If not given explicitly, &#8216;skip_gcps&#8217; is fetched from the
metadata of self, or from dstDomain (as set by mapper or user).
[defaults to 1 if not specified, i.e. using all GCPs]</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.vrt</strong> : VRT object with dataset replaced to warpedVRT dataset</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="line-block">
<div class="line">Integer data is returnd by integer. Round off to decimal place.</div>
<div class="line">If you do not want to round off, convert the data types
to GDT_Float32, GDT_Float64, or GDT_CFloat32.</div>
</div>
<p>see also: <a class="reference external" href="http://www.gdal.org/gdalwarp.html">http://www.gdal.org/gdalwarp.html</a></p>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.reproject_GCPs">
<tt class="descname">reproject_GCPs</tt><big>(</big><em>srsString</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.reproject_GCPs" title="Permalink to this definition">¶</a></dt>
<dd><p>Reproject all GCPs to a new spatial reference system</p>
<p>Necessary before warping an image if the given GCPs
are in a coordinate system which has a singularity
in (or near) the destination area (e.g. poles for lonlat GCPs)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>srsString</strong> : string</p>
<blockquote>
<div><p>SRS given as Proj4 string</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.vrt</strong> : Reprojects all GCPs to new SRS and updates GCPProjection</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.resize">
<tt class="descname">resize</tt><big>(</big><em>factor=1</em>, <em>width=None</em>, <em>height=None</em>, <em>pixelsize=None</em>, <em>eResampleAlg=-1</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.resize" title="Permalink to this definition">¶</a></dt>
<dd><p>Proportional resize of the dataset.</p>
<div class="line-block">
<div class="line">The dataset is resized as (xSize*factor, ySize*factor)</div>
<div class="line">If desired width, height or pixelsize is specified,
the scaling factor is calculated accordingly.</div>
<div class="line">If GCPs are given in a dataset, they are also rewritten.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>factor</strong> : float, optional, default=1</p>
<blockquote>
<div><div class="line-block">
<div class="line">Scaling factor for width and height</div>
<div class="line">&gt; 1 means increasing domain size</div>
<div class="line">&lt; 1 means decreasing domain size</div>
</div>
</div></blockquote>
<p><strong>width</strong> : int, optional</p>
<blockquote>
<div><p>Desired new width in pixels</p>
</div></blockquote>
<p><strong>height</strong> : int, optional</p>
<blockquote>
<div><p>Desired new height in pixels</p>
</div></blockquote>
<p><strong>pixelsize</strong> : float, optional</p>
<blockquote>
<div><div class="line-block">
<div class="line">Desired new pixelsize in meters (approximate).</div>
<div class="line">A factor is calculated from ratio of the</div>
<div class="line">current pixelsize to the desired pixelsize.</div>
</div>
</div></blockquote>
<p><strong>eResampleAlg</strong> : int (GDALResampleAlg), optional</p>
<blockquote>
<div><div class="line-block">
<div class="line">-1 : Average (default),</div>
<div class="line">0 : NearestNeighbour</div>
<div class="line">1 : Bilinear,</div>
<div class="line">2 : Cubic,</div>
<div class="line">3 : CubicSpline,</div>
<div class="line">4 : Lancoz</div>
</div>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.vrt.dataset</strong> : VRT dataset of VRT object</p>
<blockquote class="last">
<div><p>raster size are modified to downscaled size.
If GCPs are given in the dataset, they are also overwritten.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.set_metadata">
<tt class="descname">set_metadata</tt><big>(</big><em>key=''</em>, <em>value=''</em>, <em>bandID=None</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.set_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Set metadata to self.vrt.dataset</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>key</strong> : string or dictionary with strings</p>
<blockquote>
<div><p>name of the metadata, or dictionary with metadata names, values</p>
</div></blockquote>
<p><strong>value</strong> : string</p>
<blockquote>
<div><p>value of metadata</p>
</div></blockquote>
<p><strong>bandID</strong> : int or str</p>
<blockquote>
<div><p>number or name of band
Without : global metadata is set</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.vrt.dataset</strong> : sets metadata in GDAL current dataset</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.shape">
<tt class="descname">shape</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Mosaic.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Numpy-like shape of Domain object (ySize, xSize)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>shape</strong> : tuple of two INT</p>
<blockquote class="last">
<div><p>Numpy-like shape of Domain object (ySize, xSize)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.transform_points">
<tt class="descname">transform_points</tt><big>(</big><em>colVector</em>, <em>rowVector</em>, <em>DstToSrc=0</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.transform_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform given lists of X,Y coordinates into lon/lat or inverse</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>colVector</strong> : lists</p>
<blockquote>
<div><p>X and Y coordinates in pixel/line or lon/lat  coordinate system</p>
</div></blockquote>
<p><strong>DstToSrc</strong> : 0 or 1</p>
<blockquote>
<div><p>0 - forward transform (pix/line =&gt; lon/lat)
1 - inverse transformation</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>X, Y</strong> : lists</p>
<blockquote class="last">
<div><p>X and Y coordinates in lon/lat or pixel/line coordinate system</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.undo">
<tt class="descname">undo</tt><big>(</big><em>steps=1</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.undo" title="Permalink to this definition">¶</a></dt>
<dd><p>Undo reproject, resize, add_band or crop of Nansat object</p>
<p>Restore the self.vrt from self.vrt.vrt</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>steps</strong> : int</p>
<blockquote>
<div><p>How many steps back to undo</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.vrt</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.watermask">
<tt class="descname">watermask</tt><big>(</big><em>mod44path=None</em>, <em>dstDomain=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.watermask" title="Permalink to this definition">¶</a></dt>
<dd><p>Create numpy array with watermask (water=1, land=0)</p>
<p>250 meters resolution watermask from MODIS 44W Product:
<a class="reference external" href="http://www.glcf.umd.edu/data/watermask/">http://www.glcf.umd.edu/data/watermask/</a></p>
<div class="line-block">
<div class="line">Watermask is stored as tiles in TIF(LZW) format and a VRT file</div>
<div class="line">All files are stored in one directory.</div>
<div class="line">A tarball with compressed TIF and VRT files should be additionally
downloaded from the Nansat wiki:</div>
<div class="line"><a class="reference external" href="https://svn.nersc.no/nansat/wiki/Nansat/Data/Watermask">https://svn.nersc.no/nansat/wiki/Nansat/Data/Watermask</a></div>
</div>
<div class="line-block">
<div class="line">The method :</div>
<div class="line">Gets the directory either from input parameter or from environment
variable MOD44WPATH</div>
<div class="line">Open Nansat object from the VRT file</div>
<div class="line">Reprojects the watermask onto the current object using reproject()
or reproject_on_jcps()</div>
<div class="line">Returns the reprojected Nansat object</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mod44path</strong> : string, optional, default=None</p>
<blockquote>
<div><p>path with MOD44W Products and a VRT file</p>
</div></blockquote>
<p><strong>dstDomain</strong> : Domain</p>
<blockquote>
<div><p>destination domain other than self</p>
</div></blockquote>
<p><strong>tps</strong> : Bool</p>
<blockquote>
<div><p>Use Thin Spline Transformation in reprojection of watermask?
See also Nansat.reproject()</p>
</div></blockquote>
<p><strong>skip_gcps</strong> : int</p>
<blockquote>
<div><p>Factor to reduce the number of GCPs by and increase speed
See also Nansat.reproject()</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>watermask</strong> : Nansat object with water mask in current projection</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>250 meters resolution watermask from MODIS 44W Product:
<a class="reference external" href="http://www.glcf.umd.edu/data/watermask/">http://www.glcf.umd.edu/data/watermask/</a></p>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.write_figure">
<tt class="descname">write_figure</tt><big>(</big><em>fileName=None</em>, <em>bands=1</em>, <em>clim=None</em>, <em>addDate=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.write_figure" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a raster band to a figure in graphical format.</p>
<div class="line-block">
<div class="line">Get numpy array from the band(s) and band information specified
either by given band number or band id.</div>
<div class="line">If three bands are given, merge them and create PIL image.</div>
<div class="line">If one band is given, create indexed image</div>
<div class="line">Create Figure object and:</div>
<div class="line">Adjust the array brightness and contrast using the given min/max or
histogram.</div>
<div class="line">Apply logarithmic scaling of color tone.</div>
<div class="line">Generate and append legend.</div>
<div class="line">Save the PIL output image in PNG or any other graphical format.</div>
<div class="line">If the filename extension is &#8216;tif&#8217;, the figure file is converted
to GeoTiff</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : string, optional</p>
<blockquote>
<div><div class="line-block">
<div class="line">Output file name. if one of extensions &#8216;png&#8217;, &#8216;PNG&#8217;, &#8216;tif&#8217;,
&#8216;TIF&#8217;, &#8216;bmp&#8217;, &#8216;BMP&#8217;, &#8216;jpg&#8217;, &#8216;JPG&#8217;, &#8216;jpeg&#8217;, &#8216;JPEG&#8217; is included,
specified file is crated. otherwise, &#8216;png&#8217; file is created.</div>
<div class="line">if None, the figure object is returned.</div>
<div class="line">if True, the figure is shown</div>
</div>
</div></blockquote>
<p><strong>bands</strong> : integer or string or list (elements are integer or string),</p>
<blockquote>
<div><div class="line-block">
<div class="line">default = 1</div>
<div class="line">the size of the list has to be 1 or 3.</div>
<div class="line">if the size is 3, RGB image is created based on the three bands.</div>
<div class="line">Then the first element is Red, the second is Green,
and the third is Blue.</div>
</div>
</div></blockquote>
<p><strong>clim</strong> : list with two elements or &#8216;hist&#8217; to specify range of colormap</p>
<blockquote>
<div><div class="line-block">
<div class="line">None (default) : min/max values are fetched from WKV,
fallback-&#8216;hist&#8217;</div>
<div class="line">[min, max] : min and max are numbers, or
[[min, min, min], [max, max, max]]: three bands used</div>
<div class="line">&#8216;hist&#8217; : a histogram is used to calculate min and max values</div>
</div>
</div></blockquote>
<p><strong>addDate</strong> : boolean</p>
<blockquote>
<div><div class="line-block">
<div class="line">False (default) : no date will be aded to the caption</div>
<div class="line">True : the first time of the object will be added to the caption</div>
</div>
</div></blockquote>
<p><strong>**kwargs</strong> : parameters for Figure().</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>if fileName is specified, creates image file</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>Figure object</strong> : Figure object</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Write only indexed image, color limits from WKV or from histogram</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">write_figure</span><span class="p">(</span><span class="s">&#39;test.jpg&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Write only RGB image, color limits from histogram</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">write_figure</span><span class="p">(</span><span class="s">&#39;test_rgb_hist.jpg&#39;</span><span class="p">,</span> <span class="n">clim</span><span class="o">=</span><span class="s">&#39;hist&#39;</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
<p>Write indexed image, apply log scaling and gamma correction,
add legend and type in title &#8216;Title&#8217;, increase font size and put 15
tics</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">write_figure</span><span class="p">(</span><span class="s">&#39;r09_log3_leg.jpg&#39;</span><span class="p">,</span> <span class="n">logarithm</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">legend</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                <span class="n">gamma</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">titleString</span><span class="o">=</span><span class="s">&#39;Title&#39;</span><span class="p">,</span> <span class="n">fontSize</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                <span class="n">numOfTicks</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
</pre></div>
</div>
<p>Write an image to png with transparent Mask set to color
transparency=[0,0,0], following PIL alpha mask</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">write_figure</span><span class="p">(</span><span class="n">fileName</span><span class="o">=</span><span class="s">&#39;transparent.png&#39;</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
<span class="gp">&gt;&gt;&gt; </span>               <span class="n">mask_array</span><span class="o">=</span><span class="n">wmArray</span><span class="p">,</span> <span class="n">mask_lut</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]},</span>
<span class="gp">&gt;&gt;&gt; </span>               <span class="n">clim</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.15</span><span class="p">],</span> <span class="n">cmapName</span><span class="o">=</span><span class="s">&#39;gray&#39;</span><span class="p">,</span> <span class="n">transparency</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<dl class="docutils">
<dt>see also Figure() :</dt>
<dd><a class="reference external" href="http://www.scipy.org/Cookbook/Matplotlib/Show_colormaps">http://www.scipy.org/Cookbook/Matplotlib/Show_colormaps</a></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.write_geotiffimage">
<tt class="descname">write_geotiffimage</tt><big>(</big><em>fileName</em>, <em>bandID=1</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.write_geotiffimage" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes an 8-bit GeoTiff image for a given band.</p>
<div class="line-block">
<div class="line">The output GeoTiff image is convenient e.g. for display in a GIS tool.</div>
<div class="line">Colormap is fetched from the metadata item &#8216;colormap&#8217;.
Fallback colormap is &#8216;jet&#8217;.</div>
<div class="line">Color limits are fetched from the metadata item &#8216;minmax&#8217;.</div>
<div class="line">If &#8216;minmax&#8217; is not specified, min and max of raster is used.</div>
</div>
<div class="line-block">
<div class="line">The method can be replaced by using nansat.write_figure(),
however, write_figure uses PIL which does not allow
Tiff compression, giving much larger files</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : string</p>
<p class="last"><strong>bandID</strong> : integer or string(default = 1)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.write_kml">
<tt class="descname">write_kml</tt><big>(</big><em>xmlFileName=None</em>, <em>kmlFileName=None</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.write_kml" title="Permalink to this definition">¶</a></dt>
<dd><p>Write KML file with domains</p>
<p>Convert XML-file with domains into KML-file for GoogleEarth
or write KML-file with the current Domain</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xmlFileName</strong> : string, optional</p>
<blockquote>
<div><p>Name of the XML-file to convert. If only this value is given
- kmlFileName=xmlFileName+&#8217;.kml&#8217;</p>
</div></blockquote>
<p><strong>kmlFileName</strong> : string, optional</p>
<blockquote class="last">
<div><p>Name of the KML-file to generate from the current Domain</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.write_kml_image">
<tt class="descname">write_kml_image</tt><big>(</big><em>kmlFileName=None</em>, <em>kmlFigureName=None</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.write_kml_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Create KML file for already projected image</p>
<p>Write Domain Image into KML-file for GoogleEarth</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>kmlFileName</strong> : string, optional</p>
<blockquote>
<div><p>Name of the KML-file to generate from the current Domain</p>
</div></blockquote>
<p><strong>kmlFigureName</strong> : string, optional</p>
<blockquote class="last">
<div><p>Name of the projected image stored in .png format</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="line-block">
<div class="line">First of all, reproject an image into Lat/Lon WGS84
(Simple Cylindrical) projection</div>
<div class="line">1. Cancel previous reprojection</div>
<div class="line">2. Get corners of the image and the pixel resolution</div>
<div class="line">3. Create Domain with stereographic projection,
corner coordinates and resolution 1000m</div>
<div class="line">4. Reproject</div>
<div class="line">5. Write image</div>
<div class="line">6. Write KML for the image</div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">reproject</span><span class="p">()</span>  <span class="c"># 1.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">get_corners</span><span class="p">()</span>  <span class="c"># 2.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">srsString</span> <span class="o">=</span> <span class="s">&#39;+proj=latlong +datum=WGS84 +ellps=WGS84 +no_defs&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">extentString</span> <span class="o">=</span> <span class="s">&#39;-lle </span><span class="si">%f</span><span class="s"> </span><span class="si">%f</span><span class="s"> </span><span class="si">%f</span><span class="s"> </span><span class="si">%f</span><span class="s"> -ts 3000 3000&#39;</span>
<span class="gp">&gt;&gt;&gt; </span>                <span class="o">%</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">lons</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">lats</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">lons</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">lats</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">Domain</span><span class="p">(</span><span class="n">srs</span><span class="o">=</span><span class="n">srsString</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">extentString</span><span class="p">)</span>  <span class="c"># 3.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">reproject</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>  <span class="c"># 4.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">write_figure</span><span class="p">(</span><span class="n">fileName</span><span class="o">=</span><span class="n">figureName</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">clim</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.15</span><span class="p">],</span>
<span class="gp">&gt;&gt;&gt; </span>               <span class="n">cmapName</span><span class="o">=</span><span class="s">&#39;gray&#39;</span><span class="p">,</span> <span class="n">transparency</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c"># 5.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">write_kml_image</span><span class="p">(</span><span class="n">kmlFileName</span><span class="o">=</span><span class="n">oPath</span> <span class="o">+</span> <span class="n">fileName</span> <span class="o">+</span> <span class="s">&#39;.kml&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">kmlFigureName</span><span class="o">=</span><span class="n">figureName</span><span class="p">)</span>  <span class="c"># 6.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.write_map">
<tt class="descname">write_map</tt><big>(</big><em>outputFileName, lonVec=None, latVec=None, lonBorder=10.0, latBorder=10.0, figureSize=(6, 6), dpi=50, projection='cyl', resolution='c', continetsColor='coral', meridians=10, parallels=10, pColor='r', pLine='k', pAlpha=0.5, padding=0.0, merLabels=[False, False, False, False], parLabels=[False, False, False, False], pltshow=False</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.write_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an image with a map of the domain</p>
<div class="line-block">
<div class="line">Uses Basemap to create a World Map</div>
<div class="line">Adds a semitransparent patch with outline of the Domain</div>
<div class="line">Writes to an image file</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>outputFileName</strong> : string</p>
<blockquote>
<div><p>name of the output file name</p>
</div></blockquote>
<p><strong>lonBorder</strong> : float</p>
<blockquote>
<div><p>10, horisontal border around patch (degrees of longitude)</p>
</div></blockquote>
<p><strong>latBorder</strong> : float</p>
<blockquote>
<div><p>10, vertical border around patch (degrees of latitude)</p>
</div></blockquote>
<p><strong>figureSize</strong> : tuple of two integers</p>
<blockquote>
<div><p>(6, 6), size of the generated figure in inches</p>
</div></blockquote>
<p><strong>dpi: int</strong></p>
<blockquote>
<div><p>50, resolution of the output figure (size 6,6 and dpi 50
produces 300 x 300 figure)</p>
</div></blockquote>
<p><strong>projection</strong> : string, one of Basemap projections</p>
<blockquote>
<div><p>&#8216;cyl&#8217;, projection of the map</p>
</div></blockquote>
<p><strong>resolution</strong> : string, resolution of the map</p>
<blockquote>
<div><div class="line-block">
<div class="line">&#8216;c&#8217;, crude</div>
<div class="line">&#8216;l&#8217;, low</div>
<div class="line">&#8216;i&#8217;, intermediate</div>
<div class="line">&#8216;h&#8217;, high</div>
<div class="line">&#8216;f&#8217;, full</div>
</div>
</div></blockquote>
<p><strong>continetsColor</strong> : string or any matplotlib color representation</p>
<blockquote>
<div><p>&#8216;coral&#8217;, color of continets</p>
</div></blockquote>
<p><strong>meridians</strong> : int</p>
<blockquote>
<div><p>10, number of meridians to draw</p>
</div></blockquote>
<p><strong>parallels</strong> : int</p>
<blockquote>
<div><p>10, number of parallels to draw</p>
</div></blockquote>
<p><strong>pColor</strong> : string or any matplotlib color representation</p>
<blockquote>
<div><p>&#8216;r&#8217;, color of the Domain patch</p>
</div></blockquote>
<p><strong>pLine</strong> : string or any matplotlib color representation</p>
<blockquote>
<div><p>&#8216;k&#8217;, color of the Domain outline</p>
</div></blockquote>
<p><strong>pAlpha</strong> : float 0 - 1</p>
<blockquote>
<div><p>0.5, transparency of Domain patch</p>
</div></blockquote>
<p><strong>padding</strong> : float</p>
<blockquote>
<div><p>0., width of white padding around the map</p>
</div></blockquote>
<p><strong>merLabels</strong> : list of 4 booleans</p>
<blockquote>
<div><p>where to put meridian labels, see also Basemap.drawmeridians()</p>
</div></blockquote>
<p><strong>parLables</strong> : list of 4 booleans</p>
<blockquote class="last">
<div><p>where to put parallel labels, see also Basemap.drawparallels()</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>

    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2013, Nansen Center.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.3.
      </li>
    </ul>
    </div>
    </div>
    </div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-43252602-1', 'nansencenter.github.io');
  ga('send', 'pageview');

</script>

  </body>
</html>