<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>nansat package &mdash; Nansat 0.1 documentation</title>
    
    <link rel="stylesheet" type="text/css" href="_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="_static/css/spc-extend.css">
    <link rel="stylesheet" href="_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/js/copybutton.js"></script>
    <link rel="top" title="Nansat 0.1 documentation" href="index.html" >
    <link rel="next" title="nansat.domain module" href="nansat.domain.html" >
    <link rel="prev" title="Welcome to nansat’s documentation!" href="index.html" > 
  </head>
  <body>

<div class="container">
  <div class="top-scipy-org-logo-header">
    <a href="../index.html">
      <img style="border: 0;" alt="SciPy" src="_static/img/nansat_logo.gif"></a>
    </div>
  </div>
</div>


    <div class="container">
      <div class="main">
        

	<div class="row-fluid">
          <div class="span9">
            
	      <div class="row-fluid">
		<div class="span9">
  		  <div class="spc-navbar">
		    
    <ul class="nav nav-pills pull-left">
	
        <li class="active"><a href="../index.html">Nansat 0.1 documentation</a></li>
	 
    </ul>
		  </div>
		</div>
	      </div>
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <div class="section" id="nansat-package">
<h1>nansat package<a class="headerlink" href="#nansat-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="nansat.domain.html">nansat.domain module</a></li>
<li class="toctree-l1"><a class="reference internal" href="nansat.figure.html">nansat.figure module</a></li>
<li class="toctree-l1"><a class="reference internal" href="nansat.geolocationarray.html">nansat.geolocationarray module</a></li>
<li class="toctree-l1"><a class="reference internal" href="nansat.mosaic.html">nansat.mosaic module</a></li>
<li class="toctree-l1"><a class="reference internal" href="nansat.nansat.html">nansat.nansat module</a></li>
<li class="toctree-l1"><a class="reference internal" href="nansat.nansat_tools.html">nansat.nansat_tools module</a></li>
<li class="toctree-l1"><a class="reference internal" href="nansat.nansatmap.html">nansat.nansatmap module</a></li>
<li class="toctree-l1"><a class="reference internal" href="nansat.nansatshape.html">nansat.nansatshape module</a></li>
<li class="toctree-l1"><a class="reference internal" href="nansat.vrt.html">nansat.vrt module</a></li>
</ul>
</div>
</div>
<div class="section" id="module-nansat">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-nansat" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nansat.Nansat">
<em class="property">class </em><tt class="descclassname">nansat.</tt><tt class="descname">Nansat</tt><big>(</big><em>fileName=''</em>, <em>mapperName=''</em>, <em>domain=None</em>, <em>array=None</em>, <em>parameters=None</em>, <em>logLevel=30</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansat" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">nansat.domain.Domain</span></tt></p>
<p>Container for geospatial data, performs all high-level operations</p>
<div class="line-block">
<div class="line">n = Nansat(fileName) opens the file with satellite or model data for
reading, adds scientific metadata to bands, and prepares the data for
further handling.</div>
<div class="line">The instance of Nansat class (the object &lt;n&gt;) contains information
about geographical reference of the data (e.g raster size, pixel
resolution, type of projection, etc) and about bands with values of
geophysical variables (e.g. water leaving radiance, normalized radar
cross section, chlrophyll concentraion, etc). The object has methods
for high-level operations with data. E.g.:</div>
<div class="line-block">
<div class="line">- reading data from file (Nansat.__getitem__)</div>
<div class="line">- visualization (Nansat.write_figure)</div>
<div class="line">- changing geographical reference (Nansat.reproject)</div>
<div class="line">- exporting (Nansat.export)</div>
<div class="line">- and much more...</div>
<div class="line"><br /></div>
</div>
<div class="line">Nansat inherits from Domain (container of geo-reference information)</div>
<div class="line">Nansat uses instance of VRT (wraper around GDAL VRT-files)</div>
<div class="line">Nansat uses instance of Figure (collection of methods for visualization)</div>
</div>
<dl class="method">
<dt id="nansat.Nansat.add_band">
<tt class="descname">add_band</tt><big>(</big><em>array</em>, <em>parameters=None</em>, <em>nomem=False</em><big>)</big><a class="headerlink" href="#nansat.Nansat.add_band" title="Permalink to this definition">¶</a></dt>
<dd><p>Add band from the array to self.vrt</p>
<p>Create VRT object which contains VRT and RAW binary file and append
it to self.vrt.subVRTs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>array</strong> : Numpy array with band data</p>
<p><strong>parameters</strong> : dictionary, band metadata: wkv, name, etc.</p>
<p><strong>nomem</strong> : boolean, saves the vrt to a tempfile if nomem is True</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Creates:</th><td class="field-body"><p class="first"><strong>VRT object</strong> : VRT object with VRT-file and RAW-file</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.vrt</strong> : Add a band</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.bands">
<tt class="descname">bands</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Nansat.bands" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a dictionary with all bands metadata</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>b</strong> : dictionary</p>
<blockquote class="last">
<div><p>key = N, value = dict with all band metadata</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.crop">
<tt class="descname">crop</tt><big>(</big><em>xOff=0</em>, <em>yOff=0</em>, <em>xSize=None</em>, <em>ySize=None</em>, <em>lonlim=None</em>, <em>latlim=None</em><big>)</big><a class="headerlink" href="#nansat.Nansat.crop" title="Permalink to this definition">¶</a></dt>
<dd><p>Crop Nansat object</p>
<div class="line-block">
<div class="line">Create superVRT, modify the Source Rectangle (SrcRect) and
Destination.</div>
<div class="line">Rectangle (DstRect) tags in the VRT file for each band in order
to take only part of the original image, create new GCPs or
new GeoTransform for the cropped object.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xOff</strong> : int</p>
<blockquote>
<div><p>pixel offset of subimage</p>
</div></blockquote>
<p><strong>yOff</strong> : int</p>
<blockquote>
<div><p>line offset of subimage</p>
</div></blockquote>
<p><strong>xSize</strong> : int</p>
<blockquote>
<div><p>width in pixels of subimage</p>
</div></blockquote>
<p><strong>ySize</strong> : int</p>
<blockquote>
<div><p>height in pizels of subimage</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Creates:</th><td class="field-body"><p class="first"><strong>superVRT</strong> : VRT with modified SrcRect and DstRect</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.vrt</strong> : VRT</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>status</strong> : int</p>
<blockquote class="last">
<div><div class="line-block">
<div class="line">0 - everyhting is OK, image is cropped</div>
<div class="line">1 - if crop is totally outside, image is NOT cropped</div>
<div class="line">2 - crop area is too large and crop is not needed</div>
</div>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.export">
<tt class="descname">export</tt><big>(</big><em>fileName</em>, <em>rmMetadata=</em>, <span class="optional">[</span><span class="optional">]</span><em>addGeolocArray=True</em>, <em>addGCPs=True</em>, <em>driver='netCDF'</em>, <em>bottomup=False</em><big>)</big><a class="headerlink" href="#nansat.Nansat.export" title="Permalink to this definition">¶</a></dt>
<dd><p>Export Nansat object into netCDF or GTiff file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : str</p>
<blockquote>
<div><p>output file name</p>
</div></blockquote>
<p><strong>rmMetadata</strong> : list</p>
<blockquote>
<div><div class="line-block">
<div class="line">metadata names for removal before export.</div>
<div class="line">e.g. [&#8216;name&#8217;, &#8216;colormap&#8217;, &#8216;source&#8217;, &#8216;sourceBands&#8217;]</div>
</div>
</div></blockquote>
<p><strong>addGeolocArray</strong> : bool</p>
<blockquote>
<div><p>add geolocation array datasets to exported file?</p>
</div></blockquote>
<p><strong>addGCPs</strong> : bool</p>
<blockquote>
<div><p>add GCPs?  to exported file?</p>
</div></blockquote>
<p><strong>driver</strong> : str</p>
<blockquote>
<div><p>Name of GDAL driver (format)</p>
</div></blockquote>
<p><strong>bottomup</strong> : bool</p>
<blockquote>
<div><div class="line-block">
<div class="line">False : Write swath-projected data with rows and columns
organized as in the original product.</div>
<div class="line">True : Use the default behaviour of GDAL, which is to flip
the rows</div>
</div>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Creates:</th><td class="field-body"><p class="first last"><strong>a netCDF file</strong></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="line-block">
<div class="line">If number of bands is more than one, serial numbers are
added at the end of each band name.</div>
<div class="line">It is possible to fix it by changing
line.4605 in GDAL/frmts/netcdf/netcdfdataset.cpp :</div>
<div class="line">&#8216;if( nBands &gt; 1 ) sprintf(szBandName,&#8221;%s%d&#8221;,tmpMetadata,iBand);&#8217;</div>
<div class="line">&#8211;&gt; &#8216;if( nBands &gt; 1 ) sprintf(szBandName,&#8221;%s&#8221;,tmpMetadata);&#8217;</div>
<div class="line">CreateCopy fails in case the band name has special characters,</div>
<div class="line">e.g. the slash in &#8216;HH/VV&#8217;.</div>
</div>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.export_band">
<tt class="descname">export_band</tt><big>(</big><em>fileName</em>, <em>bandID=1</em>, <em>driver='netCDF'</em><big>)</big><a class="headerlink" href="#nansat.Nansat.export_band" title="Permalink to this definition">¶</a></dt>
<dd><p>Export only one band of the Nansat object</p>
<div class="line-block">
<div class="line">Get array from the required band</div>
<div class="line">Create temporary Nansat from the array</div>
<div class="line">Export temporary Nansat to file</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : str</p>
<blockquote>
<div><p>name of the output file</p>
</div></blockquote>
<p><strong>bandID</strong> : int or str, [1]</p>
<blockquote>
<div><p>number of name of the band</p>
</div></blockquote>
<p><strong>driver</strong> : str, [&#8216;netCDF&#8217;]</p>
<blockquote class="last">
<div><p>name of the GDAL Driver (format) to use</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.get_GDALRasterBand">
<tt class="descname">get_GDALRasterBand</tt><big>(</big><em>bandID=1</em><big>)</big><a class="headerlink" href="#nansat.Nansat.get_GDALRasterBand" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a GDALRasterBand of a given Nansat object</p>
<div class="line-block">
<div class="line">If str is given find corresponding band number.</div>
<div class="line">If int is given check if band with this number exists.</div>
<div class="line">Get a GDALRasterBand from vrt.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>bandID</strong> : serial number or string, optional (default is 1)</p>
<blockquote>
<div><div class="line-block">
<div class="line">if number - a band number of the band to fetch</div>
<div class="line">if string - bandID = {&#8216;name&#8217;: bandID}</div>
</div>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">GDAL RasterBand</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Get a raster band</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># get a band from the band number</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">get_GDALRasterBand</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="c"># get a band from the name</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">get_GDALRasterBand</span><span class="p">(</span><span class="s">&#39;sigma0&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.get_metadata">
<tt class="descname">get_metadata</tt><big>(</big><em>key=None</em>, <em>bandID=None</em><big>)</big><a class="headerlink" href="#nansat.Nansat.get_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Get metadata from self.vrt.dataset</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>key</strong> : string, optional</p>
<blockquote>
<div><p>name of the metadata key. If not givem all metadata is returned</p>
</div></blockquote>
<p><strong>bandID</strong> : int or str, optional</p>
<blockquote>
<div><p>number or name of band to get metadata from.
If not given, global metadata is returned</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>string</strong> : a string with metadata</p>
<blockquote>
<div><div class="line-block">
<div class="line">if key is given and found an empty string</div>
<div class="line">if key is given and not found</div>
</div>
</div></blockquote>
<p><strong>dictionary</strong> : a dictionary with all metadata</p>
<blockquote class="last">
<div><p>if key is not given</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.get_time">
<tt class="descname">get_time</tt><big>(</big><em>bandID=None</em><big>)</big><a class="headerlink" href="#nansat.Nansat.get_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Get time for dataset and/or its bands</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>bandID</strong> : int or str (default = None)</p>
<blockquote>
<div><p>band number or name</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>time</strong> : list with datetime objects for each band.</p>
<blockquote class="last">
<div><p>If time is the same for all bands, the list contains 1 item</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.get_transect">
<tt class="descname">get_transect</tt><big>(</big><em>points=None, bandList=[1], latlon=True, transect=True, returnOGR=False, layerNum=0, smoothRadius=0, smoothAlg=0, **kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansat.get_transect" title="Permalink to this definition">¶</a></dt>
<dd><p>Get transect from two poins and retun the values by numpy array</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>points</strong> : tuple with one or more points or shape file name</p>
<blockquote>
<div><div class="line-block">
<div class="line">i.e. ((lon1, lat1),(lon2, lat2),(lon3, lat3), ...) or</div>
<div class="line-block">
<div class="line">((col1, row1),(col2, row2),(col3, row3), ...)</div>
</div>
</div>
</div></blockquote>
<p><strong>bandList</strong> : list of int or string</p>
<blockquote>
<div><p>elements of the list are band number or band Name</p>
</div></blockquote>
<p><strong>latlon</strong> : bool</p>
<blockquote>
<div><p>If the points in lat/lon, then True.
If the points in pixel/line, then False.</p>
</div></blockquote>
<p><strong>transect</strong> : bool</p>
<blockquote>
<div><p>If True, get all transact values
If False, get values of points</p>
</div></blockquote>
<p><strong>returnOGR: bool</strong></p>
<blockquote>
<div><p>If True, then return numpy array
If False, return OGR object</p>
</div></blockquote>
<p><strong>layerNum: int</strong></p>
<blockquote>
<div><p>If shapefile is given as points, it is the number of the layer</p>
</div></blockquote>
<p><strong>smoothRadius: int</strong></p>
<blockquote>
<div><p>If smootRadius is greater than 0, smooth every transect
pixel as the median or mean value in a circule with radius
equal to the given number.</p>
</div></blockquote>
<p><strong>smoothAlg: 0 or 1 for median or mean</strong></p>
<p><strong>vmin, vmax</strong> : int (optional)</p>
<blockquote>
<div><p>minimum and maximum pixel values of an image shown
in case points is None.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>if returnOGR = True</strong></p>
<blockquote>
<div><p><strong>transect</strong> : OGR object with points coordinates and values</p>
</div></blockquote>
<p><strong>if returnOGR = False</strong></p>
<blockquote>
<div><p><strong>transect</strong> : list or values of the transect or
OGR object with the transect values</p>
</div></blockquote>
<p><strong>[lonVector, latVector]</strong> : list with longitudes, latitudes</p>
<p class="last"><strong>pixlinCoord</strong> : numpy array with pixels and lines coordinates</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.has_band">
<tt class="descname">has_band</tt><big>(</big><em>band</em><big>)</big><a class="headerlink" href="#nansat.Nansat.has_band" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if self has band with name &lt;band&gt;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>band</strong> : str</p>
<blockquote>
<div><p>name of the band to check</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>bool</strong> : True/False if band exists or not</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.list_bands">
<tt class="descname">list_bands</tt><big>(</big><em>doPrint=True</em><big>)</big><a class="headerlink" href="#nansat.Nansat.list_bands" title="Permalink to this definition">¶</a></dt>
<dd><p>Show band information of the given Nansat object</p>
<p>Show serial number, longName, name and all parameters
for each band in the metadata of the given Nansat object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>doPrint</strong> : boolean, optional, default=True</p>
<blockquote>
<div><p>do print, otherwise it is returned as string</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>outString</strong> : String</p>
<blockquote class="last">
<div><p>formatted string with bands info</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.process">
<tt class="descname">process</tt><big>(</big><em>opts=None</em><big>)</big><a class="headerlink" href="#nansat.Nansat.process" title="Permalink to this definition">¶</a></dt>
<dd><p>Default L2 processing of Nansat object. Overloaded in childs.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.reproject">
<tt class="descname">reproject</tt><big>(</big><em>dstDomain=None</em>, <em>eResampleAlg=0</em>, <em>blockSize=None</em>, <em>WorkingDataType=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansat.reproject" title="Permalink to this definition">¶</a></dt>
<dd><p>Change projection of the object based on the given Domain</p>
<div class="line-block">
<div class="line">Create superVRT from self.vrt with AutoCreateWarpedVRT() using
projection from the dstDomain.</div>
<div class="line">Modify XML content of the warped vrt using the Domain parameters.</div>
<div class="line">Generate warpedVRT and replace self.vrt with warpedVRT.</div>
<div class="line">If current object spans from 0 to 360 and dstDomain is west of 0,
the object is shifted by 180 westwards.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dstDomain</strong> : domain</p>
<blockquote>
<div><p>destination Domain where projection and resolution are set</p>
</div></blockquote>
<p><strong>eResampleAlg</strong> : int (GDALResampleAlg)</p>
<blockquote>
<div><div class="line-block">
<div class="line">0 : NearestNeighbour</div>
<div class="line">1 : Bilinear</div>
<div class="line">2 : Cubic,</div>
<div class="line">3 : CubicSpline</div>
<div class="line">4 : Lancoz</div>
</div>
</div></blockquote>
<p><strong>blockSize</strong> : int</p>
<blockquote>
<div><p>size of blocks for resampling. Large value decrease speed
but increase accuracy at the edge</p>
</div></blockquote>
<p><strong>WorkingDataType</strong> : int (GDT_int, ...)</p>
<blockquote>
<div><p>type of data in bands. Shuold be integer for int32 bands</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.vrt</strong> : VRT object with dataset replaced to warpedVRT dataset</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>gdalwarp : <a class="reference external" href="http://www.gdal.org/gdalwarp.html">http://www.gdal.org/gdalwarp.html</a></p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.resize">
<tt class="descname">resize</tt><big>(</big><em>factor=1</em>, <em>width=None</em>, <em>height=None</em>, <em>pixelsize=None</em>, <em>eResampleAlg=-1</em><big>)</big><a class="headerlink" href="#nansat.Nansat.resize" title="Permalink to this definition">¶</a></dt>
<dd><p>Proportional resize of the dataset.</p>
<div class="line-block">
<div class="line">The dataset is resized as (xSize*factor, ySize*factor)</div>
<div class="line">If desired width, height or pixelsize is specified,
the scaling factor is calculated accordingly.</div>
<div class="line">If GCPs are given in a dataset, they are also rewritten.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>factor</strong> : float, optional, default=1</p>
<blockquote>
<div><div class="line-block">
<div class="line">scaling factor for width and height</div>
<div class="line">&gt;1 : increasing domain size</div>
<div class="line">&lt;1 : decreasing domain size</div>
</div>
</div></blockquote>
<p><strong>width</strong> : int, optional</p>
<blockquote>
<div><p>Desired new width in pixels</p>
</div></blockquote>
<p><strong>height</strong> : int, optional</p>
<blockquote>
<div><p>Desired new height in pixels</p>
</div></blockquote>
<p><strong>pixelsize</strong> : float, optional</p>
<blockquote>
<div><p>Desired new pixelsize in meters (approximate).
A factor is calculated from ratio of the
current pixelsize to the desired pixelsize.</p>
</div></blockquote>
<p><strong>eResampleAlg</strong> : int (GDALResampleAlg), optional</p>
<blockquote>
<div><div class="line-block">
<div class="line">-1 : Average</div>
<div class="line">0 : NearestNeighbour</div>
<div class="line">1 : Bilinear</div>
<div class="line">2 : Cubic</div>
<div class="line">3 : CubicSpline</div>
<div class="line">4 : Lancoz</div>
</div>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.vrt.dataset</strong> : raster size are modified to downscaled size.</p>
<blockquote class="last">
<div><p>If GCPs are given in the dataset, they are also overwritten.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.set_metadata">
<tt class="descname">set_metadata</tt><big>(</big><em>key=''</em>, <em>value=''</em>, <em>bandID=None</em><big>)</big><a class="headerlink" href="#nansat.Nansat.set_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Set metadata to self.vrt.dataset</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>key</strong> : string or dictionary with strings</p>
<blockquote>
<div><p>name of the metadata, or dictionary with metadata names, values</p>
</div></blockquote>
<p><strong>value</strong> : string</p>
<blockquote>
<div><p>value of metadata</p>
</div></blockquote>
<p><strong>bandID</strong> : int or str</p>
<blockquote>
<div><div class="line-block">
<div class="line">number or name of band</div>
<div class="line">Without bandID (None), global metadata is set</div>
</div>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.vrt.dataset</strong> : sets metadata in GDAL current dataset</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.undo">
<tt class="descname">undo</tt><big>(</big><em>steps=1</em><big>)</big><a class="headerlink" href="#nansat.Nansat.undo" title="Permalink to this definition">¶</a></dt>
<dd><p>Undo reproject, resize, add_band or crop of Nansat object</p>
<p>Restore the self.vrt from self.vrt.vrt</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>steps</strong> : int</p>
<blockquote>
<div><p>How many steps back to undo</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.vrt</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.watermask">
<tt class="descname">watermask</tt><big>(</big><em>mod44path=None</em>, <em>dstDomain=None</em><big>)</big><a class="headerlink" href="#nansat.Nansat.watermask" title="Permalink to this definition">¶</a></dt>
<dd><p>Create numpy array with watermask (water=1, land=0)</p>
<div class="line-block">
<div class="line">250 meters resolution watermask from MODIS 44W Product:</div>
<div class="line"><a class="reference external" href="http://www.glcf.umd.edu/data/watermask/">http://www.glcf.umd.edu/data/watermask/</a></div>
<div class="line">Watermask is stored as tiles in TIF(LZW) format and a VRT file.</div>
<div class="line">All files are stored in one directory.</div>
<div class="line">A tarball with compressed TIF and VRT files should be additionally
downloaded from the Nansat wiki:</div>
<div class="line"><a class="reference external" href="https://github.com/nansencenter/nansat/wiki/Install-Nansat">https://github.com/nansencenter/nansat/wiki/Install-Nansat</a></div>
<div class="line"><br /></div>
<div class="line">1. Gets the directory either from input parameter or from
environment variable MOD44WPATH</div>
<div class="line">2. Open Nansat object from the VRT file</div>
<div class="line">3. Reprojects the watermask onto the current object using
reproject() or reproject_on_jcps()</div>
<div class="line">4. Returns the reprojected Nansat object</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mod44path</strong> : string, optional, default=None</p>
<blockquote>
<div><p>path with MOD44W Products and a VRT file</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>watermask</strong> : Nansat object with water mask in current projection</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>250 meters resolution watermask from MODIS 44W Product :
<a class="reference external" href="http://www.glcf.umd.edu/data/watermask/">http://www.glcf.umd.edu/data/watermask/</a></p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.write_figure">
<tt class="descname">write_figure</tt><big>(</big><em>fileName=None</em>, <em>bands=1</em>, <em>clim=None</em>, <em>addDate=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansat.write_figure" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a raster band to a figure in graphical format.</p>
<div class="line-block">
<div class="line">Get numpy array from the band(s) and band information specified
either by given band number or band id.</div>
<div class="line-block">
<div class="line">If three bands are given, merge them and create PIL image.</div>
<div class="line">If one band is given, create indexed image</div>
</div>
<div class="line">Create Figure object.</div>
<div class="line">Adjust the array brightness and contrast using the given min/max or
histogram.</div>
<div class="line">Apply logarithmic scaling of color tone.</div>
<div class="line">Generate and append legend.</div>
<div class="line">Save the PIL output image in PNG or any other graphical format.</div>
<div class="line">If the filename extension is &#8216;tif&#8217;, the figure file is converted
to GeoTiff</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : string, optional</p>
<blockquote>
<div><p>Output file name. if one of extensions &#8216;png&#8217;, &#8216;PNG&#8217;, &#8216;tif&#8217;,
&#8216;TIF&#8217;, &#8216;bmp&#8217;, &#8216;BMP&#8217;, &#8216;jpg&#8217;, &#8216;JPG&#8217;, &#8216;jpeg&#8217;, &#8216;JPEG&#8217; is included,
specified file is crated. otherwise, &#8216;png&#8217; file is created.
if None, the figure object is returned.
if True, the figure is shown</p>
</div></blockquote>
<p><strong>bands</strong> : integer or string or list (elements are integer or string),</p>
<blockquote>
<div><p>default = 1
the size of the list has to be 1 or 3.
if the size is 3, RGB image is created based on the three bands.
Then the first element is Red, the second is Green,
and the third is Blue.</p>
</div></blockquote>
<p><strong>clim</strong> : list with two elements or &#8216;hist&#8217; to specify range of colormap</p>
<blockquote>
<div><p>None (default) : min/max values are fetched from WKV,
fallback-&#8216;hist&#8217;
[min, max] : min and max are numbers, or
[[min, min, min], [max, max, max]]: three bands used
&#8216;hist&#8217; : a histogram is used to calculate min and max values</p>
</div></blockquote>
<p><strong>addDate</strong> : boolean</p>
<blockquote>
<div><p>False (default) : no date will be aded to the caption
True : the first time of the object will be added to the caption</p>
</div></blockquote>
<p><strong>**kwargs</strong> : parameters for Figure().</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Creates:</th><td class="field-body"><p class="first"><strong>image file</strong> : if fileName is specified</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Figure object</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<div class="line-block">
<div class="line">Figure() class</div>
<div class="line">colormaps : <a class="reference external" href="http://www.scipy.org/Cookbook/Matplotlib/Show_colormaps">http://www.scipy.org/Cookbook/Matplotlib/Show_colormaps</a></div>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># 1. write only indexed image, color limits from WKV or</span>
<span class="c"># rom histogram</span>
<span class="n">n</span><span class="o">.</span><span class="n">write_figure</span><span class="p">(</span><span class="s">&#39;test.jpg&#39;</span><span class="p">)</span>
<span class="c"># 2. write only RGB image, color limits from histogram</span>
<span class="n">n</span><span class="o">.</span><span class="n">write_figure</span><span class="p">(</span><span class="s">&#39;test_rgb_hist.jpg&#39;</span><span class="p">,</span> <span class="n">clim</span><span class="o">=</span><span class="s">&#39;hist&#39;</span><span class="p">,</span>
                <span class="n">bands</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="c"># 3. write indexed image, apply log scaling and gamma correction,</span>
<span class="c"># add legend and type in title &#39;Title&#39;,</span>
<span class="c"># increase font size and put 15 tics</span>
<span class="n">n</span><span class="o">.</span><span class="n">write_figure</span><span class="p">(</span><span class="s">&#39;r09_log3_leg.jpg&#39;</span><span class="p">,</span> <span class="n">logarithm</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
               <span class="n">legend</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">titleString</span><span class="o">=</span><span class="s">&#39;Title&#39;</span><span class="p">,</span>
               <span class="n">fontSize</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">numOfTicks</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="c"># 4. write an image to png with transparent Mask set to color</span>
<span class="c"># transparency=[0, 0, 0], following PIL alpha mask</span>
<span class="n">n</span><span class="o">.</span><span class="n">write_figure</span><span class="p">(</span><span class="n">fileName</span><span class="o">=</span><span class="s">&#39;transparent.png&#39;</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
               <span class="n">mask_array</span><span class="o">=</span><span class="n">wmArray</span><span class="p">,</span> <span class="n">mask_lut</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]},</span>
               <span class="n">clim</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.15</span><span class="p">],</span> <span class="n">cmapName</span><span class="o">=</span><span class="s">&#39;gray&#39;</span><span class="p">,</span>
               <span class="n">transparency</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansat.write_geotiffimage">
<tt class="descname">write_geotiffimage</tt><big>(</big><em>fileName</em>, <em>bandID=1</em><big>)</big><a class="headerlink" href="#nansat.Nansat.write_geotiffimage" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes an 8-bit GeoTiff image for a given band.</p>
<div class="line-block">
<div class="line">The output GeoTiff image is convenient</div>
<div class="line-block">
<div class="line">e.g. for display in a GIS tool.</div>
</div>
<div class="line">Colormap is fetched from the metadata item &#8216;colormap&#8217;.</div>
<div class="line-block">
<div class="line">Fallback colormap is &#8216;jet&#8217;.</div>
</div>
<div class="line">Color limits are fetched from the metadata item &#8216;minmax&#8217;.</div>
<div class="line-block">
<div class="line">If &#8216;minmax&#8217; is not specified, min and max of raster is used.</div>
</div>
<div class="line">The method can be replaced by using nansat.write_figure(),
however, write_figure uses PIL which does not allow
Tiff compression, giving much larger files</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : string</p>
<p class="last"><strong>bandID</strong> : integer or string (default = 1)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nansat.Nansatshape">
<em class="property">class </em><tt class="descclassname">nansat.</tt><tt class="descname">Nansatshape</tt><big>(</big><em>fileName=None</em>, <em>layer=0</em>, <em>srs=None</em>, <em>wkbStyle=1</em><big>)</big><a class="headerlink" href="#nansat.Nansatshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Nansatshape class reads and writes ESRI-shape files</p>
<p>The core of Nansatshape is a OGR. the main functions of the class are
1. Create empty object in memory and add data (fields and geometory).
2. Open shape file and read the data.</p>
<p>Nansatshape support points, but not line, ploygons, mupti-polygons</p>
<dl class="method">
<dt id="nansat.Nansatshape.add_features">
<tt class="descname">add_features</tt><big>(</big><em>values</em>, <em>coordinates</em><big>)</big><a class="headerlink" href="#nansat.Nansatshape.add_features" title="Permalink to this definition">¶</a></dt>
<dd><p>Set field values and / or geometry to each feature</p>
<p>Loop over given arrays of coordinates and values and create
corresponding points with data. Only ogr.wkbPoint is supported.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>values</strong> :  2-D structured numpy array (aka record array)</p>
<blockquote>
<div><p>data to be stored in the vector layer. Names of the fields
in the array will become fields in the layer.</p>
</div></blockquote>
<p><strong>coordinates</strong> : np.array (n x 2)</p>
<blockquote>
<div><p>n rows with x and y coordinates of points. Length of
coordinates should be equal to length of values.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.layer</strong> : Set the values and geometry.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatshape.export">
<tt class="descname">export</tt><big>(</big><em>fileName</em><big>)</big><a class="headerlink" href="#nansat.Nansatshape.export" title="Permalink to this definition">¶</a></dt>
<dd><p>Save as ESRI shape-file</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatshape.get_points">
<tt class="descname">get_points</tt><big>(</big><em>latlon=True</em><big>)</big><a class="headerlink" href="#nansat.Nansatshape.get_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Get points (geometries of featuers) in the layer</p>
<p>!!NB!!
if shapefile has SRS, assume that geometry is lon/lat
if not, assume that the geometry is given in pix/lin
only ogr.wkbPoint or ogr.wkbPoint25D is supported</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>latlon</strong> : bool</p>
<blockquote>
<div><p>if True, coordinates in lon/lat</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>points</strong> : tuple or None</p>
<blockquote>
<div><p>elements of tuple are X-Y coordinates</p>
</div></blockquote>
<p class="last"><strong>latlon</strong> : bool</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nansat.Domain">
<em class="property">class </em><tt class="descclassname">nansat.</tt><tt class="descname">Domain</tt><big>(</big><em>srs=None</em>, <em>ext=None</em>, <em>ds=None</em>, <em>lon=None</em>, <em>lat=None</em>, <em>name=''</em>, <em>logLevel=None</em><big>)</big><a class="headerlink" href="#nansat.Domain" title="Permalink to this definition">¶</a></dt>
<dd><p>Container for geographical reference of a raster</p>
<div class="line-block">
<div class="line">A Domain object describes all attributes of geographical
reference of a raster:</div>
<div class="line-block">
<div class="line">- width and height (number of pixels)</div>
<div class="line">- pixel size (e.g. in decimal degrees or in meters)</div>
<div class="line">- relation between pixel/line coordinates and geographical
coordinates (e.g. a linear relation)</div>
<div class="line">- type of data projection (e.g. geographical or stereographic)</div>
<div class="line"><br /></div>
</div>
<div class="line">The core of Domain is a GDAL Dataset. It has no bands, but only
georeference information: rasterXsize, rasterYsize, GeoTransform and</div>
<div class="line">Projection or GCPs, etc. which fully describe dimentions and spatial
reference of the grid.</div>
<div class="line">There are three ways to store geo-reference in a GDAL dataset:</div>
<div class="line-block">
<div class="line">- Using GeoTransfrom to define linear relationship between raster
pixel/line and geographical X/Y coordinates</div>
<div class="line">- Using GCPs (set of Ground Control Points) to define non-linear
relationship between pixel/line and X/Y</div>
<div class="line">-Using Geolocation Array - full grids of X/Y coordinates for
each pixel of a raster</div>
</div>
<div class="line">The relation between X/Y coordinates of the raster and latitude/longitude
coordinates is defined by projection type and projection parameters.</div>
<div class="line">These pieces of information are therefore stored in Domain:</div>
<div class="line">Type and parameters of projection +</div>
<div class="line-block">
<div class="line">- GeoTransform, or</div>
<div class="line">- GCPs, or</div>
<div class="line">- GeolocationArrays</div>
<div class="line"><br /></div>
</div>
<div class="line">Domain has methods for basic operations with georeference information:</div>
<div class="line-block">
<div class="line">- creating georeference from input options;</div>
<div class="line">- fetching corner, border or full grids of X/Y coordinates;</div>
<div class="line">- making map of the georeferenced grid in a PNG or KML file;</div>
<div class="line">- and some more...</div>
<div class="line"><br /></div>
</div>
<div class="line">The main attribute of Domain is a VRT object self.vrt.</div>
<div class="line">Nansat inherits from Domain and adds bands to self.vrt</div>
</div>
<dl class="method">
<dt id="nansat.Domain.azimuth_up">
<tt class="descname">azimuth_up</tt><big>(</big><em>reductionFactor=1</em><big>)</big><a class="headerlink" href="#nansat.Domain.azimuth_up" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the azimuth of &#8216;upward&#8217; direction in each pixel</p>
<div class="line-block">
<div class="line">Generaly speaking, azimuth is angle from the reference vector
(direction to North) to the chosen direction. Azimuth increases
clockwise from direction to North.
<a class="reference external" href="http://en.wikipedia.org/wiki/Azimuth">http://en.wikipedia.org/wiki/Azimuth</a></div>
<div class="line">Here we calcluate azimuth of &#8216;upward&#8217; direction.
&#8216;Upward&#8217; direction coincides with Y-axis direction (and hence is
opposite to the ROW-axis direction). For lon-lat (cylindrical,
Plate Caree) and Mercator projections &#8216;upward&#8217; direction coincides
with direction to North, hence azimuth is 0.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reductionFactor</strong> : integer</p>
<blockquote>
<div><p>factor by which the size of the output array is reduced</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>azimuth</strong> : numpy array</p>
<blockquote class="last">
<div><p>Values of azimuth in degrees in range 0 - 360</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.get_border">
<tt class="descname">get_border</tt><big>(</big><em>nPoints=10</em><big>)</big><a class="headerlink" href="#nansat.Domain.get_border" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate two vectors with values of lat/lon for the border of domain</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>nPoints</strong> : int, optional</p>
<blockquote>
<div><p>Number of points on each border</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>lonVec, latVec</strong> : lists</p>
<blockquote class="last">
<div><p>vectors with lon/lat values for each point at the border</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.get_border_geometry">
<tt class="descname">get_border_geometry</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Domain.get_border_geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Get OGR Geometry of the border Polygon</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>OGR Geometry</strong> : type Polygon</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.get_border_postgis">
<tt class="descname">get_border_postgis</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Domain.get_border_postgis" title="Permalink to this definition">¶</a></dt>
<dd><p>Get PostGIS formatted string of the border Polygon</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>str</strong> : &#8216;PolygonFromText(PolygonWKT)&#8217;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.get_border_wkt">
<tt class="descname">get_border_wkt</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Domain.get_border_wkt" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates string with WKT representation of the border polygon</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>WKTPolygon</strong> : string</p>
<blockquote class="last">
<div><p>string with WKT representation of the border polygon</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.get_corners">
<tt class="descname">get_corners</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Domain.get_corners" title="Permalink to this definition">¶</a></dt>
<dd><p>Get coordinates of corners of the Domain</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>lonVec, latVec</strong> : lists</p>
<blockquote class="last">
<div><p>vectors with lon/lat values for each corner</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.get_geolocation_grids">
<tt class="descname">get_geolocation_grids</tt><big>(</big><em>stepSize=1</em><big>)</big><a class="headerlink" href="#nansat.Domain.get_geolocation_grids" title="Permalink to this definition">¶</a></dt>
<dd><p>Get longitude and latitude grids representing the full data grid</p>
<div class="line-block">
<div class="line">If GEOLOCATION is not present in the self.vrt.dataset then grids
are generated by converting pixel/line of each pixel into lat/lon</div>
<div class="line">If GEOLOCATION is present in the self.vrt.dataset then grids are
read from the geolocation bands.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>stepSize</strong> : int</p>
<blockquote>
<div><p>Reduction factor if output is desired on a reduced grid size</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>longitude</strong> : numpy array</p>
<blockquote>
<div><p>grid with longitudes</p>
</div></blockquote>
<p><strong>latitude</strong> : numpy array</p>
<blockquote class="last">
<div><p>grid with latitudes</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.get_pixelsize_meters">
<tt class="descname">get_pixelsize_meters</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Domain.get_pixelsize_meters" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pixelsize (deltaX, deltaY) of the domain</p>
<div class="line-block">
<div class="line">For projected domains, the exact result which is constant
over the domain is returned.</div>
<div class="line">For geographic (lon-lat) projections,
or domains with no geotransform,
the haversine formula is used to calculate the pixel size
in the center of the domain.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>deltaX, deltaY</strong> : float</p>
<blockquote class="last">
<div><p>pixel size in X and Y directions given in meters</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.reproject_GCPs">
<tt class="descname">reproject_GCPs</tt><big>(</big><em>srsString</em><big>)</big><a class="headerlink" href="#nansat.Domain.reproject_GCPs" title="Permalink to this definition">¶</a></dt>
<dd><p>Reproject all GCPs to a new spatial reference system</p>
<div class="line-block">
<div class="line">Necessary before warping an image if the given GCPs
are in a coordinate system which has a singularity
in (or near) the destination area (e.g. poles for lonlat GCPs)</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>srsString</strong> : string</p>
<blockquote>
<div><p>SRS given as Proj4 string</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>Reprojects all GCPs to new SRS and updates GCPProjection</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.shape">
<tt class="descname">shape</tt><big>(</big><big>)</big><a class="headerlink" href="#nansat.Domain.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Numpy-like shape of Domain object (ySize, xSize)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>shape</strong> : tuple of two INT</p>
<blockquote class="last">
<div><p>Numpy-like shape of Domain object (ySize, xSize)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.transform_points">
<tt class="descname">transform_points</tt><big>(</big><em>colVector</em>, <em>rowVector</em>, <em>DstToSrc=0</em><big>)</big><a class="headerlink" href="#nansat.Domain.transform_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform given lists of X,Y coordinates into lon/lat or inverse</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>colVector</strong> : lists</p>
<blockquote>
<div><p>X and Y coordinates in pixel/line or lon/lat  coordinate system</p>
</div></blockquote>
<p><strong>DstToSrc</strong> : 0 or 1</p>
<blockquote>
<div><ul class="simple">
<li>0 - forward transform (pix/line =&gt; lon/lat)</li>
<li>1 - inverse transformation</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>X, Y</strong> : lists</p>
<blockquote class="last">
<div><p>X and Y coordinates in lon/lat or pixel/line coordinate system</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.upwards_azimuth_direction">
<tt class="descname">upwards_azimuth_direction</tt><big>(</big><em>orbit_direction=None</em><big>)</big><a class="headerlink" href="#nansat.Domain.upwards_azimuth_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Caluculate and return upwards azimuth direction of domain.</p>
<p>The upward azimuth direction will be the satellite flight
direction (bearing) for unprojected satellite images.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>bearing_center</strong> : float</p>
<blockquote class="last">
<div><p>The upwards azimuth direction (bearing) in the center of
the domain.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="line-block">
<div class="line">For longer domains especially at high latitudes
the azimuth direction may vary a lot over the domain,
and using the center angle will be a coarse approximation.</div>
<div class="line">This function should be updated to return a matrix
of bearings interpolated to each pixel of the domain.
This method should probably also get a better name.</div>
</div>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.write_kml">
<tt class="descname">write_kml</tt><big>(</big><em>xmlFileName=None</em>, <em>kmlFileName=None</em><big>)</big><a class="headerlink" href="#nansat.Domain.write_kml" title="Permalink to this definition">¶</a></dt>
<dd><p>Write KML file with domains</p>
<p>Convert XML-file with domains into KML-file for GoogleEarth
or write KML-file with the current Domain</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xmlFileName</strong> : string, optional</p>
<blockquote>
<div><p>Name of the XML-file to convert. If only this value is given
- kmlFileName=xmlFileName+&#8217;.kml&#8217;</p>
</div></blockquote>
<p><strong>kmlFileName</strong> : string, optional</p>
<blockquote class="last">
<div><p>Name of the KML-file to generate from the current Domain</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.write_kml_image">
<tt class="descname">write_kml_image</tt><big>(</big><em>kmlFileName=None</em>, <em>kmlFigureName=None</em><big>)</big><a class="headerlink" href="#nansat.Domain.write_kml_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Create KML file for already projected image</p>
<p>Write Domain Image into KML-file for GoogleEarth</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>kmlFileName</strong> : string, optional</p>
<blockquote>
<div><p>Name of the KML-file to generate from the current Domain</p>
</div></blockquote>
<p><strong>kmlFigureName</strong> : string, optional</p>
<blockquote class="last">
<div><p>Name of the projected image stored in .png format</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Create projected a KML image</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># 1. First of all, reproject an image into Lat/Lon WGS84</span>
<span class="c"># (Simple Cylindrical) projection.</span>
<span class="c"># Cancel previous reprojection</span>
<span class="n">n</span><span class="o">.</span><span class="n">reproject</span><span class="p">()</span>
<span class="c"># 2. Get corners of the image and the pixel resolution</span>
<span class="c"># lons, lats = n.get_corners()</span>
<span class="c"># 3. Create Domain with stereographic projection,</span>
<span class="c">#    corner coordinates and resolution 1000m</span>
<span class="n">srsString</span> <span class="o">=</span> <span class="s">&#39;+proj=latlong +datum=WGS84 +ellps=WGS84 +no_defs&#39;</span>
<span class="n">extentString</span> <span class="o">=</span> <span class="s">&#39;-lle </span><span class="si">%f</span><span class="s"> </span><span class="si">%f</span><span class="s"> </span><span class="si">%f</span><span class="s"> </span><span class="si">%f</span><span class="s"> -ts 3000 3000&#39;</span> <span class="o">%</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">lons</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">lats</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">lons</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">lats</span><span class="p">))</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">Domain</span><span class="p">(</span><span class="n">srs</span><span class="o">=</span><span class="n">srsString</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">extentString</span><span class="p">)</span>
<span class="c"># 4. Reproject</span>
<span class="n">n</span><span class="o">.</span><span class="n">reproject</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="c"># 5. Write image</span>
<span class="n">n</span><span class="o">.</span><span class="n">write_figure</span><span class="p">(</span><span class="n">fileName</span><span class="o">=</span><span class="n">figureName</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">clim</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.15</span><span class="p">],</span>
               <span class="n">cmapName</span><span class="o">=</span><span class="s">&#39;gray&#39;</span><span class="p">,</span> <span class="n">transparency</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="c"># 6. Write KML for the image</span>
<span class="n">n</span><span class="o">.</span><span class="n">write_kml_image</span><span class="p">(</span><span class="n">kmlFileName</span><span class="o">=</span><span class="n">oPath</span> <span class="o">+</span> <span class="n">fileName</span> <span class="o">+</span> <span class="s">&#39;.kml&#39;</span><span class="p">,</span>
                  <span class="n">kmlFigureName</span><span class="o">=</span><span class="n">figureName</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nansat.Domain.write_map">
<tt class="descname">write_map</tt><big>(</big><em>outputFileName</em>, <em>lonVec=None</em>, <em>latVec=None</em>, <em>lonBorder=10.0</em>, <em>latBorder=10.0</em>, <em>figureSize=(6</em>, <em>6)</em>, <em>dpi=50</em>, <em>projection='cyl'</em>, <em>resolution='c'</em>, <em>continetsColor='coral'</em>, <em>meridians=10</em>, <em>parallels=10</em>, <em>pColor='r'</em>, <em>pLine='k'</em>, <em>pAlpha=0.5</em>, <em>padding=0.0</em><big>)</big><a class="headerlink" href="#nansat.Domain.write_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an image with a map of the domain</p>
<div class="line-block">
<div class="line">Uses Basemap to create a World Map.</div>
<div class="line">Adds a semitransparent patch with outline of the Domain</div>
<div class="line">Writes to an image file.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>outputFileName</strong> : string</p>
<blockquote>
<div><p>name of the output file name</p>
</div></blockquote>
<p><strong>lonBorder</strong> : float</p>
<blockquote>
<div><p>10, horisontal border around patch (degrees of longitude)</p>
</div></blockquote>
<p><strong>latBorder</strong> : float</p>
<blockquote>
<div><p>10, vertical border around patch (degrees of latitude)</p>
</div></blockquote>
<p><strong>figureSize</strong> : tuple of two integers</p>
<blockquote>
<div><p>(6, 6), size of the generated figure in inches</p>
</div></blockquote>
<p><strong>dpi: int</strong></p>
<blockquote>
<div><p>50, resolution of the output figure (size 6,6 and dpi 50
produces 300 x 300 figure)</p>
</div></blockquote>
<p><strong>projection</strong> : string, one of Basemap projections</p>
<blockquote>
<div><p>&#8216;cyl&#8217;, projection of the map</p>
</div></blockquote>
<p><strong>resolution</strong> : string, resolution of the map</p>
<blockquote>
<div><div class="line-block">
<div class="line">&#8216;c&#8217;, crude</div>
<div class="line">&#8216;l&#8217;, low</div>
<div class="line">&#8216;i&#8217;, intermediate</div>
<div class="line">&#8216;h&#8217;, high</div>
<div class="line">&#8216;f&#8217;, full</div>
</div>
</div></blockquote>
<p><strong>continetsColor</strong> : string or any matplotlib color representation</p>
<blockquote>
<div><p>&#8216;coral&#8217;, color of continets</p>
</div></blockquote>
<p><strong>meridians</strong> : int</p>
<blockquote>
<div><p>10, number of meridians to draw</p>
</div></blockquote>
<p><strong>parallels</strong> : int</p>
<blockquote>
<div><p>10, number of parallels to draw</p>
</div></blockquote>
<p><strong>pColor</strong> : string or any matplotlib color representation</p>
<blockquote>
<div><p>&#8216;r&#8217;, color of the Domain patch</p>
</div></blockquote>
<p><strong>pLine</strong> : string or any matplotlib color representation</p>
<blockquote>
<div><p>&#8216;k&#8217;, color of the Domain outline</p>
</div></blockquote>
<p><strong>pAlpha</strong> : float 0 - 1</p>
<blockquote>
<div><p>0.5, transparency of Domain patch</p>
</div></blockquote>
<p><strong>padding</strong> : float</p>
<blockquote class="last">
<div><p>0., width of white padding around the map</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nansat.Figure">
<em class="property">class </em><tt class="descclassname">nansat.</tt><tt class="descname">Figure</tt><big>(</big><em>nparray</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform opeartions with graphical files: create, append legend, save.</p>
<p>Figure instance is created in the Nansat.write_figure method
The methods below are applied consequently in order to generate a figure
from one or three bands, estimate min/max, apply logarithmic scaling,
convert to uint8, append legend, save to a file</p>
<dl class="attribute">
<dt id="nansat.Figure.CAPTION_LOCATION_X">
<tt class="descname">CAPTION_LOCATION_X</tt><em class="property"> = 0.1</em><a class="headerlink" href="#nansat.Figure.CAPTION_LOCATION_X" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.CAPTION_LOCATION_Y">
<tt class="descname">CAPTION_LOCATION_Y</tt><em class="property"> = 0.3</em><a class="headerlink" href="#nansat.Figure.CAPTION_LOCATION_Y" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.CBAR_HEIGHT">
<tt class="descname">CBAR_HEIGHT</tt><em class="property"> = 0.15</em><a class="headerlink" href="#nansat.Figure.CBAR_HEIGHT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.CBAR_HEIGHTMIN">
<tt class="descname">CBAR_HEIGHTMIN</tt><em class="property"> = 5</em><a class="headerlink" href="#nansat.Figure.CBAR_HEIGHTMIN" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.CBAR_LOCATION_X">
<tt class="descname">CBAR_LOCATION_X</tt><em class="property"> = 0.1</em><a class="headerlink" href="#nansat.Figure.CBAR_LOCATION_X" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.CBAR_LOCATION_Y">
<tt class="descname">CBAR_LOCATION_Y</tt><em class="property"> = 0.5</em><a class="headerlink" href="#nansat.Figure.CBAR_LOCATION_Y" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.CBAR_WIDTH">
<tt class="descname">CBAR_WIDTH</tt><em class="property"> = 0.8</em><a class="headerlink" href="#nansat.Figure.CBAR_WIDTH" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.CBTICK_LOC_ADJUST_X">
<tt class="descname">CBTICK_LOC_ADJUST_X</tt><em class="property"> = 5</em><a class="headerlink" href="#nansat.Figure.CBTICK_LOC_ADJUST_X" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.CBTICK_LOC_ADJUST_Y">
<tt class="descname">CBTICK_LOC_ADJUST_Y</tt><em class="property"> = 3</em><a class="headerlink" href="#nansat.Figure.CBTICK_LOC_ADJUST_Y" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.DEFAULT_EXTENSION">
<tt class="descname">DEFAULT_EXTENSION</tt><em class="property"> = '.png'</em><a class="headerlink" href="#nansat.Figure.DEFAULT_EXTENSION" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.LEGEND_HEIGHT">
<tt class="descname">LEGEND_HEIGHT</tt><em class="property"> = 0.1</em><a class="headerlink" href="#nansat.Figure.LEGEND_HEIGHT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.TITLE_LOCATION_X">
<tt class="descname">TITLE_LOCATION_X</tt><em class="property"> = 0.1</em><a class="headerlink" href="#nansat.Figure.TITLE_LOCATION_X" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.TITLE_LOCATION_Y">
<tt class="descname">TITLE_LOCATION_Y</tt><em class="property"> = 0.1</em><a class="headerlink" href="#nansat.Figure.TITLE_LOCATION_Y" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.Figure.add_latlon_grids">
<tt class="descname">add_latlon_grids</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure.add_latlon_grids" title="Permalink to this definition">¶</a></dt>
<dd><p>Add lat/lon grid lines into the PIL image</p>
<div class="line-block">
<div class="line">Compute step of the grid</div>
<div class="line">Make matrices with binarized lat/lon</div>
<div class="line">Find edge (make line)</div>
<div class="line">Convert to maks</div>
<div class="line">Add mask to PIL</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Any of Figure attributes</strong></p>
<p><strong>latGrid</strong> : numpy array</p>
<blockquote>
<div><p>array with values of latitudes</p>
</div></blockquote>
<p><strong>lonGrid</strong> : numpy array</p>
<blockquote>
<div><p>array with values of longitudes</p>
</div></blockquote>
<p><strong>nGridLines</strong> : int</p>
<blockquote>
<div><p>number of lines to draw</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.pilImg</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Figure.add_latlon_labels">
<tt class="descname">add_latlon_labels</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure.add_latlon_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Add lat/lon labels along upper and left side</p>
<div class="line-block">
<div class="line">Compute step of lables</div>
<div class="line">Get lat/lon for these labels from latGrid, lonGrid</div>
<div class="line">Print lables to PIL</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Any of Figure attributes</strong></p>
<p><strong>latGrid</strong> : numpy array</p>
<p><strong>lonGrid</strong> : numpy array</p>
<p><strong>latlonLabels</strong> : int</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.pilImg</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Figure.add_logo">
<tt class="descname">add_logo</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure.add_logo" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert logo into the PIL image</p>
<div class="line-block">
<div class="line">Read logo from file as PIL</div>
<div class="line">Resize to the given size</div>
<div class="line">Pan using the given location</div>
<div class="line">Paste into pilImg</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>Any of Figure attributes</strong></td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><strong>self.pilImg</strong></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Figure.apply_logarithm">
<tt class="descname">apply_logarithm</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure.apply_logarithm" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a tone curve to the array</p>
<div class="line-block">
<div class="line">After the normalization of the values from 0 to 1,
logarithm is applied</div>
<div class="line">Then the values are converted to the normal scale.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>Any of Figure attributes</strong></td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><strong>self.array</strong> : numpy array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Figure.apply_mask">
<tt class="descname">apply_mask</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure.apply_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply mask for coloring land, clouds, etc</p>
<div class="line-block">
<div class="line">If mask_array and mask_lut are provided as input parameters</div>
<div class="line">The pixels in self.array which have index equal to mask_lut kay
in mask_array will have color equal to mask_lut value
apply_mask should be called only after convert_palettesize.
(i.e. to uint8 data)</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>Any of Figure attributes</strong></td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><strong>self.array</strong> : numpy array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.caption">
<tt class="descname">caption</tt><em class="property"> = ''</em><a class="headerlink" href="#nansat.Figure.caption" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.Figure.clim_from_histogram">
<tt class="descname">clim_from_histogram</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure.clim_from_histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate min and max pixel values from histogram</p>
<div class="line-block">
<div class="line">If ratio=1.0, simply the minimum and maximum values are returned.</div>
<div class="line">If 0 &lt; ratio &lt; 1.0, get the histogram of the pixel values.</div>
<div class="line">Then get rid of (1.0-ratio)/2 from the both sides and
return the minimum and maximum values.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Any of Figure attributes</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>clim</strong> : numpy array 2D ((3x2) or (1x2))</p>
<blockquote class="last">
<div><p>minimum and maximum pixel values for each band</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Figure.clip">
<tt class="descname">clip</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure.clip" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert self.array to values between cmin and cmax</p>
<div class="line-block">
<div class="line">If pixel value &lt; cmin, replaced to cmin.</div>
<div class="line">If pixel value &gt; cmax, replaced to cmax.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Any of Figure attributes</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.array</strong> : numpy array</p>
<p class="last"><strong>self.cmin, self.cmax</strong> : allowed min/max values</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.cmapName">
<tt class="descname">cmapName</tt><em class="property"> = 'jet'</em><a class="headerlink" href="#nansat.Figure.cmapName" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.cmax">
<tt class="descname">cmax</tt><em class="property"> = [1.0]</em><a class="headerlink" href="#nansat.Figure.cmax" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.cmin">
<tt class="descname">cmin</tt><em class="property"> = [0.0]</em><a class="headerlink" href="#nansat.Figure.cmin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.Figure.convert_palettesize">
<tt class="descname">convert_palettesize</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure.convert_palettesize" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert self.array to palette color size in uint8</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>Any of Figure attributes</strong></td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><strong>self.array</strong> : numpy array (=&gt;uint8)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Figure.create_legend">
<tt class="descname">create_legend</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure.create_legend" title="Permalink to this definition">¶</a></dt>
<dd><p>self.legend is replaced from None to PIL image</p>
<p>PIL image includes colorbar, caption, and titleString.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>Any of Figure attributes</strong></td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><strong>self.legend</strong> : PIL image</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Figure.create_pilImage">
<tt class="descname">create_pilImage</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure.create_pilImage" title="Permalink to this definition">¶</a></dt>
<dd><p>self.create_pilImage is replaced from None to PIL image</p>
<div class="line-block">
<div class="line">If three images are given, create a image with RGB mode.
if self.pilImgLegend is not None, it is pasted.</div>
<div class="line">If one image is given, create a image with P(palette) mode.
if self.pilImgLegend is not None,
self.array is extended before create the pilImag and
then paste pilImgLegend onto it.</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Any of Figure attributes</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.pilImg</strong> : PIL image with / without the legend</p>
<p class="last"><strong>self.array</strong> : replace to None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.extensionList">
<tt class="descname">extensionList</tt><em class="property"> = ['png', 'PNG', 'tif', 'TIF', 'bmp', 'BMP', 'jpg', 'JPG', 'jpeg', 'JPEG']</em><a class="headerlink" href="#nansat.Figure.extensionList" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.fontSize">
<tt class="descname">fontSize</tt><em class="property"> = 12</em><a class="headerlink" href="#nansat.Figure.fontSize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.gamma">
<tt class="descname">gamma</tt><em class="property"> = 2.0</em><a class="headerlink" href="#nansat.Figure.gamma" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.latGrid">
<tt class="descname">latGrid</tt><em class="property"> = None</em><a class="headerlink" href="#nansat.Figure.latGrid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.latlonLabels">
<tt class="descname">latlonLabels</tt><em class="property"> = 0</em><a class="headerlink" href="#nansat.Figure.latlonLabels" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.legend">
<tt class="descname">legend</tt><em class="property"> = False</em><a class="headerlink" href="#nansat.Figure.legend" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.logarithm">
<tt class="descname">logarithm</tt><em class="property"> = False</em><a class="headerlink" href="#nansat.Figure.logarithm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.logoFileName">
<tt class="descname">logoFileName</tt><em class="property"> = None</em><a class="headerlink" href="#nansat.Figure.logoFileName" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.logoLocation">
<tt class="descname">logoLocation</tt><em class="property"> = [0, 0]</em><a class="headerlink" href="#nansat.Figure.logoLocation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.logoSize">
<tt class="descname">logoSize</tt><em class="property"> = None</em><a class="headerlink" href="#nansat.Figure.logoSize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.lonGrid">
<tt class="descname">lonGrid</tt><em class="property"> = None</em><a class="headerlink" href="#nansat.Figure.lonGrid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.mask_array">
<tt class="descname">mask_array</tt><em class="property"> = None</em><a class="headerlink" href="#nansat.Figure.mask_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.mask_lut">
<tt class="descname">mask_lut</tt><em class="property"> = None</em><a class="headerlink" href="#nansat.Figure.mask_lut" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.nGridLines">
<tt class="descname">nGridLines</tt><em class="property"> = 10</em><a class="headerlink" href="#nansat.Figure.nGridLines" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.numOfColor">
<tt class="descname">numOfColor</tt><em class="property"> = 250</em><a class="headerlink" href="#nansat.Figure.numOfColor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.numOfTicks">
<tt class="descname">numOfTicks</tt><em class="property"> = 5</em><a class="headerlink" href="#nansat.Figure.numOfTicks" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.palette">
<tt class="descname">palette</tt><em class="property"> = None</em><a class="headerlink" href="#nansat.Figure.palette" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.pilImg">
<tt class="descname">pilImg</tt><em class="property"> = None</em><a class="headerlink" href="#nansat.Figure.pilImg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.pilImgLegend">
<tt class="descname">pilImgLegend</tt><em class="property"> = None</em><a class="headerlink" href="#nansat.Figure.pilImgLegend" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.Figure.process">
<tt class="descname">process</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure.process" title="Permalink to this definition">¶</a></dt>
<dd><p>Do all common operations for preparation of a figure for saving</p>
<div class="line-block">
<div class="line">Modify default values of parameters by the provided ones (if any)</div>
<div class="line">Clip to min/max</div>
<div class="line">Apply logarithm if required</div>
<div class="line">Convert data to uint8</div>
<div class="line">Create palette</div>
<div class="line">Apply mask for colouring land, clouds, etc if required</div>
<div class="line">Create legend if required</div>
<div class="line">Create PIL image</div>
<div class="line">Add logo if required</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Any of Figure attributes</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.d</strong></p>
<p><strong>self.array</strong></p>
<p><strong>self.palette</strong></p>
<p><strong>self.pilImgLegend</strong></p>
<p class="last"><strong>self.pilImg.</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.ratio">
<tt class="descname">ratio</tt><em class="property"> = 1.0</em><a class="headerlink" href="#nansat.Figure.ratio" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.Figure.save">
<tt class="descname">save</tt><big>(</big><em>fileName</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Figure.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save self.pilImg to a physical file</p>
<p>If given extension is JPG, convert the image mode from Palette to RGB</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : string</p>
<blockquote>
<div><p>name of outputfile</p>
</div></blockquote>
<p><strong>Any of Figure attributes</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>self.pilImg</strong> : None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.subsetArraySize">
<tt class="descname">subsetArraySize</tt><em class="property"> = 100000</em><a class="headerlink" href="#nansat.Figure.subsetArraySize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.titleString">
<tt class="descname">titleString</tt><em class="property"> = ''</em><a class="headerlink" href="#nansat.Figure.titleString" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Figure.transparency">
<tt class="descname">transparency</tt><em class="property"> = None</em><a class="headerlink" href="#nansat.Figure.transparency" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nansat.Nansatmap">
<em class="property">class </em><tt class="descclassname">nansat.</tt><tt class="descname">Nansatmap</tt><big>(</big><em>domain</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">mpl_toolkits.basemap.Basemap</span></tt></p>
<p>Perform opeartions with graphical files: create,
add legend and geolocation_grids, save.</p>
<div class="line-block">
<div class="line">NansatMap instance is created in the Nansat.write_map method.</div>
<div class="line">The methods below are applied consequently in order to get projection,
generate a basemap from array(s), add legend and geolocation grids,
save to a file.</div>
</div>
<dl class="attribute">
<dt id="nansat.Nansatmap.DEFAULT_EXTENSION">
<tt class="descname">DEFAULT_EXTENSION</tt><em class="property"> = '.png'</em><a class="headerlink" href="#nansat.Nansatmap.DEFAULT_EXTENSION" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.add_colorbar">
<tt class="descname">add_colorbar</tt><big>(</big><em>fontsize=6</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.add_colorbar" title="Permalink to this definition">¶</a></dt>
<dd><p>Add color bar</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fontsize</strong> : int</p>
<p><strong>Parameters for matplotlib.pyplot.colorbar</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>Adds colorbar to self.fig</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="nansat.Nansatmap.cmap">
<tt class="descname">cmap</tt><em class="property"> = &lt;matplotlib.colors.LinearSegmentedColormap object at 0x038C3970&gt;</em><a class="headerlink" href="#nansat.Nansatmap.cmap" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Nansatmap.colorbar">
<tt class="descname">colorbar</tt><em class="property"> = None</em><a class="headerlink" href="#nansat.Nansatmap.colorbar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.contour">
<tt class="descname">contour</tt><big>(</big><em>data</em>, <em>v=None</em>, <em>smooth=False</em>, <em>mode='gaussian'</em>, <em>label=True</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.contour" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw lined contour plots</p>
<p>If smooth is True, data is smoothed. Then draw lined contour.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : numpy 2D array</p>
<blockquote>
<div><p>Input data</p>
</div></blockquote>
<p><strong>v</strong> : list with values</p>
<blockquote>
<div><p>draw contour lines at the values specified in sequence v</p>
</div></blockquote>
<p><strong>smooth</strong> : Boolean</p>
<blockquote>
<div><p>Apply smoothing?</p>
</div></blockquote>
<p><strong>mode</strong> : string</p>
<blockquote>
<div><p>&#8216;gaussian&#8217;, &#8216;spline&#8217;, &#8216;fourier&#8217;, &#8216;convolve&#8217;
mname of smoothing algorithm to apply</p>
</div></blockquote>
<p><strong>label</strong> : boolean</p>
<blockquote>
<div><p>Add lables?</p>
</div></blockquote>
<p><strong>**kwargs:</strong></p>
<blockquote>
<div><div class="line-block">
<div class="line">Optional parameters for Nansatmap.smooth()</div>
<div class="line">Optional parameters for pyplot.contour().</div>
<div class="line">Optional parameters for pyplot.clabel()</div>
</div>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.mpl</strong> : list</p>
<blockquote class="last">
<div><p>append QuadContourSet instance</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.contourf">
<tt class="descname">contourf</tt><big>(</big><em>data</em>, <em>v=None</em>, <em>smooth=False</em>, <em>mode='gaussian'</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.contourf" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw filled contour plots</p>
<p>If smooth is True, data is smoothed. Then draw filled contour.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : numpy 2D array</p>
<blockquote>
<div><p>Input data</p>
</div></blockquote>
<p><strong>v</strong> : list with values</p>
<blockquote>
<div><p>draw contour lines at the values specified in sequence v</p>
</div></blockquote>
<p><strong>smooth</strong> : Boolean</p>
<blockquote>
<div><p>Apply smoothing?</p>
</div></blockquote>
<p><strong>mode</strong> : string</p>
<blockquote>
<div><p>&#8216;gaussian&#8217;, &#8216;spline&#8217;, &#8216;fourier&#8217;, &#8216;convolve&#8217;
mname of smoothing algorithm to apply</p>
</div></blockquote>
<p><strong>**kwargs:</strong></p>
<blockquote>
<div><div class="line-block">
<div class="line">cmap : colormap (e.g. cm.jet)</div>
<div class="line">Optional parameters for Nansatmap.smooth()</div>
<div class="line">Optional parameters for pyplot.contourf().</div>
</div>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.mpl</strong> : list</p>
<blockquote class="last">
<div><p>append QuadContourSet instance</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="nansat.Nansatmap.convolve_cval">
<tt class="descname">convolve_cval</tt><em class="property"> = 0.0</em><a class="headerlink" href="#nansat.Nansatmap.convolve_cval" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Nansatmap.convolve_mode">
<tt class="descname">convolve_mode</tt><em class="property"> = 'reflect'</em><a class="headerlink" href="#nansat.Nansatmap.convolve_mode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Nansatmap.convolve_origin">
<tt class="descname">convolve_origin</tt><em class="property"> = 0</em><a class="headerlink" href="#nansat.Nansatmap.convolve_origin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Nansatmap.convolve_weightSize">
<tt class="descname">convolve_weightSize</tt><em class="property"> = 7</em><a class="headerlink" href="#nansat.Nansatmap.convolve_weightSize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Nansatmap.convolve_weights">
<tt class="descname">convolve_weights</tt><em class="property"> = None</em><a class="headerlink" href="#nansat.Nansatmap.convolve_weights" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.draw_continents">
<tt class="descname">draw_continents</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.draw_continents" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw continents</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>Parameters of basemap.fillcontinents</strong></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.drawgrid">
<tt class="descname">drawgrid</tt><big>(</big><em>fontsize=10, lat_num=5, lon_num=5, lat_labels=[True, False, False, False], lon_labels=[False, False, True, False]</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.drawgrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw and label parallels (lat and lon lines) for values (in degrees)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fontsize</strong> : int</p>
<p><strong>lat_num</strong> : int</p>
<blockquote>
<div><p>Number of latitude lables</p>
</div></blockquote>
<p><strong>lon_num :</strong></p>
<blockquote>
<div><p>Number of longitude lables</p>
</div></blockquote>
<p><strong>lat_labels</strong> : list of Bool</p>
<blockquote>
<div><p>Location of latitude labels</p>
</div></blockquote>
<p><strong>lon_labels</strong> : list of Bool</p>
<blockquote class="last">
<div><p>Location of longitude labels</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<dl class="docutils">
<dt>Basemap.drawparallels() :</dt>
<dd><a class="reference external" href="http://matplotlib.org/basemap/api/basemap_api.html#mpl_toolkits.basemap.Basemap.drawparallels">http://matplotlib.org/basemap/api/basemap_api.html#mpl_toolkits.basemap.Basemap.drawparallels</a></dd>
<dt>Basemap.drawmeridians() :</dt>
<dd><a class="reference external" href="http://matplotlib.org/basemap/api/basemap_api.html#mpl_toolkits.basemap.Basemap.drawmeridians">http://matplotlib.org/basemap/api/basemap_api.html#mpl_toolkits.basemap.Basemap.drawmeridians</a></dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="nansat.Nansatmap.fourier_axis">
<tt class="descname">fourier_axis</tt><em class="property"> = -1</em><a class="headerlink" href="#nansat.Nansatmap.fourier_axis" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Nansatmap.fourier_n">
<tt class="descname">fourier_n</tt><em class="property"> = -1</em><a class="headerlink" href="#nansat.Nansatmap.fourier_n" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Nansatmap.fourier_sigma">
<tt class="descname">fourier_sigma</tt><em class="property"> = 1.0</em><a class="headerlink" href="#nansat.Nansatmap.fourier_sigma" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Nansatmap.gaussian_cval">
<tt class="descname">gaussian_cval</tt><em class="property"> = 0.0</em><a class="headerlink" href="#nansat.Nansatmap.gaussian_cval" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Nansatmap.gaussian_mode">
<tt class="descname">gaussian_mode</tt><em class="property"> = 'reflect'</em><a class="headerlink" href="#nansat.Nansatmap.gaussian_mode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Nansatmap.gaussian_order">
<tt class="descname">gaussian_order</tt><em class="property"> = 0</em><a class="headerlink" href="#nansat.Nansatmap.gaussian_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Nansatmap.gaussian_sigma">
<tt class="descname">gaussian_sigma</tt><em class="property"> = 2.5</em><a class="headerlink" href="#nansat.Nansatmap.gaussian_sigma" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Nansatmap.lat">
<tt class="descname">lat</tt><em class="property"> = None</em><a class="headerlink" href="#nansat.Nansatmap.lat" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Nansatmap.lon">
<tt class="descname">lon</tt><em class="property"> = None</em><a class="headerlink" href="#nansat.Nansatmap.lon" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Nansatmap.mpl">
<tt class="descname">mpl</tt><em class="property"> = []</em><a class="headerlink" href="#nansat.Nansatmap.mpl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.pcolormesh">
<tt class="descname">pcolormesh</tt><big>(</big><em>data</em>, <em>validValues=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.pcolormesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a pseudo-color plot over the map</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : numpy 2D array</p>
<blockquote>
<div><p>Input data</p>
</div></blockquote>
<p><strong>validValues</strong> : list with two scalars (e.g. [min, max])</p>
<blockquote>
<div><p>minimum and maximum valid values</p>
</div></blockquote>
<p><strong>Parameters of Basemap.pcolormesh</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.mpl</strong> : list</p>
<blockquote class="last">
<div><p>append matplotlib.collections.QuadMesh object</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.quiver">
<tt class="descname">quiver</tt><big>(</big><em>dataX</em>, <em>dataY</em>, <em>quivectors=30</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.quiver" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw quiver plots</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dataX</strong> :  numpy array</p>
<blockquote>
<div><p>Input data with X-component</p>
</div></blockquote>
<p><strong>dataY</strong> :  numpy array</p>
<blockquote>
<div><p>Input data with Y-component</p>
</div></blockquote>
<p><strong>quivectors</strong> : int</p>
<blockquote>
<div><p>Number of vectors along both dimentions</p>
</div></blockquote>
<p><strong>Parameters of Basemap.quiver()</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.mpl</strong> : list</p>
<blockquote class="last">
<div><p>append matplotlib.quiver.Quiver instance</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.save">
<tt class="descname">save</tt><big>(</big><em>fileName</em>, <em>landmask=True</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw continents and save</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : string</p>
<blockquote>
<div><p>name of outputfile</p>
</div></blockquote>
<p><strong>landmask</strong> : Boolean</p>
<blockquote>
<div><p>Draw landmask?</p>
</div></blockquote>
<p class="last"><strong>Parameters of basemap.fillcontinents</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.Nansatmap.smooth">
<tt class="descname">smooth</tt><big>(</big><em>idata</em>, <em>mode</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Nansatmap.smooth" title="Permalink to this definition">¶</a></dt>
<dd><p>Smooth data for contour() and contourf()</p>
<p>idata is smoothed by convolve, fourier_gaussian, spline or
gaussian (default). If contour_mode is &#8216;convolve&#8217; and weight is None,
the weight matrix is created automatically.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>idata</strong> : numpy 2D array</p>
<blockquote>
<div><p>Input data</p>
</div></blockquote>
<p><strong>mode</strong> : string</p>
<blockquote>
<div><p>&#8216;convolve&#8217;,&#8217;fourier&#8217;,&#8217;spline&#8217; or &#8216;gaussian&#8217;</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>odata</strong> : numpy 2D array</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<dl class="docutils">
<dt>scipy.ndimage() :</dt>
<dd><a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/ndimage.html">http://docs.scipy.org/doc/scipy/reference/ndimage.html</a></dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="nansat.Nansatmap.spline_axis">
<tt class="descname">spline_axis</tt><em class="property"> = -1</em><a class="headerlink" href="#nansat.Nansatmap.spline_axis" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Nansatmap.spline_order">
<tt class="descname">spline_order</tt><em class="property"> = 3</em><a class="headerlink" href="#nansat.Nansatmap.spline_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Nansatmap.x">
<tt class="descname">x</tt><em class="property"> = None</em><a class="headerlink" href="#nansat.Nansatmap.x" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Nansatmap.y">
<tt class="descname">y</tt><em class="property"> = None</em><a class="headerlink" href="#nansat.Nansatmap.y" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nansat.Basemap">
<em class="property">class </em><tt class="descclassname">nansat.</tt><tt class="descname">Basemap</tt><big>(</big><em>llcrnrlon=None</em>, <em>llcrnrlat=None</em>, <em>urcrnrlon=None</em>, <em>urcrnrlat=None</em>, <em>llcrnrx=None</em>, <em>llcrnry=None</em>, <em>urcrnrx=None</em>, <em>urcrnry=None</em>, <em>width=None</em>, <em>height=None</em>, <em>projection='cyl'</em>, <em>resolution='c'</em>, <em>area_thresh=None</em>, <em>rsphere=6370997.0</em>, <em>ellps=None</em>, <em>lat_ts=None</em>, <em>lat_1=None</em>, <em>lat_2=None</em>, <em>lat_0=None</em>, <em>lon_0=None</em>, <em>lon_1=None</em>, <em>lon_2=None</em>, <em>k_0=None</em>, <em>no_rot=False</em>, <em>suppress_ticks=True</em>, <em>satellite_height=35786000</em>, <em>boundinglat=None</em>, <em>fix_aspect=True</em>, <em>anchor='C'</em>, <em>celestial=False</em>, <em>round=False</em>, <em>epsg=None</em>, <em>ax=None</em><big>)</big><a class="headerlink" href="#nansat.Basemap" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<dl class="method">
<dt id="nansat.Basemap.arcgisimage">
<tt class="descname">arcgisimage</tt><big>(</big><em>server='http://server.arcgisonline.com/ArcGIS'</em>, <em>service='ESRI_Imagery_World_2D'</em>, <em>xpixels=400</em>, <em>ypixels=None</em>, <em>dpi=96</em>, <em>verbose=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Basemap.arcgisimage" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve an image using the ArcGIS Server REST API and display it on
the map. In order to use this method, the Basemap instance must be
created using the <tt class="docutils literal"><span class="pre">epsg</span></tt> keyword to define the map projection, unless
the <tt class="docutils literal"><span class="pre">cyl</span></tt> projection is used (in which case the epsg code 4326 is
assumed).</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keywords</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>server</td>
<td>web map server URL (default
<a class="reference external" href="http://server.arcgisonline.com/ArcGIS">http://server.arcgisonline.com/ArcGIS</a>).</td>
</tr>
<tr class="row-odd"><td>service</td>
<td>service (image type) hosted on server (default
ESRI_Imagery_World_2D, which is NASA &#8216;Blue Marble&#8217;
image).</td>
</tr>
<tr class="row-even"><td>xpixels</td>
<td>requested number of image pixels in x-direction
(default 400).</td>
</tr>
<tr class="row-odd"><td>ypixels</td>
<td>requested number of image pixels in y-direction.
Default (None) is to infer the number from
from xpixels and the aspect ratio of the
map projection region.</td>
</tr>
<tr class="row-even"><td>dpi</td>
<td>The device resolution of the exported image (dots per
inch, default 96).</td>
</tr>
<tr class="row-odd"><td>verbose</td>
<td>if True, print URL used to retrieve image (default
False).</td>
</tr>
</tbody>
</table>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>returns a matplotlib.image.AxesImage instance.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.barbs">
<tt class="descname">barbs</tt><big>(</big><em>x</em>, <em>y</em>, <em>u</em>, <em>v</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Basemap.barbs" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a wind barb plot (u, v) with on the map.
(see matplotlib.pyplot.barbs documentation).</p>
<p>If <tt class="docutils literal"><span class="pre">latlon</span></tt> keyword is set to True, x,y are intrepreted as
longitude and latitude in degrees.  Data and longitudes are
automatically shifted to match map projection region for cylindrical
and pseudocylindrical projections, and x,y are transformed to map
projection coordinates. If <tt class="docutils literal"><span class="pre">latlon</span></tt> is False (default), x and y
are assumed to be map projection coordinates.</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>Other *args and **kwargs passed on to matplotlib.pyplot.barbs</p>
<p>Returns two matplotlib.axes.Barbs instances, one for the Northern
Hemisphere and one for the Southern Hemisphere.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.bluemarble">
<tt class="descname">bluemarble</tt><big>(</big><em>ax=None</em>, <em>scale=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Basemap.bluemarble" title="Permalink to this definition">¶</a></dt>
<dd><p>display blue marble image (from <a class="reference external" href="http://visibleearth.nasa.gov">http://visibleearth.nasa.gov</a>)
as map background.
Default image size is 5400x2700, which can be quite slow and
use quite a bit of memory.  The <tt class="docutils literal"><span class="pre">scale</span></tt> keyword can be used
to downsample the image (<tt class="docutils literal"><span class="pre">scale=0.5</span></tt> downsamples to 2700x1350).</p>
<p>**kwargs passed on to <a class="reference internal" href="#nansat.Basemap.imshow" title="nansat.Basemap.imshow"><tt class="xref py py-meth docutils literal"><span class="pre">imshow()</span></tt></a>.</p>
<p>returns a matplotlib.image.AxesImage instance.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.colorbar">
<tt class="descname">colorbar</tt><big>(</big><em>mappable=None</em>, <em>location='right'</em>, <em>size='5%'</em>, <em>pad='2%'</em>, <em>fig=None</em>, <em>ax=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Basemap.colorbar" title="Permalink to this definition">¶</a></dt>
<dd><p>Add colorbar to axes associated with a map.
The colorbar axes instance is created using the axes_grid toolkit.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keywords</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>mappable</td>
<td>the Image, ContourSet, etc. to which the colorbar
applies.  Default None, matplotlib.pyplot.gci() is
used to retrieve the current image mappable.</td>
</tr>
<tr class="row-odd"><td>location</td>
<td>where to put colorbar (&#8216;top&#8217;,&#8217;bottom&#8217;,&#8217;left&#8217;,&#8217;right&#8217;)
Default &#8216;right&#8217;.</td>
</tr>
<tr class="row-even"><td>size</td>
<td>width of colorbar axes (string &#8216;N%&#8217;, where N is
an integer describing the fractional width of the parent
axes). Default &#8216;5%&#8217;.</td>
</tr>
<tr class="row-odd"><td>pad</td>
<td>Padding between parent axes and colorbar axes in
same units as size. Default &#8216;2%&#8217;.</td>
</tr>
<tr class="row-even"><td>fig</td>
<td>Figure instance the map axes instance is associated
with. Default None, and matplotlib.pyplot.gcf() is used
to retrieve the current active figure instance.</td>
</tr>
<tr class="row-odd"><td>ax</td>
<td>The axes instance which the colorbar will be
associated with.  Default None, searches for self.ax,
and if None uses matplotlib.pyplot.gca().</td>
</tr>
<tr class="row-even"><td>**kwargs</td>
<td>extra keyword arguments passed on to
colorbar method of the figure instance.</td>
</tr>
</tbody>
</table>
<p>Returns a matplotlib colorbar instance.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.contour">
<tt class="descname">contour</tt><big>(</big><em>x</em>, <em>y</em>, <em>data</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Basemap.contour" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a contour plot over the map
(see matplotlib.pyplot.contour documentation).</p>
<p>If <tt class="docutils literal"><span class="pre">latlon</span></tt> keyword is set to True, x,y are intrepreted as
longitude and latitude in degrees.  Data and longitudes are
automatically shifted to match map projection region for cylindrical
and pseudocylindrical projections, and x,y are transformed to map
projection coordinates. If <tt class="docutils literal"><span class="pre">latlon</span></tt> is False (default), x and y
are assumed to be map projection coordinates.</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>If <tt class="docutils literal"><span class="pre">tri</span></tt> is set to <tt class="docutils literal"><span class="pre">True</span></tt>, an unstructured grid is assumed
(x,y,data must be 1-d) and matplotlib.pyplot.tricontour is used.</p>
<p>Other *args and **kwargs passed on to matplotlib.pyplot.contour
(or tricontour if <tt class="docutils literal"><span class="pre">tri=True</span></tt>).</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.contourf">
<tt class="descname">contourf</tt><big>(</big><em>x</em>, <em>y</em>, <em>data</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Basemap.contourf" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a filled contour plot over the map
(see matplotlib.pyplot.contourf documentation).</p>
<p>If <tt class="docutils literal"><span class="pre">latlon</span></tt> keyword is set to True, x,y are intrepreted as
longitude and latitude in degrees.  Data and longitudes are
automatically shifted to match map projection region for cylindrical
and pseudocylindrical projections, and x,y are transformed to map
projection coordinates. If <tt class="docutils literal"><span class="pre">latlon</span></tt> is False (default), x and y
are assumed to be map projection coordinates.</p>
<p>If x or y are outside projection limb (i.e. they have values &gt; 1.e20),
the corresponing data elements will be masked.</p>
<p>Extra keyword &#8216;ax&#8217; can be used to override the default axis instance.</p>
<p>If <tt class="docutils literal"><span class="pre">tri</span></tt> is set to <tt class="docutils literal"><span class="pre">True</span></tt>, an unstructured grid is assumed
(x,y,data must be 1-d) and matplotlib.pyplot.tricontourf is used.</p>
<p>Other *args and **kwargs passed on to matplotlib.pyplot.contourf
(or tricontourf if <tt class="docutils literal"><span class="pre">tri=True</span></tt>).</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.drawcoastlines">
<tt class="descname">drawcoastlines</tt><big>(</big><em>linewidth=1.0</em>, <em>linestyle='solid'</em>, <em>color='k'</em>, <em>antialiased=1</em>, <em>ax=None</em>, <em>zorder=None</em><big>)</big><a class="headerlink" href="#nansat.Basemap.drawcoastlines" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw coastlines.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>linewidth</td>
<td>coastline width (default 1.)</td>
</tr>
<tr class="row-odd"><td>linestyle</td>
<td>coastline linestyle (default solid)</td>
</tr>
<tr class="row-even"><td>color</td>
<td>coastline color (default black)</td>
</tr>
<tr class="row-odd"><td>antialiased</td>
<td>antialiasing switch for coastlines (default True).</td>
</tr>
<tr class="row-even"><td>ax</td>
<td>axes instance (overrides default axes instance)</td>
</tr>
<tr class="row-odd"><td>zorder</td>
<td>sets the zorder for the coastlines (if not specified,
uses default zorder for
matplotlib.patches.LineCollections).</td>
</tr>
</tbody>
</table>
<p>returns a matplotlib.patches.LineCollection object.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.drawcounties">
<tt class="descname">drawcounties</tt><big>(</big><em>linewidth=0.1</em>, <em>linestyle='solid'</em>, <em>color='k'</em>, <em>antialiased=1</em>, <em>ax=None</em>, <em>zorder=None</em>, <em>drawbounds=False</em><big>)</big><a class="headerlink" href="#nansat.Basemap.drawcounties" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw county boundaries in US. The county boundary shapefile
originates with the NOAA Coastal Geospatial Data Project
(<a class="reference external" href="http://coastalgeospatial.noaa.gov/data_gis.html">http://coastalgeospatial.noaa.gov/data_gis.html</a>).</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>linewidth</td>
<td>county boundary line width (default 0.1)</td>
</tr>
<tr class="row-odd"><td>linestyle</td>
<td>coastline linestyle (default solid)</td>
</tr>
<tr class="row-even"><td>color</td>
<td>county boundary line color (default black)</td>
</tr>
<tr class="row-odd"><td>antialiased</td>
<td>antialiasing switch for county boundaries
(default True).</td>
</tr>
<tr class="row-even"><td>ax</td>
<td>axes instance (overrides default axes instance)</td>
</tr>
<tr class="row-odd"><td>zorder</td>
<td>sets the zorder for the county boundaries (if not
specified, uses default zorder for
matplotlib.patches.LineCollections).</td>
</tr>
</tbody>
</table>
<p>returns a matplotlib.patches.LineCollection object.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.drawcountries">
<tt class="descname">drawcountries</tt><big>(</big><em>linewidth=0.5</em>, <em>linestyle='solid'</em>, <em>color='k'</em>, <em>antialiased=1</em>, <em>ax=None</em>, <em>zorder=None</em><big>)</big><a class="headerlink" href="#nansat.Basemap.drawcountries" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw country boundaries.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>linewidth</td>
<td>country boundary line width (default 0.5)</td>
</tr>
<tr class="row-odd"><td>linestyle</td>
<td>coastline linestyle (default solid)</td>
</tr>
<tr class="row-even"><td>color</td>
<td>country boundary line color (default black)</td>
</tr>
<tr class="row-odd"><td>antialiased</td>
<td>antialiasing switch for country boundaries (default
True).</td>
</tr>
<tr class="row-even"><td>ax</td>
<td>axes instance (overrides default axes instance)</td>
</tr>
<tr class="row-odd"><td>zorder</td>
<td>sets the zorder for the country boundaries (if not
specified uses default zorder for
matplotlib.patches.LineCollections).</td>
</tr>
</tbody>
</table>
<p>returns a matplotlib.patches.LineCollection object.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.drawgreatcircle">
<tt class="descname">drawgreatcircle</tt><big>(</big><em>lon1</em>, <em>lat1</em>, <em>lon2</em>, <em>lat2</em>, <em>del_s=100.0</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Basemap.drawgreatcircle" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a great circle on the map from the longitude-latitude
pair <tt class="docutils literal"><span class="pre">lon1,lat1</span></tt> to <tt class="docutils literal"><span class="pre">lon2,lat2</span></tt></p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>del_s</td>
<td>points on great circle computed every del_s kilometers
(default 100).</td>
</tr>
<tr class="row-odd"><td>**kwargs</td>
<td>other keyword arguments are passed on to <a class="reference internal" href="#nansat.Basemap.plot" title="nansat.Basemap.plot"><tt class="xref py py-meth docutils literal"><span class="pre">plot()</span></tt></a>
method of Basemap instance.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Cannot handle situations in which the great circle intersects
the edge of the map projection domain, and then re-enters the domain.</p>
</div>
<p>Returns a matplotlib.lines.Line2D object.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.drawlsmask">
<tt class="descname">drawlsmask</tt><big>(</big><em>land_color='0.8'</em>, <em>ocean_color='w'</em>, <em>lsmask=None</em>, <em>lsmask_lons=None</em>, <em>lsmask_lats=None</em>, <em>lakes=True</em>, <em>resolution='l'</em>, <em>grid=5</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Basemap.drawlsmask" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw land-sea mask image.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The land-sea mask image cannot be overlaid on top
of other images, due to limitations in matplotlib image handling
(you can&#8217;t specify the zorder of an image).</p>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keywords</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>land_color</td>
<td>desired land color (color name or rgba tuple).
Default gray (&#8220;0.8&#8221;).</td>
</tr>
<tr class="row-odd"><td>ocean_color</td>
<td>desired water color (color name or rgba tuple).
Default white.</td>
</tr>
<tr class="row-even"><td>lsmask</td>
<td>An array of 0&#8217;s for ocean pixels, 1&#8217;s for
land pixels and 2&#8217;s for lake/pond pixels.
Default is None
(default 5-minute resolution land-sea mask is used).</td>
</tr>
<tr class="row-odd"><td>lakes</td>
<td>Plot lakes and ponds (Default True)</td>
</tr>
<tr class="row-even"><td>lsmask_lons</td>
<td>1d array of longitudes for lsmask (ignored
if lsmask is None). Longitudes must be ordered
from -180 W eastward.</td>
</tr>
<tr class="row-odd"><td>lsmask_lats</td>
<td>1d array of latitudes for lsmask (ignored
if lsmask is None). Latitudes must be ordered
from -90 S northward.</td>
</tr>
<tr class="row-even"><td>resolution</td>
<td>gshhs coastline resolution used to define land/sea
mask (default &#8216;l&#8217;, available &#8216;c&#8217;,&#8217;l&#8217;,&#8217;i&#8217;,&#8217;h&#8217; or &#8216;f&#8217;)</td>
</tr>
<tr class="row-odd"><td>grid</td>
<td>land/sea mask grid spacing in minutes (Default 5;
10, 2.5 and 1.25 are also available).</td>
</tr>
<tr class="row-even"><td>**kwargs</td>
<td>extra keyword arguments passed on to
<a class="reference internal" href="#nansat.Basemap.imshow" title="nansat.Basemap.imshow"><tt class="xref py py-meth docutils literal"><span class="pre">imshow()</span></tt></a></td>
</tr>
</tbody>
</table>
<p>If any of the lsmask, lsmask_lons or lsmask_lats keywords are not
set, the built in GSHHS land-sea mask datasets are used.</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>returns a matplotlib.image.AxesImage instance.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.drawmapboundary">
<tt class="descname">drawmapboundary</tt><big>(</big><em>color='k'</em>, <em>linewidth=1.0</em>, <em>fill_color=None</em>, <em>zorder=None</em>, <em>ax=None</em><big>)</big><a class="headerlink" href="#nansat.Basemap.drawmapboundary" title="Permalink to this definition">¶</a></dt>
<dd><p>draw boundary around map projection region, optionally
filling interior of region.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>linewidth</td>
<td>line width for boundary (default 1.)</td>
</tr>
<tr class="row-odd"><td>color</td>
<td>color of boundary line (default black)</td>
</tr>
<tr class="row-even"><td>fill_color</td>
<td>fill the map region background with this
color (default is to fill with axis
background color). If set to the string
&#8216;none&#8217;, no filling is done.</td>
</tr>
<tr class="row-odd"><td>zorder</td>
<td>sets the zorder for filling map background
(default 0).</td>
</tr>
<tr class="row-even"><td>ax</td>
<td>axes instance to use
(default None, use default axes instance).</td>
</tr>
</tbody>
</table>
<p>returns matplotlib.collections.PatchCollection representing map boundary.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.drawmapscale">
<tt class="descname">drawmapscale</tt><big>(</big><em>lon</em>, <em>lat</em>, <em>lon0</em>, <em>lat0</em>, <em>length</em>, <em>barstyle='simple'</em>, <em>units='km'</em>, <em>fontsize=9</em>, <em>yoffset=None</em>, <em>labelstyle='simple'</em>, <em>fontcolor='k'</em>, <em>fillcolor1='w'</em>, <em>fillcolor2='k'</em>, <em>ax=None</em>, <em>format='%d'</em>, <em>zorder=None</em><big>)</big><a class="headerlink" href="#nansat.Basemap.drawmapscale" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a map scale at <tt class="docutils literal"><span class="pre">lon,lat</span></tt> of length <tt class="docutils literal"><span class="pre">length</span></tt>
representing distance in the map
projection coordinates at <tt class="docutils literal"><span class="pre">lon0,lat0</span></tt>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keywords</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>units</td>
<td>the units of the length argument (Default km).</td>
</tr>
<tr class="row-odd"><td>barstyle</td>
<td><tt class="docutils literal"><span class="pre">simple</span></tt> or <tt class="docutils literal"><span class="pre">fancy</span></tt> (roughly corresponding
to the styles provided by Generic Mapping Tools).
Default <tt class="docutils literal"><span class="pre">simple</span></tt>.</td>
</tr>
<tr class="row-even"><td>fontsize</td>
<td>for map scale annotations, default 9.</td>
</tr>
<tr class="row-odd"><td>color</td>
<td>for map scale annotations, default black.</td>
</tr>
<tr class="row-even"><td>labelstype</td>
<td><tt class="docutils literal"><span class="pre">simple</span></tt> (default) or <tt class="docutils literal"><span class="pre">fancy</span></tt>.  For
<tt class="docutils literal"><span class="pre">fancy</span></tt> the map scale factor (ratio betwee
the actual distance and map projection distance
at lon0,lat0) and the value of lon0,lat0 are also
displayed on the top of the scale bar. For
<tt class="docutils literal"><span class="pre">simple</span></tt>, just the units are display on top
and the distance below the scale bar.
If equal to False, plot an empty label.</td>
</tr>
<tr class="row-odd"><td>format</td>
<td>a string formatter to format numeric values</td>
</tr>
<tr class="row-even"><td>yoffset</td>
<td>yoffset controls how tall the scale bar is,
and how far the annotations are offset from the
scale bar.  Default is 0.02 times the height of
the map (0.02*(self.ymax-self.ymin)).</td>
</tr>
<tr class="row-odd"><td>fillcolor1(2)</td>
<td>colors of the alternating filled regions
(default white and black).  Only relevant for
&#8216;fancy&#8217; barstyle.</td>
</tr>
<tr class="row-even"><td>zorder</td>
<td>sets the zorder for the map scale.</td>
</tr>
</tbody>
</table>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.drawmeridians">
<tt class="descname">drawmeridians</tt><big>(</big><em>meridians, color='k', linewidth=1.0, zorder=None, dashes=[1, 1], labels=[0, 0, 0, 0], labelstyle=None, fmt='%g', xoffset=None, yoffset=None, ax=None, latmax=None, **kwargs</em><big>)</big><a class="headerlink" href="#nansat.Basemap.drawmeridians" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw and label meridians (longitude lines) for values (in degrees)
given in the sequence <tt class="docutils literal"><span class="pre">meridians</span></tt>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>color</td>
<td>color to draw meridians (default black).</td>
</tr>
<tr class="row-odd"><td>linewidth</td>
<td>line width for meridians (default 1.)</td>
</tr>
<tr class="row-even"><td>zorder</td>
<td>sets the zorder for meridians (if not specified,
uses default zorder for matplotlib.lines.Line2D
objects).</td>
</tr>
<tr class="row-odd"><td>dashes</td>
<td>dash pattern for meridians (default [1,1], i.e.
1 pixel on, 1 pixel off).</td>
</tr>
<tr class="row-even"><td>labels</td>
<td>list of 4 values (default [0,0,0,0]) that control
whether meridians are labelled where they intersect
the left, right, top or bottom of the plot. For
example labels=[1,0,0,1] will cause meridians
to be labelled where they intersect the left and
and bottom of the plot, but not the right and top.</td>
</tr>
<tr class="row-odd"><td>labelstyle</td>
<td>if set to &#8220;+/-&#8221;, east and west longitudes are
labelled with &#8220;+&#8221; and &#8220;-&#8221;, otherwise they are
labelled with &#8220;E&#8221; and &#8220;W&#8221;.</td>
</tr>
<tr class="row-even"><td>fmt</td>
<td>a format string to format the meridian labels
(default &#8216;%g&#8217;) <strong>or</strong> a function that takes a
longitude value in degrees as it&#8217;s only argument
and returns a formatted string.</td>
</tr>
<tr class="row-odd"><td>xoffset</td>
<td>label offset from edge of map in x-direction
(default is 0.01 times width of map in map
projection coordinates).</td>
</tr>
<tr class="row-even"><td>yoffset</td>
<td>label offset from edge of map in y-direction
(default is 0.01 times height of map in map
projection coordinates).</td>
</tr>
<tr class="row-odd"><td>ax</td>
<td>axes instance (overrides default axes instance)</td>
</tr>
<tr class="row-even"><td>latmax</td>
<td>absolute value of latitude to which meridians are drawn
(default is 80).</td>
</tr>
<tr class="row-odd"><td>**kwargs</td>
<td>additional keyword arguments controlling text
for labels that are passed on to
the text method of the axes instance (see
matplotlib.pyplot.text documentation).</td>
</tr>
</tbody>
</table>
<p>returns a dictionary whose keys are the meridian values, and
whose values are tuples containing lists of the
matplotlib.lines.Line2D and matplotlib.text.Text instances
associated with each meridian. Deleting an item from the
dictionary removes the correpsonding meridian from the plot.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.drawparallels">
<tt class="descname">drawparallels</tt><big>(</big><em>circles, color='k', linewidth=1.0, zorder=None, dashes=[1, 1], labels=[0, 0, 0, 0], labelstyle=None, fmt='%g', xoffset=None, yoffset=None, ax=None, latmax=None, **kwargs</em><big>)</big><a class="headerlink" href="#nansat.Basemap.drawparallels" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw and label parallels (latitude lines) for values (in degrees)
given in the sequence <tt class="docutils literal"><span class="pre">circles</span></tt>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>color</td>
<td>color to draw parallels (default black).</td>
</tr>
<tr class="row-odd"><td>linewidth</td>
<td>line width for parallels (default 1.)</td>
</tr>
<tr class="row-even"><td>zorder</td>
<td>sets the zorder for parallels (if not specified,
uses default zorder for matplotlib.lines.Line2D
objects).</td>
</tr>
<tr class="row-odd"><td>dashes</td>
<td>dash pattern for parallels (default [1,1], i.e.
1 pixel on, 1 pixel off).</td>
</tr>
<tr class="row-even"><td>labels</td>
<td>list of 4 values (default [0,0,0,0]) that control
whether parallels are labelled where they intersect
the left, right, top or bottom of the plot. For
example labels=[1,0,0,1] will cause parallels
to be labelled where they intersect the left and
and bottom of the plot, but not the right and top.</td>
</tr>
<tr class="row-odd"><td>labelstyle</td>
<td>if set to &#8220;+/-&#8221;, north and south latitudes are
labelled with &#8220;+&#8221; and &#8220;-&#8221;, otherwise they are
labelled with &#8220;N&#8221; and &#8220;S&#8221;.</td>
</tr>
<tr class="row-even"><td>fmt</td>
<td>a format string to format the parallel labels
(default &#8216;%g&#8217;) <strong>or</strong> a function that takes a
latitude value in degrees as it&#8217;s only argument
and returns a formatted string.</td>
</tr>
<tr class="row-odd"><td>xoffset</td>
<td>label offset from edge of map in x-direction
(default is 0.01 times width of map in map
projection coordinates).</td>
</tr>
<tr class="row-even"><td>yoffset</td>
<td>label offset from edge of map in y-direction
(default is 0.01 times height of map in map
projection coordinates).</td>
</tr>
<tr class="row-odd"><td>ax</td>
<td>axes instance (overrides default axes instance)</td>
</tr>
<tr class="row-even"><td>latmax</td>
<td>absolute value of latitude to which meridians are drawn
(default is 80).</td>
</tr>
<tr class="row-odd"><td>**kwargs</td>
<td>additional keyword arguments controlling text
for labels that are passed on to
the text method of the axes instance (see
matplotlib.pyplot.text documentation).</td>
</tr>
</tbody>
</table>
<p>returns a dictionary whose keys are the parallel values, and
whose values are tuples containing lists of the
matplotlib.lines.Line2D and matplotlib.text.Text instances
associated with each parallel. Deleting an item from the
dictionary removes the corresponding parallel from the plot.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.drawrivers">
<tt class="descname">drawrivers</tt><big>(</big><em>linewidth=0.5</em>, <em>linestyle='solid'</em>, <em>color='k'</em>, <em>antialiased=1</em>, <em>ax=None</em>, <em>zorder=None</em><big>)</big><a class="headerlink" href="#nansat.Basemap.drawrivers" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw major rivers.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>linewidth</td>
<td>river boundary line width (default 0.5)</td>
</tr>
<tr class="row-odd"><td>linestyle</td>
<td>coastline linestyle (default solid)</td>
</tr>
<tr class="row-even"><td>color</td>
<td>river boundary line color (default black)</td>
</tr>
<tr class="row-odd"><td>antialiased</td>
<td>antialiasing switch for river boundaries (default
True).</td>
</tr>
<tr class="row-even"><td>ax</td>
<td>axes instance (overrides default axes instance)</td>
</tr>
<tr class="row-odd"><td>zorder</td>
<td>sets the zorder for the rivers (if not
specified uses default zorder for
matplotlib.patches.LineCollections).</td>
</tr>
</tbody>
</table>
<p>returns a matplotlib.patches.LineCollection object.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.drawstates">
<tt class="descname">drawstates</tt><big>(</big><em>linewidth=0.5</em>, <em>linestyle='solid'</em>, <em>color='k'</em>, <em>antialiased=1</em>, <em>ax=None</em>, <em>zorder=None</em><big>)</big><a class="headerlink" href="#nansat.Basemap.drawstates" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw state boundaries in Americas.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>linewidth</td>
<td>state boundary line width (default 0.5)</td>
</tr>
<tr class="row-odd"><td>linestyle</td>
<td>coastline linestyle (default solid)</td>
</tr>
<tr class="row-even"><td>color</td>
<td>state boundary line color (default black)</td>
</tr>
<tr class="row-odd"><td>antialiased</td>
<td>antialiasing switch for state boundaries
(default True).</td>
</tr>
<tr class="row-even"><td>ax</td>
<td>axes instance (overrides default axes instance)</td>
</tr>
<tr class="row-odd"><td>zorder</td>
<td>sets the zorder for the state boundaries (if not
specified, uses default zorder for
matplotlib.patches.LineCollections).</td>
</tr>
</tbody>
</table>
<p>returns a matplotlib.patches.LineCollection object.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.etopo">
<tt class="descname">etopo</tt><big>(</big><em>ax=None</em>, <em>scale=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Basemap.etopo" title="Permalink to this definition">¶</a></dt>
<dd><p>display etopo relief image (from
<a class="reference external" href="http://www.ngdc.noaa.gov/mgg/global/global.html">http://www.ngdc.noaa.gov/mgg/global/global.html</a>)
as map background.
Default image size is 5400x2700, which can be quite slow and
use quite a bit of memory.  The <tt class="docutils literal"><span class="pre">scale</span></tt> keyword can be used
to downsample the image (<tt class="docutils literal"><span class="pre">scale=0.5</span></tt> downsamples to 5400x2700).</p>
<p>**kwargs passed on to <a class="reference internal" href="#nansat.Basemap.imshow" title="nansat.Basemap.imshow"><tt class="xref py py-meth docutils literal"><span class="pre">imshow()</span></tt></a>.</p>
<p>returns a matplotlib.image.AxesImage instance.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.fillcontinents">
<tt class="descname">fillcontinents</tt><big>(</big><em>color='0.8'</em>, <em>lake_color=None</em>, <em>ax=None</em>, <em>zorder=None</em>, <em>alpha=None</em><big>)</big><a class="headerlink" href="#nansat.Basemap.fillcontinents" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill continents.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>color</td>
<td>color to fill continents (default gray).</td>
</tr>
<tr class="row-odd"><td>lake_color</td>
<td>color to fill inland lakes (default axes background).</td>
</tr>
<tr class="row-even"><td>ax</td>
<td>axes instance (overrides default axes instance).</td>
</tr>
<tr class="row-odd"><td>zorder</td>
<td>sets the zorder for the continent polygons (if not
specified, uses default zorder for a Polygon patch).
Set to zero if you want to paint over the filled
continents).</td>
</tr>
<tr class="row-even"><td>alpha</td>
<td>sets alpha transparency for continent polygons</td>
</tr>
</tbody>
</table>
<p>After filling continents, lakes are re-filled with
axis background color.</p>
<p>returns a list of matplotlib.patches.Polygon objects.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.gcpoints">
<tt class="descname">gcpoints</tt><big>(</big><em>lon1</em>, <em>lat1</em>, <em>lon2</em>, <em>lat2</em>, <em>npoints</em><big>)</big><a class="headerlink" href="#nansat.Basemap.gcpoints" title="Permalink to this definition">¶</a></dt>
<dd><p>compute <tt class="docutils literal"><span class="pre">points</span></tt> points along a great circle with endpoints
<tt class="docutils literal"><span class="pre">(lon1,lat1)</span></tt> and <tt class="docutils literal"><span class="pre">(lon2,lat2)</span></tt>.</p>
<p>Returns arrays x,y with map projection coordinates.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.hexbin">
<tt class="descname">hexbin</tt><big>(</big><em>x</em>, <em>y</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Basemap.hexbin" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a hexagonal binning plot of x versus y, where x, y are 1-D
sequences of the same length, N. If C is None (the default), this is a
histogram of the number of occurences of the observations at
(x[i],y[i]).</p>
<p>If C is specified, it specifies values at the coordinate (x[i],y[i]).
These values are accumulated for each hexagonal bin and then reduced
according to reduce_C_function, which defaults to the numpy mean function
(np.mean). (If C is specified, it must also be a 1-D sequence of the
same length as x and y.)</p>
<p>x, y and/or C may be masked arrays, in which case only unmasked points
will be plotted.</p>
<p>(see matplotlib.pyplot.hexbin documentation).</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>Other **kwargs passed on to matplotlib.pyplot.hexbin</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.imshow">
<tt class="descname">imshow</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Basemap.imshow" title="Permalink to this definition">¶</a></dt>
<dd><p>Display an image over the map
(see matplotlib.pyplot.imshow documentation).</p>
<p><tt class="docutils literal"><span class="pre">extent</span></tt> and <tt class="docutils literal"><span class="pre">origin</span></tt> keywords set automatically so image
will be drawn over map region.</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>Other **kwargs passed on to matplotlib.pyplot.plot.</p>
<p>returns an matplotlib.image.AxesImage instance.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.is_land">
<tt class="descname">is_land</tt><big>(</big><em>xpt</em>, <em>ypt</em><big>)</big><a class="headerlink" href="#nansat.Basemap.is_land" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the given x,y point (in projection coordinates) is
over land, False otherwise.  The definition of land is based upon
the GSHHS coastline polygons associated with the class instance.
Points over lakes inside land regions are not counted as land points.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.makegrid">
<tt class="descname">makegrid</tt><big>(</big><em>nx</em>, <em>ny</em>, <em>returnxy=False</em><big>)</big><a class="headerlink" href="#nansat.Basemap.makegrid" title="Permalink to this definition">¶</a></dt>
<dd><p>return arrays of shape (ny,nx) containing lon,lat coordinates of
an equally spaced native projection grid.</p>
<p>If <tt class="docutils literal"><span class="pre">returnxy</span> <span class="pre">=</span> <span class="pre">True</span></tt>, the x,y values of the grid are returned also.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.nightshade">
<tt class="descname">nightshade</tt><big>(</big><em>date</em>, <em>color='k'</em>, <em>delta=0.25</em>, <em>alpha=0.5</em>, <em>ax=None</em>, <em>zorder=2</em><big>)</big><a class="headerlink" href="#nansat.Basemap.nightshade" title="Permalink to this definition">¶</a></dt>
<dd><p>Shade the regions of the map that are in darkness at the time
specifed by <tt class="docutils literal"><span class="pre">date</span></tt>.  <tt class="docutils literal"><span class="pre">date</span></tt> is a datetime instance,
assumed to be UTC.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keywords</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>color</td>
<td>color to shade night regions (default black).</td>
</tr>
<tr class="row-odd"><td>delta</td>
<td>day/night terminator is computed with a
a resolution of <tt class="docutils literal"><span class="pre">delta</span></tt> degrees (default 0.25).</td>
</tr>
<tr class="row-even"><td>alpha</td>
<td>alpha transparency for shading (default 0.5, so
map background shows through).</td>
</tr>
<tr class="row-odd"><td>zorder</td>
<td>zorder for shading (default 2).</td>
</tr>
</tbody>
</table>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>returns a matplotlib.contour.ContourSet instance.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.pcolor">
<tt class="descname">pcolor</tt><big>(</big><em>x</em>, <em>y</em>, <em>data</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Basemap.pcolor" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a pseudo-color plot over the map
(see matplotlib.pyplot.pcolor documentation).</p>
<p>If <tt class="docutils literal"><span class="pre">latlon</span></tt> keyword is set to True, x,y are intrepreted as
longitude and latitude in degrees.  Data and longitudes are
automatically shifted to match map projection region for cylindrical
and pseudocylindrical projections, and x,y are transformed to map
projection coordinates. If <tt class="docutils literal"><span class="pre">latlon</span></tt> is False (default), x and y
are assumed to be map projection coordinates.</p>
<p>If x or y are outside projection limb (i.e. they have values &gt; 1.e20)
they will be convert to masked arrays with those values masked.
As a result, those values will not be plotted.</p>
<p>If <tt class="docutils literal"><span class="pre">tri</span></tt> is set to <tt class="docutils literal"><span class="pre">True</span></tt>, an unstructured grid is assumed
(x,y,data must be 1-d) and matplotlib.pyplot.tricolor is used.</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>Other **kwargs passed on to matplotlib.pyplot.pcolor (or tricolor if
<tt class="docutils literal"><span class="pre">tri=True</span></tt>).</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.pcolormesh">
<tt class="descname">pcolormesh</tt><big>(</big><em>x</em>, <em>y</em>, <em>data</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Basemap.pcolormesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a pseudo-color plot over the map
(see matplotlib.pyplot.pcolormesh documentation).</p>
<p>If <tt class="docutils literal"><span class="pre">latlon</span></tt> keyword is set to True, x,y are intrepreted as
longitude and latitude in degrees.  Data and longitudes are
automatically shifted to match map projection region for cylindrical
and pseudocylindrical projections, and x,y are transformed to map
projection coordinates. If <tt class="docutils literal"><span class="pre">latlon</span></tt> is False (default), x and y
are assumed to be map projection coordinates.</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>Other **kwargs passed on to matplotlib.pyplot.pcolormesh.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.plot">
<tt class="descname">plot</tt><big>(</big><em>x</em>, <em>y</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Basemap.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw lines and/or markers on the map
(see matplotlib.pyplot.plot documentation).</p>
<p>If <tt class="docutils literal"><span class="pre">latlon</span></tt> keyword is set to True, x,y are intrepreted as
longitude and latitude in degrees.  Data and longitudes are
automatically shifted to match map projection region for cylindrical
and pseudocylindrical projections, and x,y are transformed to map
projection coordinates. If <tt class="docutils literal"><span class="pre">latlon</span></tt> is False (default), x and y
are assumed to be map projection coordinates.</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>Other **kwargs passed on to matplotlib.pyplot.plot.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.quiver">
<tt class="descname">quiver</tt><big>(</big><em>x</em>, <em>y</em>, <em>u</em>, <em>v</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Basemap.quiver" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a vector plot (u, v) with arrows on the map.
Grid must be evenly spaced regular grid in x and y.
(see matplotlib.pyplot.quiver documentation).</p>
<p>If <tt class="docutils literal"><span class="pre">latlon</span></tt> keyword is set to True, x,y are intrepreted as
longitude and latitude in degrees.  Data and longitudes are
automatically shifted to match map projection region for cylindrical
and pseudocylindrical projections, and x,y are transformed to map
projection coordinates. If <tt class="docutils literal"><span class="pre">latlon</span></tt> is False (default), x and y
are assumed to be map projection coordinates.</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>Other *args and **kwargs passed on to matplotlib.pyplot.quiver.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.readshapefile">
<tt class="descname">readshapefile</tt><big>(</big><em>shapefile</em>, <em>name</em>, <em>drawbounds=True</em>, <em>zorder=None</em>, <em>linewidth=0.5</em>, <em>color='k'</em>, <em>antialiased=1</em>, <em>ax=None</em>, <em>default_encoding='utf-8'</em><big>)</big><a class="headerlink" href="#nansat.Basemap.readshapefile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read in shape file, optionally draw boundaries on map.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>Assumes shapes are 2D</li>
<li>only works for Point, MultiPoint, Polyline and Polygon shapes.</li>
<li>vertices/points must be in geographic (lat/lon) coordinates.</li>
</ul>
</div>
<p>Mandatory Arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Argument</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>shapefile</td>
<td>path to shapefile components.  Example:
shapefile=&#8217;/home/jeff/esri/world_borders&#8217; assumes
that world_borders.shp, world_borders.shx and
world_borders.dbf live in /home/jeff/esri.</td>
</tr>
<tr class="row-odd"><td>name</td>
<td>name for Basemap attribute to hold the shapefile
vertices or points in map projection
coordinates. Class attribute name+&#8217;_info&#8217; is a list
of dictionaries, one for each shape, containing
attributes of each shape from dbf file, For
example, if name=&#8217;counties&#8217;, self.counties
will be a list of x,y vertices for each shape in
map projection  coordinates and self.counties_info
will be a list of dictionaries with shape
attributes.  Rings in individual Polygon
shapes are split out into separate polygons, and
additional keys &#8216;RINGNUM&#8217; and &#8216;SHAPENUM&#8217; are added
to the shape attribute dictionary.</td>
</tr>
</tbody>
</table>
<p>The following optional keyword arguments are only relevant for Polyline
and Polygon shape types, for Point and MultiPoint shapes they are
ignored.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>drawbounds</td>
<td>draw boundaries of shapes (default True).</td>
</tr>
<tr class="row-odd"><td>zorder</td>
<td>shape boundary zorder (if not specified,
default for mathplotlib.lines.LineCollection
is used).</td>
</tr>
<tr class="row-even"><td>linewidth</td>
<td>shape boundary line width (default 0.5)</td>
</tr>
<tr class="row-odd"><td>color</td>
<td>shape boundary line color (default black)</td>
</tr>
<tr class="row-even"><td>antialiased</td>
<td>antialiasing switch for shape boundaries
(default True).</td>
</tr>
<tr class="row-odd"><td>ax</td>
<td>axes instance (overrides default axes instance)</td>
</tr>
</tbody>
</table>
<p>A tuple (num_shapes, type, min, max) containing shape file info
is returned.
num_shapes is the number of shapes, type is the type code (one of
the SHPT* constants defined in the shapelib module, see
<a class="reference external" href="http://shapelib.maptools.org/shp_api.html">http://shapelib.maptools.org/shp_api.html</a>) and min and
max are 4-element lists with the minimum and maximum values of the
vertices. If <tt class="docutils literal"><span class="pre">drawbounds=True</span></tt> a
matplotlib.patches.LineCollection object is appended to the tuple.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.rotate_vector">
<tt class="descname">rotate_vector</tt><big>(</big><em>uin</em>, <em>vin</em>, <em>lons</em>, <em>lats</em>, <em>returnxy=False</em><big>)</big><a class="headerlink" href="#nansat.Basemap.rotate_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate a vector field (<tt class="docutils literal"><span class="pre">uin,vin</span></tt>) on a rectilinear grid
with longitudes = <tt class="docutils literal"><span class="pre">lons</span></tt> and latitudes = <tt class="docutils literal"><span class="pre">lats</span></tt> from
geographical (lat/lon) into map projection (x/y) coordinates.</p>
<p>Differs from transform_vector in that no interpolation is done.
The vector is returned on the same grid, but rotated into
x,y coordinates.</p>
<p>The input vector field is defined in spherical coordinates (it
has eastward and northward components) while the output
vector field is rotated to map projection coordinates (relative
to x and y). The magnitude of the vector is preserved.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Arguments</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>uin, vin</td>
<td>input vector field on a lat/lon grid.</td>
</tr>
<tr class="row-odd"><td>lons, lats</td>
<td>Arrays containing longitudes and latitudes
(in degrees) of input data in increasing order.
For non-cylindrical projections (those other than
<tt class="docutils literal"><span class="pre">cyl</span></tt>, <tt class="docutils literal"><span class="pre">merc</span></tt>, <tt class="docutils literal"><span class="pre">cyl</span></tt>, <tt class="docutils literal"><span class="pre">gall</span></tt> and <tt class="docutils literal"><span class="pre">mill</span></tt>) lons
must fit within range -180 to 180.</td>
</tr>
</tbody>
</table>
<p>Returns <tt class="docutils literal"><span class="pre">uout,</span> <span class="pre">vout</span></tt> (rotated vector field).
If the optional keyword argument
<tt class="docutils literal"><span class="pre">returnxy</span></tt> is True (default is False),
returns <tt class="docutils literal"><span class="pre">uout,vout,x,y</span></tt> (where <tt class="docutils literal"><span class="pre">x,y</span></tt> are the map projection
coordinates of the grid defined by <tt class="docutils literal"><span class="pre">lons,lats</span></tt>).</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.scatter">
<tt class="descname">scatter</tt><big>(</big><em>x</em>, <em>y</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Basemap.scatter" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot points with markers on the map
(see matplotlib.pyplot.scatter documentation).</p>
<p>If <tt class="docutils literal"><span class="pre">latlon</span></tt> keyword is set to True, x,y are intrepreted as
longitude and latitude in degrees.  Data and longitudes are
automatically shifted to match map projection region for cylindrical
and pseudocylindrical projections, and x,y are transformed to map
projection coordinates. If <tt class="docutils literal"><span class="pre">latlon</span></tt> is False (default), x and y
are assumed to be map projection coordinates.</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axes instance.</p>
<p>Other **kwargs passed on to matplotlib.pyplot.scatter.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.set_axes_limits">
<tt class="descname">set_axes_limits</tt><big>(</big><em>ax=None</em><big>)</big><a class="headerlink" href="#nansat.Basemap.set_axes_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Final step in Basemap method wrappers of Axes plotting methods:</p>
<p>Set axis limits, fix aspect ratio for map domain using current
or specified axes instance.  This is done only once per axes
instance.</p>
<p>In interactive mode, this method always calls draw_if_interactive
before returning.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.shadedrelief">
<tt class="descname">shadedrelief</tt><big>(</big><em>ax=None</em>, <em>scale=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Basemap.shadedrelief" title="Permalink to this definition">¶</a></dt>
<dd><p>display shaded relief image (from <a class="reference external" href="http://www.shadedrelief.com">http://www.shadedrelief.com</a>)
as map background.
Default image size is 10800x5400, which can be quite slow and
use quite a bit of memory.  The <tt class="docutils literal"><span class="pre">scale</span></tt> keyword can be used
to downsample the image (<tt class="docutils literal"><span class="pre">scale=0.5</span></tt> downsamples to 5400x2700).</p>
<p>**kwargs passed on to <a class="reference internal" href="#nansat.Basemap.imshow" title="nansat.Basemap.imshow"><tt class="xref py py-meth docutils literal"><span class="pre">imshow()</span></tt></a>.</p>
<p>returns a matplotlib.image.AxesImage instance.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.shiftdata">
<tt class="descname">shiftdata</tt><big>(</big><em>lonsin</em>, <em>datain=None</em>, <em>lon_0=None</em><big>)</big><a class="headerlink" href="#nansat.Basemap.shiftdata" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift longitudes (and optionally data) so that they match map projection region.
Only valid for cylindrical/pseudo-cylindrical global projections and data
on regular lat/lon grids. longitudes and data can be 1-d or 2-d, if 2-d
it is assumed longitudes are 2nd (rightmost) dimension.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Arguments</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>lonsin</td>
<td>original 1-d or 2-d longitudes.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keywords</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>datain</td>
<td>original 1-d or 2-d data. Default None.</td>
</tr>
<tr class="row-odd"><td>lon_0</td>
<td>center of map projection region. Defaut None,
given by current map projection.</td>
</tr>
</tbody>
</table>
<p>if datain given, returns <tt class="docutils literal"><span class="pre">dataout,lonsout</span></tt> (data and longitudes shifted to fit in interval
[lon_0-180,lon_0+180]), otherwise just returns longitudes.  If
transformed longitudes lie outside map projection region, data is
masked and longitudes are set to 1.e30.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.streamplot">
<tt class="descname">streamplot</tt><big>(</big><em>x</em>, <em>y</em>, <em>u</em>, <em>v</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Basemap.streamplot" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws streamlines of a vector flow.
(see matplotlib.pyplot.streamplot documentation).</p>
<p>If <tt class="docutils literal"><span class="pre">latlon</span></tt> keyword is set to True, x,y are intrepreted as
longitude and latitude in degrees.  Data and longitudes are
automatically shifted to match map projection region for cylindrical
and pseudocylindrical projections, and x,y are transformed to map
projection coordinates. If <tt class="docutils literal"><span class="pre">latlon</span></tt> is False (default), x and y
are assumed to be map projection coordinates.</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>Other *args and **kwargs passed on to matplotlib.pyplot.streamplot.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.tissot">
<tt class="descname">tissot</tt><big>(</big><em>lon_0</em>, <em>lat_0</em>, <em>radius_deg</em>, <em>npts</em>, <em>ax=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Basemap.tissot" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a polygon centered at <tt class="docutils literal"><span class="pre">lon_0,lat_0</span></tt>.  The polygon
approximates a circle on the surface of the earth with radius
<tt class="docutils literal"><span class="pre">radius_deg</span></tt> degrees latitude along longitude <tt class="docutils literal"><span class="pre">lon_0</span></tt>,
made up of <tt class="docutils literal"><span class="pre">npts</span></tt> vertices.
The polygon represents a Tissot&#8217;s indicatrix
(<a class="reference external" href="http://en.wikipedia.org/wiki/Tissot's_Indicatrix">http://en.wikipedia.org/wiki/Tissot&#8217;s_Indicatrix</a>),
which when drawn on a map shows the distortion
inherent in the map projection.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Cannot handle situations in which the polygon intersects
the edge of the map projection domain, and then re-enters the domain.</p>
</div>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>Other **kwargs passed on to matplotlib.patches.Polygon.</p>
<p>returns a matplotlib.patches.Polygon object.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.transform_scalar">
<tt class="descname">transform_scalar</tt><big>(</big><em>datin</em>, <em>lons</em>, <em>lats</em>, <em>nx</em>, <em>ny</em>, <em>returnxy=False</em>, <em>checkbounds=False</em>, <em>order=1</em>, <em>masked=False</em><big>)</big><a class="headerlink" href="#nansat.Basemap.transform_scalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate a scalar field (<tt class="docutils literal"><span class="pre">datin</span></tt>) from a lat/lon grid with
longitudes = <tt class="docutils literal"><span class="pre">lons</span></tt> and latitudes = <tt class="docutils literal"><span class="pre">lats</span></tt> to a <tt class="docutils literal"><span class="pre">ny</span></tt> by <tt class="docutils literal"><span class="pre">nx</span></tt>
map projection grid.  Typically used to transform data to
map projection coordinates for plotting on a map with
the <a class="reference internal" href="#nansat.Basemap.imshow" title="nansat.Basemap.imshow"><tt class="xref py py-meth docutils literal"><span class="pre">imshow()</span></tt></a>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Argument</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>datin</td>
<td>input data on a lat/lon grid.</td>
</tr>
<tr class="row-odd"><td>lons, lats</td>
<td>rank-1 arrays containing longitudes and latitudes
(in degrees) of input data in increasing order.
For non-cylindrical projections (those other than
<tt class="docutils literal"><span class="pre">cyl</span></tt>, <tt class="docutils literal"><span class="pre">merc</span></tt>, <tt class="docutils literal"><span class="pre">cea</span></tt>, <tt class="docutils literal"><span class="pre">gall</span></tt> and <tt class="docutils literal"><span class="pre">mill</span></tt>) lons
must fit within range -180 to 180.</td>
</tr>
<tr class="row-even"><td>nx, ny</td>
<td>The size of the output regular grid in map
projection coordinates</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>returnxy</td>
<td>If True, the x and y values of the map
projection grid are also returned (Default False).</td>
</tr>
<tr class="row-odd"><td>checkbounds</td>
<td>If True, values of lons and lats are checked to see
that they lie within the map projection region.
Default is False, and data outside map projection
region is clipped to values on boundary.</td>
</tr>
<tr class="row-even"><td>masked</td>
<td>If True, interpolated data is returned as a masked
array with values outside map projection region
masked (Default False).</td>
</tr>
<tr class="row-odd"><td>order</td>
<td>0 for nearest-neighbor interpolation, 1 for
bilinear, 3 for cubic spline (Default 1).
Cubic spline interpolation requires scipy.ndimage.</td>
</tr>
</tbody>
</table>
<p>Returns <tt class="docutils literal"><span class="pre">datout</span></tt> (data on map projection grid).
If returnxy=True, returns <tt class="docutils literal"><span class="pre">data,x,y</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.transform_vector">
<tt class="descname">transform_vector</tt><big>(</big><em>uin</em>, <em>vin</em>, <em>lons</em>, <em>lats</em>, <em>nx</em>, <em>ny</em>, <em>returnxy=False</em>, <em>checkbounds=False</em>, <em>order=1</em>, <em>masked=False</em><big>)</big><a class="headerlink" href="#nansat.Basemap.transform_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate and interpolate a vector field (<tt class="docutils literal"><span class="pre">uin,vin</span></tt>) from a
lat/lon grid with longitudes = <tt class="docutils literal"><span class="pre">lons</span></tt> and latitudes = <tt class="docutils literal"><span class="pre">lats</span></tt>
to a <tt class="docutils literal"><span class="pre">ny</span></tt> by <tt class="docutils literal"><span class="pre">nx</span></tt> map projection grid.</p>
<p>The input vector field is defined in spherical coordinates (it
has eastward and northward components) while the output
vector field is rotated to map projection coordinates (relative
to x and y). The magnitude of the vector is preserved.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Arguments</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>uin, vin</td>
<td>input vector field on a lat/lon grid.</td>
</tr>
<tr class="row-odd"><td>lons, lats</td>
<td>rank-1 arrays containing longitudes and latitudes
(in degrees) of input data in increasing order.
For non-cylindrical projections (those other than
<tt class="docutils literal"><span class="pre">cyl</span></tt>, <tt class="docutils literal"><span class="pre">merc</span></tt>, <tt class="docutils literal"><span class="pre">cea</span></tt>, <tt class="docutils literal"><span class="pre">gall</span></tt> and <tt class="docutils literal"><span class="pre">mill</span></tt>) lons
must fit within range -180 to 180.</td>
</tr>
<tr class="row-even"><td>nx, ny</td>
<td>The size of the output regular grid in map
projection coordinates</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>returnxy</td>
<td>If True, the x and y values of the map
projection grid are also returned (Default False).</td>
</tr>
<tr class="row-odd"><td>checkbounds</td>
<td>If True, values of lons and lats are checked to see
that they lie within the map projection region.
Default is False, and data outside map projection
region is clipped to values on boundary.</td>
</tr>
<tr class="row-even"><td>masked</td>
<td>If True, interpolated data is returned as a masked
array with values outside map projection region
masked (Default False).</td>
</tr>
<tr class="row-odd"><td>order</td>
<td>0 for nearest-neighbor interpolation, 1 for
bilinear, 3 for cubic spline (Default 1).
Cubic spline interpolation requires scipy.ndimage.</td>
</tr>
</tbody>
</table>
<p>Returns <tt class="docutils literal"><span class="pre">uout,</span> <span class="pre">vout</span></tt> (vector field on map projection grid).
If returnxy=True, returns <tt class="docutils literal"><span class="pre">uout,vout,x,y</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.warpimage">
<tt class="descname">warpimage</tt><big>(</big><em>image='bluemarble'</em>, <em>scale=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Basemap.warpimage" title="Permalink to this definition">¶</a></dt>
<dd><p>Display an image (filename given by <tt class="docutils literal"><span class="pre">image</span></tt> keyword) as a map background.
If image is a URL (starts with &#8216;http&#8217;), it is downloaded to a temp
file using urllib.urlretrieve.</p>
<p>Default (if <tt class="docutils literal"><span class="pre">image</span></tt> not specified) is to display
&#8216;blue marble next generation&#8217; image from <a class="reference external" href="http://visibleearth.nasa.gov/">http://visibleearth.nasa.gov/</a>.</p>
<p>Specified image must have pixels covering the whole globe in a regular
lat/lon grid, starting and -180W and the South Pole.
Works with the global images from
<a class="reference external" href="http://earthobservatory.nasa.gov/Features/BlueMarble/BlueMarble_monthlies.php">http://earthobservatory.nasa.gov/Features/BlueMarble/BlueMarble_monthlies.php</a>.</p>
<p>The <tt class="docutils literal"><span class="pre">scale</span></tt> keyword can be used to downsample (rescale) the image.
Values less than 1.0 will speed things up at the expense of image
resolution.</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>**kwargs passed on to <a class="reference internal" href="#nansat.Basemap.imshow" title="nansat.Basemap.imshow"><tt class="xref py py-meth docutils literal"><span class="pre">imshow()</span></tt></a>.</p>
<p>returns a matplotlib.image.AxesImage instance.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.Basemap.wmsimage">
<tt class="descname">wmsimage</tt><big>(</big><em>server</em>, <em>xpixels=400</em>, <em>ypixels=None</em>, <em>format='png'</em>, <em>verbose=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Basemap.wmsimage" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve an image using from a WMS server using the
Open Geospatial Consortium (OGC) standard interface
and display on the map. Requires OWSLib
(<a class="reference external" href="http://pypi.python.org/pypi/OWSLib">http://pypi.python.org/pypi/OWSLib</a>).
In order to use this method, the Basemap instance must be
created using the <tt class="docutils literal"><span class="pre">epsg</span></tt> keyword to define the map projection, unless
the <tt class="docutils literal"><span class="pre">cyl</span></tt> projection is used (in which case the epsg code 4326 is
assumed).</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keywords</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>server</td>
<td>WMS server URL.</td>
</tr>
<tr class="row-odd"><td>xpixels</td>
<td>requested number of image pixels in x-direction
(default 400).</td>
</tr>
<tr class="row-even"><td>ypixels</td>
<td>requested number of image pixels in y-direction.
Default (None) is to infer the number from
from xpixels and the aspect ratio of the
map projection region.</td>
</tr>
<tr class="row-odd"><td>format</td>
<td>desired image format (default &#8216;png&#8217;)</td>
</tr>
<tr class="row-even"><td>verbose</td>
<td>if True, print WMS server info (default
False).</td>
</tr>
<tr class="row-odd"><td>**kwargs</td>
<td>extra keyword arguments passed on to
OWSLib.wms.WebMapService.getmap.</td>
</tr>
</tbody>
</table>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>returns a matplotlib.image.AxesImage instance.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nansat.Mosaic">
<em class="property">class </em><tt class="descclassname">nansat.</tt><tt class="descname">Mosaic</tt><big>(</big><em>fileName=''</em>, <em>mapperName=''</em>, <em>domain=None</em>, <em>array=None</em>, <em>parameters=None</em>, <em>logLevel=30</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.Mosaic" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">nansat.nansat.Nansat</span></tt></p>
<p>Container for mosaicing methods</p>
<p>Mosaic inherits everything from Nansat</p>
<dl class="method">
<dt id="nansat.Mosaic.average">
<tt class="descname">average</tt><big>(</big><em>files=[], bands=[1], doReproject=True, maskName='mask', threads=1, **kwargs</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.average" title="Permalink to this definition">¶</a></dt>
<dd><p>Memory-friendly, multithreaded mosaicing(averaging) of input files</p>
<div class="line-block">
<div class="line">Convert all input files into Nansat objects, reproject onto the</div>
<div class="line">Domain of the current object, get bands, from each object,
calculate average and STD, add averaged bands (and STD) to
the current object.</div>
<div class="line">average() tries to get band &#8216;mask&#8217; from the input files. The mask
should have the following coding</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Code:</th><td class="field-body"><div class="first last line-block">
<div class="line">0 : nodata</div>
<div class="line">1 : clouds</div>
<div class="line">2 : land</div>
<div class="line">64 : valid pixel</div>
</div>
</td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line">If it gets that band (which can be provided by some mappers or Nansat
childs, e.g.  ModisL2Image) it uses it to select averagable pixels
(i.e. where mask == 64).</div>
<div class="line">If it cannot locate the band &#8216;mask&#8217; is assumes that all pixels are
averagebale except for thouse out of swath after reprojection.</div>
<div class="line">average() adds bands to the object, so it works only with empty, or
non-projected objects</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>files</strong> : list</p>
<blockquote>
<div><p>list of input files</p>
</div></blockquote>
<p><strong>bands</strong> : list</p>
<blockquote>
<div><p>list of names/band_numbers to be processed</p>
</div></blockquote>
<p><strong>doReproject</strong> : boolean, [True]</p>
<blockquote>
<div><p>reproject input files?</p>
</div></blockquote>
<p><strong>maskName</strong> : str, [&#8216;mask&#8217;]</p>
<blockquote>
<div><p>name of the mask in input files</p>
</div></blockquote>
<p><strong>nClass</strong> : child of Nansat, [Nansat]</p>
<blockquote>
<div><p>This class is used to read input files</p>
</div></blockquote>
<p><strong>threads</strong> : int</p>
<blockquote>
<div><p>number of parallel processes to use</p>
</div></blockquote>
<p><strong>eResampleAlg</strong> : int, [0]</p>
<blockquote>
<div><p>agorithm for reprojection, see Nansat.reproject()</p>
</div></blockquote>
<p><strong>period</strong> : [datetime0, datetime1]</p>
<blockquote class="last">
<div><p>Start and stop datetime objects from pyhon datetime.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="nansat.Mosaic.bandNames">
<tt class="descname">bandNames</tt><em class="property"> = [1]</em><a class="headerlink" href="#nansat.Mosaic.bandNames" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Mosaic.doReproject">
<tt class="descname">doReproject</tt><em class="property"> = True</em><a class="headerlink" href="#nansat.Mosaic.doReproject" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Mosaic.eResampleAlg">
<tt class="descname">eResampleAlg</tt><em class="property"> = 0</em><a class="headerlink" href="#nansat.Mosaic.eResampleAlg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.latest">
<tt class="descname">latest</tt><big>(</big><em>files=[], bands=[1], doReproject=True, maskName='mask', **kwargs</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.latest" title="Permalink to this definition">¶</a></dt>
<dd><p>Mosaic by adding the latest image on top without averaging</p>
<div class="line-block">
<div class="line">Uses Nansat.get_time() to estimate time of each input file;</div>
<div class="line">Sorts images by aquisition time;</div>
<div class="line">Creates date_index band - with mask of coverage of each frame;</div>
<div class="line">Uses date_index to fill bands of self only with the latest data</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>files</strong> : list</p>
<blockquote>
<div><p>list of input files</p>
</div></blockquote>
<p><strong>bands</strong> : list</p>
<blockquote>
<div><p>list of names/band_numbers to be processed</p>
</div></blockquote>
<p><strong>doReproject</strong> : boolean, [True]</p>
<blockquote>
<div><p>reproject input files?</p>
</div></blockquote>
<p><strong>maskName</strong> : str, [&#8216;mask&#8217;]</p>
<blockquote>
<div><p>name of the mask in input files</p>
</div></blockquote>
<p><strong>nClass</strong> : child of Nansat, [Nansat]</p>
<blockquote>
<div><p>This class is used to read input files</p>
</div></blockquote>
<p><strong>eResampleAlg</strong> : int, [0]</p>
<blockquote>
<div><p>agorithm for reprojection, see Nansat.reproject()</p>
</div></blockquote>
<p><strong>period</strong> : [datetime0, datetime1]</p>
<blockquote class="last">
<div><p>Start and stop datetime objects from pyhon datetime.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="nansat.Mosaic.maskName">
<tt class="descname">maskName</tt><em class="property"> = 'mask'</em><a class="headerlink" href="#nansat.Mosaic.maskName" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nansat.Mosaic.median">
<tt class="descname">median</tt><big>(</big><em>files=[], bands=[1], doReproject=True, maskName='mask', **kwargs</em><big>)</big><a class="headerlink" href="#nansat.Mosaic.median" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate median of input bands</p>
<p>Memory and CPU greedy method. Generates 3D cube from bands of
all input images and calculates median. Adds median bands to self</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>files</strong> : list</p>
<blockquote>
<div><p>list of input files</p>
</div></blockquote>
<p><strong>bands</strong> : list</p>
<blockquote>
<div><p>list of names/band_numbers to be processed</p>
</div></blockquote>
<p><strong>doReproject</strong> : boolean, [True]</p>
<blockquote>
<div><p>reproject input files?</p>
</div></blockquote>
<p><strong>maskName</strong> : str, [&#8216;mask&#8217;]</p>
<blockquote>
<div><p>name of the mask in input files</p>
</div></blockquote>
<p><strong>nClass</strong> : child of Nansat, [Nansat]</p>
<blockquote>
<div><p>This class is used to read input files</p>
</div></blockquote>
<p><strong>eResampleAlg</strong> : int, [0]</p>
<blockquote>
<div><p>agorithm for reprojection, see Nansat.reproject()</p>
</div></blockquote>
<p><strong>period</strong> : [datetime0, datetime1]</p>
<blockquote class="last">
<div><p>Start and stop datetime objects from pyhon datetime.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="nansat.Mosaic.nClass">
<tt class="descname">nClass</tt><a class="headerlink" href="#nansat.Mosaic.nClass" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="nansat.nansat.html#nansat.Nansat" title="nansat.Nansat"><tt class="xref py py-class docutils literal"><span class="pre">Nansat</span></tt></a></p>
</dd></dl>

<dl class="attribute">
<dt id="nansat.Mosaic.period">
<tt class="descname">period</tt><em class="property"> = (None, None)</em><a class="headerlink" href="#nansat.Mosaic.period" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nansat.Mosaic.threads">
<tt class="descname">threads</tt><em class="property"> = 1</em><a class="headerlink" href="#nansat.Mosaic.threads" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>

    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2013, Nansen Center.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.1.
      </li>
    </ul>
    </div>
    </div>
    </div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-43252602-1', 'nansencenter.github.io');
  ga('send', 'pageview');

</script>

  </body>
</html>