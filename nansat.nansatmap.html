<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>nansat.nansatmap module &mdash; Nansat 0.6dev documentation</title>
    
    <link rel="stylesheet" type="text/css" href="_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="_static/css/spc-extend.css">
    <link rel="stylesheet" href="_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.6dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/js/copybutton.js"></script>
    <link rel="top" title="Nansat 0.6dev documentation" href="index.html" > 
  </head>
  <body>

<div class="container">
  <div class="top-scipy-org-logo-header">
    <a href="index.html">
      <img style="border: 0;" alt="SciPy" src="_static/img/nansat_logo.gif"></a>
    </div>
  </div>
</div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
        <li class="active"><a href="https://github.com/nansencenter/nansat/">GitHub</a></li>
	
        <li class="active"><a href="index.html">Nansat 0.6dev documentation</a></li>
	 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <div class="section" id="module-nansat.nansatmap">
<span id="nansat-nansatmap-module"></span><h1>nansat.nansatmap module<a class="headerlink" href="#module-nansat.nansatmap" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="nansat.nansatmap.Nansatmap">
<em class="property">class </em><tt class="descclassname">nansat.nansatmap.</tt><tt class="descname">Nansatmap</tt><big>(</big><em>domain</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Set attributes
Get proj4 from the given domain and convert the proj4 projection to
the basemap projection.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>domain</strong> : domain object</p>
<p><strong>kwargs</strong> : dictionary</p>
<blockquote>
<div><p>parameters that are used for all operations.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.fig</strong> : figure</p>
<blockquote>
<div><p>matplotlib.pyplot.figure</p>
</div></blockquote>
<p><strong>self.colorbar</strong> : boolean</p>
<blockquote>
<div><p>if colorbar is True, it is possible to put colorbar.
e.g. contour_plots(contour_style=&#8217;fill&#8217;), put_color()</p>
</div></blockquote>
<p><strong>self.mpl</strong> : list</p>
<blockquote class="last">
<div><div class="line-block">
<div class="line">elements are :</div>
<div class="line-block">
<div class="line">matplotlib.contour.QuadContourSet instance,</div>
<div class="line">matplotlib.quiver.Quiver instance or</div>
<div class="line">matplotlib.collections.QuadMesh object</div>
</div>
</div>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>See also : <a class="reference external" href="http://matplotlib.org/basemap/api/basemap_api.html">http://matplotlib.org/basemap/api/basemap_api.html</a></p>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="62%" />
<col width="38%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>colorbar</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>convolve_weights</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>lat</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>lon</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>x</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>y</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">__call__</span></tt>(x,&nbsp;y[,&nbsp;inverse])</td>
<td>Calling a Basemap class instance with the arguments lon, lat will convert lon/lat (in degrees) to x/y map projection coordinates (in meters).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.add_colorbar" title="nansat.nansatmap.Nansatmap.add_colorbar"><tt class="xref py py-obj docutils literal"><span class="pre">add_colorbar</span></tt></a>([fontsize])</td>
<td>Add color bar</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.arcgisimage" title="nansat.nansatmap.Nansatmap.arcgisimage"><tt class="xref py py-obj docutils literal"><span class="pre">arcgisimage</span></tt></a>([server,&nbsp;service,&nbsp;xpixels,&nbsp;...])</td>
<td>Retrieve an image using the ArcGIS Server REST API and display it on the map.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.barbs" title="nansat.nansatmap.Nansatmap.barbs"><tt class="xref py py-obj docutils literal"><span class="pre">barbs</span></tt></a>(x,&nbsp;y,&nbsp;u,&nbsp;v,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Make a wind barb plot (u, v) with on the map.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.bluemarble" title="nansat.nansatmap.Nansatmap.bluemarble"><tt class="xref py py-obj docutils literal"><span class="pre">bluemarble</span></tt></a>([ax,&nbsp;scale])</td>
<td>display blue marble image (from <a class="reference external" href="http://visibleearth.nasa.gov">http://visibleearth.nasa.gov</a>)</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">cmap</span></tt></td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.contour" title="nansat.nansatmap.Nansatmap.contour"><tt class="xref py py-obj docutils literal"><span class="pre">contour</span></tt></a>(data[,&nbsp;v,&nbsp;smooth,&nbsp;mode,&nbsp;label])</td>
<td>Draw lined contour plots</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.contourf" title="nansat.nansatmap.Nansatmap.contourf"><tt class="xref py py-obj docutils literal"><span class="pre">contourf</span></tt></a>(data[,&nbsp;v,&nbsp;smooth,&nbsp;mode])</td>
<td>Draw filled contour plots</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.draw_continents" title="nansat.nansatmap.Nansatmap.draw_continents"><tt class="xref py py-obj docutils literal"><span class="pre">draw_continents</span></tt></a>(**kwargs)</td>
<td>Draw continents</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.drawcoastlines" title="nansat.nansatmap.Nansatmap.drawcoastlines"><tt class="xref py py-obj docutils literal"><span class="pre">drawcoastlines</span></tt></a>([linewidth,&nbsp;linestyle,&nbsp;...])</td>
<td>Draw coastlines.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.drawcounties" title="nansat.nansatmap.Nansatmap.drawcounties"><tt class="xref py py-obj docutils literal"><span class="pre">drawcounties</span></tt></a>([linewidth,&nbsp;linestyle,&nbsp;color,&nbsp;...])</td>
<td>Draw county boundaries in US.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.drawcountries" title="nansat.nansatmap.Nansatmap.drawcountries"><tt class="xref py py-obj docutils literal"><span class="pre">drawcountries</span></tt></a>([linewidth,&nbsp;linestyle,&nbsp;color,&nbsp;...])</td>
<td>Draw country boundaries.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.drawgreatcircle" title="nansat.nansatmap.Nansatmap.drawgreatcircle"><tt class="xref py py-obj docutils literal"><span class="pre">drawgreatcircle</span></tt></a>(lon1,&nbsp;lat1,&nbsp;lon2,&nbsp;lat2[,&nbsp;del_s])</td>
<td>Draw a great circle on the map from the longitude-latitude</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.drawgrid" title="nansat.nansatmap.Nansatmap.drawgrid"><tt class="xref py py-obj docutils literal"><span class="pre">drawgrid</span></tt></a>([fontsize,&nbsp;lat_num,&nbsp;lon_num,&nbsp;...])</td>
<td>Draw and label parallels (lat and lon lines) for values (in degrees)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.drawlsmask" title="nansat.nansatmap.Nansatmap.drawlsmask"><tt class="xref py py-obj docutils literal"><span class="pre">drawlsmask</span></tt></a>([land_color,&nbsp;ocean_color,&nbsp;...])</td>
<td>Draw land-sea mask image.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.drawmapboundary" title="nansat.nansatmap.Nansatmap.drawmapboundary"><tt class="xref py py-obj docutils literal"><span class="pre">drawmapboundary</span></tt></a>([color,&nbsp;linewidth,&nbsp;...])</td>
<td>draw boundary around map projection region, optionally</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.drawmapscale" title="nansat.nansatmap.Nansatmap.drawmapscale"><tt class="xref py py-obj docutils literal"><span class="pre">drawmapscale</span></tt></a>(lon,&nbsp;lat,&nbsp;lon0,&nbsp;lat0,&nbsp;length[,&nbsp;...])</td>
<td>Draw a map scale at <tt class="docutils literal"><span class="pre">lon,lat</span></tt> of length <tt class="docutils literal"><span class="pre">length</span></tt> representing distance in the map projection coordinates at <tt class="docutils literal"><span class="pre">lon0,lat0</span></tt>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.drawmeridians" title="nansat.nansatmap.Nansatmap.drawmeridians"><tt class="xref py py-obj docutils literal"><span class="pre">drawmeridians</span></tt></a>(meridians[,&nbsp;color,&nbsp;linewidth,&nbsp;...])</td>
<td>Draw and label meridians (longitude lines) for values (in degrees) given in the sequence <tt class="docutils literal"><span class="pre">meridians</span></tt>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.drawparallels" title="nansat.nansatmap.Nansatmap.drawparallels"><tt class="xref py py-obj docutils literal"><span class="pre">drawparallels</span></tt></a>(circles[,&nbsp;color,&nbsp;linewidth,&nbsp;...])</td>
<td>Draw and label parallels (latitude lines) for values (in degrees) given in the sequence <tt class="docutils literal"><span class="pre">circles</span></tt>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.drawrivers" title="nansat.nansatmap.Nansatmap.drawrivers"><tt class="xref py py-obj docutils literal"><span class="pre">drawrivers</span></tt></a>([linewidth,&nbsp;linestyle,&nbsp;color,&nbsp;...])</td>
<td>Draw major rivers.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.drawstates" title="nansat.nansatmap.Nansatmap.drawstates"><tt class="xref py py-obj docutils literal"><span class="pre">drawstates</span></tt></a>([linewidth,&nbsp;linestyle,&nbsp;color,&nbsp;...])</td>
<td>Draw state boundaries in Americas.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.etopo" title="nansat.nansatmap.Nansatmap.etopo"><tt class="xref py py-obj docutils literal"><span class="pre">etopo</span></tt></a>([ax,&nbsp;scale])</td>
<td>display etopo relief image (from</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.fillcontinents" title="nansat.nansatmap.Nansatmap.fillcontinents"><tt class="xref py py-obj docutils literal"><span class="pre">fillcontinents</span></tt></a>([color,&nbsp;lake_color,&nbsp;ax,&nbsp;...])</td>
<td>Fill continents.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.gcpoints" title="nansat.nansatmap.Nansatmap.gcpoints"><tt class="xref py py-obj docutils literal"><span class="pre">gcpoints</span></tt></a>(lon1,&nbsp;lat1,&nbsp;lon2,&nbsp;lat2,&nbsp;npoints)</td>
<td>compute <tt class="docutils literal"><span class="pre">points</span></tt> points along a great circle with endpoints</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.hexbin" title="nansat.nansatmap.Nansatmap.hexbin"><tt class="xref py py-obj docutils literal"><span class="pre">hexbin</span></tt></a>(x,&nbsp;y,&nbsp;**kwargs)</td>
<td>Make a hexagonal binning plot of x versus y, where x, y are 1-D sequences of the same length, N.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.imshow" title="nansat.nansatmap.Nansatmap.imshow"><tt class="xref py py-obj docutils literal"><span class="pre">imshow</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>Display an image over the map (see matplotlib.pyplot.imshow documentation).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.is_land" title="nansat.nansatmap.Nansatmap.is_land"><tt class="xref py py-obj docutils literal"><span class="pre">is_land</span></tt></a>(xpt,&nbsp;ypt)</td>
<td>Returns True if the given x,y point (in projection coordinates) is over land, False otherwise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.makegrid" title="nansat.nansatmap.Nansatmap.makegrid"><tt class="xref py py-obj docutils literal"><span class="pre">makegrid</span></tt></a>(nx,&nbsp;ny[,&nbsp;returnxy])</td>
<td>return arrays of shape (ny,nx) containing lon,lat coordinates of</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.nightshade" title="nansat.nansatmap.Nansatmap.nightshade"><tt class="xref py py-obj docutils literal"><span class="pre">nightshade</span></tt></a>(date[,&nbsp;color,&nbsp;delta,&nbsp;alpha,&nbsp;ax,&nbsp;...])</td>
<td>Shade the regions of the map that are in darkness at the time specifed by <tt class="docutils literal"><span class="pre">date</span></tt>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.pcolor" title="nansat.nansatmap.Nansatmap.pcolor"><tt class="xref py py-obj docutils literal"><span class="pre">pcolor</span></tt></a>(x,&nbsp;y,&nbsp;data,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Make a pseudo-color plot over the map (see matplotlib.pyplot.pcolor documentation).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.pcolormesh" title="nansat.nansatmap.Nansatmap.pcolormesh"><tt class="xref py py-obj docutils literal"><span class="pre">pcolormesh</span></tt></a>(data,&nbsp;**kwargs)</td>
<td>Make a pseudo-color plot over the map</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.plot" title="nansat.nansatmap.Nansatmap.plot"><tt class="xref py py-obj docutils literal"><span class="pre">plot</span></tt></a>(x,&nbsp;y,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Draw lines and/or markers on the map (see matplotlib.pyplot.plot documentation).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.quiver" title="nansat.nansatmap.Nansatmap.quiver"><tt class="xref py py-obj docutils literal"><span class="pre">quiver</span></tt></a>(dataX,&nbsp;dataY[,&nbsp;step,&nbsp;quivectors])</td>
<td>Draw quiver plots</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.readshapefile" title="nansat.nansatmap.Nansatmap.readshapefile"><tt class="xref py py-obj docutils literal"><span class="pre">readshapefile</span></tt></a>(shapefile,&nbsp;name[,&nbsp;drawbounds,&nbsp;...])</td>
<td>Read in shape file, optionally draw boundaries on map.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.rotate_vector" title="nansat.nansatmap.Nansatmap.rotate_vector"><tt class="xref py py-obj docutils literal"><span class="pre">rotate_vector</span></tt></a>(uin,&nbsp;vin,&nbsp;lons,&nbsp;lats[,&nbsp;returnxy])</td>
<td>Rotate a vector field (<tt class="docutils literal"><span class="pre">uin,vin</span></tt>) on a rectilinear grid with longitudes = <tt class="docutils literal"><span class="pre">lons</span></tt> and latitudes = <tt class="docutils literal"><span class="pre">lats</span></tt> from geographical (lat/lon) into map projection (x/y) coordinates.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.save" title="nansat.nansatmap.Nansatmap.save"><tt class="xref py py-obj docutils literal"><span class="pre">save</span></tt></a>(fileName[,&nbsp;landmask])</td>
<td>Draw continents and save</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.scatter" title="nansat.nansatmap.Nansatmap.scatter"><tt class="xref py py-obj docutils literal"><span class="pre">scatter</span></tt></a>(x,&nbsp;y,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Plot points with markers on the map (see matplotlib.pyplot.scatter documentation).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.set_axes_limits" title="nansat.nansatmap.Nansatmap.set_axes_limits"><tt class="xref py py-obj docutils literal"><span class="pre">set_axes_limits</span></tt></a>([ax])</td>
<td>Final step in Basemap method wrappers of Axes plotting methods:</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.shadedrelief" title="nansat.nansatmap.Nansatmap.shadedrelief"><tt class="xref py py-obj docutils literal"><span class="pre">shadedrelief</span></tt></a>([ax,&nbsp;scale])</td>
<td>display shaded relief image (from <a class="reference external" href="http://www.shadedrelief.com">http://www.shadedrelief.com</a>)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.shiftdata" title="nansat.nansatmap.Nansatmap.shiftdata"><tt class="xref py py-obj docutils literal"><span class="pre">shiftdata</span></tt></a>(lonsin[,&nbsp;datain,&nbsp;lon_0])</td>
<td>Shift longitudes (and optionally data) so that they match map projection region.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.smooth" title="nansat.nansatmap.Nansatmap.smooth"><tt class="xref py py-obj docutils literal"><span class="pre">smooth</span></tt></a>(idata,&nbsp;mode,&nbsp;**kwargs)</td>
<td>Smooth data for contour() and contourf()</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.streamplot" title="nansat.nansatmap.Nansatmap.streamplot"><tt class="xref py py-obj docutils literal"><span class="pre">streamplot</span></tt></a>(x,&nbsp;y,&nbsp;u,&nbsp;v,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Draws streamlines of a vector flow.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.tissot" title="nansat.nansatmap.Nansatmap.tissot"><tt class="xref py py-obj docutils literal"><span class="pre">tissot</span></tt></a>(lon_0,&nbsp;lat_0,&nbsp;radius_deg,&nbsp;npts[,&nbsp;ax])</td>
<td>Draw a polygon centered at <tt class="docutils literal"><span class="pre">lon_0,lat_0</span></tt>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.transform_scalar" title="nansat.nansatmap.Nansatmap.transform_scalar"><tt class="xref py py-obj docutils literal"><span class="pre">transform_scalar</span></tt></a>(datin,&nbsp;lons,&nbsp;lats,&nbsp;nx,&nbsp;ny)</td>
<td>Interpolate a scalar field (<tt class="docutils literal"><span class="pre">datin</span></tt>) from a lat/lon grid with longitudes = <tt class="docutils literal"><span class="pre">lons</span></tt> and latitudes = <tt class="docutils literal"><span class="pre">lats</span></tt> to a <tt class="docutils literal"><span class="pre">ny</span></tt> by <tt class="docutils literal"><span class="pre">nx</span></tt> map projection grid.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.transform_vector" title="nansat.nansatmap.Nansatmap.transform_vector"><tt class="xref py py-obj docutils literal"><span class="pre">transform_vector</span></tt></a>(uin,&nbsp;vin,&nbsp;lons,&nbsp;lats,&nbsp;nx,&nbsp;ny)</td>
<td>Rotate and interpolate a vector field (<tt class="docutils literal"><span class="pre">uin,vin</span></tt>) from a lat/lon grid with longitudes = <tt class="docutils literal"><span class="pre">lons</span></tt> and latitudes = <tt class="docutils literal"><span class="pre">lats</span></tt> to a <tt class="docutils literal"><span class="pre">ny</span></tt> by <tt class="docutils literal"><span class="pre">nx</span></tt> map projection grid.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.warpimage" title="nansat.nansatmap.Nansatmap.warpimage"><tt class="xref py py-obj docutils literal"><span class="pre">warpimage</span></tt></a>([image,&nbsp;scale])</td>
<td>Display an image (filename given by <tt class="docutils literal"><span class="pre">image</span></tt> keyword) as a map background.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nansat.nansatmap.Nansatmap.wmsimage" title="nansat.nansatmap.Nansatmap.wmsimage"><tt class="xref py py-obj docutils literal"><span class="pre">wmsimage</span></tt></a>(server[,&nbsp;xpixels,&nbsp;ypixels,&nbsp;format,&nbsp;...])</td>
<td>Retrieve an image using from a WMS server using the Open Geospatial Consortium (OGC) standard interface and display on the map.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.add_colorbar">
<tt class="descname">add_colorbar</tt><big>(</big><em>fontsize=6</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.add_colorbar" title="Permalink to this definition">¶</a></dt>
<dd><p>Add color bar</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fontsize</strong> : int</p>
<p><strong>Parameters for matplotlib.pyplot.colorbar</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first last"><strong>Adds colorbar to self.fig</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.arcgisimage">
<tt class="descname">arcgisimage</tt><big>(</big><em>server='http://server.arcgisonline.com/ArcGIS'</em>, <em>service='ESRI_Imagery_World_2D'</em>, <em>xpixels=400</em>, <em>ypixels=None</em>, <em>dpi=96</em>, <em>verbose=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.arcgisimage" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve an image using the ArcGIS Server REST API and display it on
the map. In order to use this method, the Basemap instance must be
created using the <tt class="docutils literal"><span class="pre">epsg</span></tt> keyword to define the map projection, unless
the <tt class="docutils literal"><span class="pre">cyl</span></tt> projection is used (in which case the epsg code 4326 is
assumed).</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keywords</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>server</td>
<td>web map server URL (default
<a class="reference external" href="http://server.arcgisonline.com/ArcGIS">http://server.arcgisonline.com/ArcGIS</a>).</td>
</tr>
<tr class="row-odd"><td>service</td>
<td>service (image type) hosted on server (default
ESRI_Imagery_World_2D, which is NASA &#8216;Blue Marble&#8217;
image).</td>
</tr>
<tr class="row-even"><td>xpixels</td>
<td>requested number of image pixels in x-direction
(default 400).</td>
</tr>
<tr class="row-odd"><td>ypixels</td>
<td>requested number of image pixels in y-direction.
Default (None) is to infer the number from
from xpixels and the aspect ratio of the
map projection region.</td>
</tr>
<tr class="row-even"><td>dpi</td>
<td>The device resolution of the exported image (dots per
inch, default 96).</td>
</tr>
<tr class="row-odd"><td>verbose</td>
<td>if True, print URL used to retrieve image (default
False).</td>
</tr>
</tbody>
</table>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>returns a matplotlib.image.AxesImage instance.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.barbs">
<tt class="descname">barbs</tt><big>(</big><em>x</em>, <em>y</em>, <em>u</em>, <em>v</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.barbs" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a wind barb plot (u, v) with on the map.
(see matplotlib.pyplot.barbs documentation).</p>
<p>If <tt class="docutils literal"><span class="pre">latlon</span></tt> keyword is set to True, x,y are intrepreted as
longitude and latitude in degrees.  Data and longitudes are
automatically shifted to match map projection region for cylindrical
and pseudocylindrical projections, and x,y are transformed to map
projection coordinates. If <tt class="docutils literal"><span class="pre">latlon</span></tt> is False (default), x and y
are assumed to be map projection coordinates.</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>Other *args and **kwargs passed on to matplotlib.pyplot.barbs</p>
<p>Returns two matplotlib.axes.Barbs instances, one for the Northern
Hemisphere and one for the Southern Hemisphere.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.bluemarble">
<tt class="descname">bluemarble</tt><big>(</big><em>ax=None</em>, <em>scale=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.bluemarble" title="Permalink to this definition">¶</a></dt>
<dd><p>display blue marble image (from <a class="reference external" href="http://visibleearth.nasa.gov">http://visibleearth.nasa.gov</a>)
as map background.
Default image size is 5400x2700, which can be quite slow and
use quite a bit of memory.  The <tt class="docutils literal"><span class="pre">scale</span></tt> keyword can be used
to downsample the image (<tt class="docutils literal"><span class="pre">scale=0.5</span></tt> downsamples to 2700x1350).</p>
<p>**kwargs passed on to <a class="reference internal" href="#nansat.nansatmap.Nansatmap.imshow" title="nansat.nansatmap.Nansatmap.imshow"><tt class="xref py py-meth docutils literal"><span class="pre">imshow()</span></tt></a>.</p>
<p>returns a matplotlib.image.AxesImage instance.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.contour">
<tt class="descname">contour</tt><big>(</big><em>data</em>, <em>v=None</em>, <em>smooth=False</em>, <em>mode='gaussian'</em>, <em>label=True</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.contour" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw lined contour plots</p>
<p>If smooth is True, data is smoothed. Then draw lined contour.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : numpy 2D array</p>
<blockquote>
<div><p>Input data</p>
</div></blockquote>
<p><strong>v</strong> : list with values</p>
<blockquote>
<div><p>draw contour lines at the values specified in sequence v</p>
</div></blockquote>
<p><strong>smooth</strong> : Boolean</p>
<blockquote>
<div><p>Apply smoothing?</p>
</div></blockquote>
<p><strong>mode</strong> : string</p>
<blockquote>
<div><p>&#8216;gaussian&#8217;, &#8216;spline&#8217;, &#8216;fourier&#8217;, &#8216;convolve&#8217;
mname of smoothing algorithm to apply</p>
</div></blockquote>
<p><strong>label</strong> : boolean</p>
<blockquote>
<div><p>Add lables?</p>
</div></blockquote>
<p><strong>**kwargs: dictionary</strong></p>
<blockquote>
<div><div class="line-block">
<div class="line">Optional parameters for Nansatmap.smooth()</div>
<div class="line">Optional parameters for pyplot.contour().</div>
<div class="line">Optional parameters for pyplot.clabel()</div>
</div>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.mpl</strong> : list</p>
<blockquote class="last">
<div><p>append QuadContourSet instance</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.contourf">
<tt class="descname">contourf</tt><big>(</big><em>data</em>, <em>v=None</em>, <em>smooth=False</em>, <em>mode='gaussian'</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.contourf" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw filled contour plots</p>
<p>If smooth is True, data is smoothed. Then draw filled contour.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : numpy 2D array</p>
<blockquote>
<div><p>Input data</p>
</div></blockquote>
<p><strong>v</strong> : list with values</p>
<blockquote>
<div><p>draw contour lines at the values specified in sequence v</p>
</div></blockquote>
<p><strong>smooth</strong> : Boolean</p>
<blockquote>
<div><p>Apply smoothing?</p>
</div></blockquote>
<p><strong>mode</strong> : string</p>
<blockquote>
<div><div class="line-block">
<div class="line">mname of smoothing algorithm to apply</div>
<div class="line">e.g.) &#8216;gaussian&#8217;, &#8216;spline&#8217;, &#8216;fourier&#8217;, &#8216;convolve&#8217;</div>
</div>
</div></blockquote>
<p><strong>**kwargs: dictionary</strong></p>
<blockquote>
<div><div class="line-block">
<div class="line">cmap : colormap (e.g. cm.jet)</div>
<div class="line">Optional parameters for Nansatmap.smooth()</div>
<div class="line">Optional parameters for pyplot.contourf().</div>
</div>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.mpl</strong> : list</p>
<blockquote class="last">
<div><p>append QuadContourSet instance</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.draw_continents">
<tt class="descname">draw_continents</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.draw_continents" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw continents</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>**kwargs</strong> : dictionary</p>
<blockquote class="last">
<div><p>Parameters for basemap.fillcontinents</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.drawcoastlines">
<tt class="descname">drawcoastlines</tt><big>(</big><em>linewidth=1.0</em>, <em>linestyle='solid'</em>, <em>color='k'</em>, <em>antialiased=1</em>, <em>ax=None</em>, <em>zorder=None</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.drawcoastlines" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw coastlines.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>linewidth</td>
<td>coastline width (default 1.)</td>
</tr>
<tr class="row-odd"><td>linestyle</td>
<td>coastline linestyle (default solid)</td>
</tr>
<tr class="row-even"><td>color</td>
<td>coastline color (default black)</td>
</tr>
<tr class="row-odd"><td>antialiased</td>
<td>antialiasing switch for coastlines (default True).</td>
</tr>
<tr class="row-even"><td>ax</td>
<td>axes instance (overrides default axes instance)</td>
</tr>
<tr class="row-odd"><td>zorder</td>
<td>sets the zorder for the coastlines (if not specified,
uses default zorder for
matplotlib.patches.LineCollections).</td>
</tr>
</tbody>
</table>
<p>returns a matplotlib.patches.LineCollection object.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.drawcounties">
<tt class="descname">drawcounties</tt><big>(</big><em>linewidth=0.1</em>, <em>linestyle='solid'</em>, <em>color='k'</em>, <em>antialiased=1</em>, <em>ax=None</em>, <em>zorder=None</em>, <em>drawbounds=False</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.drawcounties" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw county boundaries in US. The county boundary shapefile
originates with the NOAA Coastal Geospatial Data Project
(<a class="reference external" href="http://coastalgeospatial.noaa.gov/data_gis.html">http://coastalgeospatial.noaa.gov/data_gis.html</a>).</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>linewidth</td>
<td>county boundary line width (default 0.1)</td>
</tr>
<tr class="row-odd"><td>linestyle</td>
<td>coastline linestyle (default solid)</td>
</tr>
<tr class="row-even"><td>color</td>
<td>county boundary line color (default black)</td>
</tr>
<tr class="row-odd"><td>antialiased</td>
<td>antialiasing switch for county boundaries
(default True).</td>
</tr>
<tr class="row-even"><td>ax</td>
<td>axes instance (overrides default axes instance)</td>
</tr>
<tr class="row-odd"><td>zorder</td>
<td>sets the zorder for the county boundaries (if not
specified, uses default zorder for
matplotlib.patches.LineCollections).</td>
</tr>
</tbody>
</table>
<p>returns a matplotlib.patches.LineCollection object.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.drawcountries">
<tt class="descname">drawcountries</tt><big>(</big><em>linewidth=0.5</em>, <em>linestyle='solid'</em>, <em>color='k'</em>, <em>antialiased=1</em>, <em>ax=None</em>, <em>zorder=None</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.drawcountries" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw country boundaries.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>linewidth</td>
<td>country boundary line width (default 0.5)</td>
</tr>
<tr class="row-odd"><td>linestyle</td>
<td>coastline linestyle (default solid)</td>
</tr>
<tr class="row-even"><td>color</td>
<td>country boundary line color (default black)</td>
</tr>
<tr class="row-odd"><td>antialiased</td>
<td>antialiasing switch for country boundaries (default
True).</td>
</tr>
<tr class="row-even"><td>ax</td>
<td>axes instance (overrides default axes instance)</td>
</tr>
<tr class="row-odd"><td>zorder</td>
<td>sets the zorder for the country boundaries (if not
specified uses default zorder for
matplotlib.patches.LineCollections).</td>
</tr>
</tbody>
</table>
<p>returns a matplotlib.patches.LineCollection object.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.drawgreatcircle">
<tt class="descname">drawgreatcircle</tt><big>(</big><em>lon1</em>, <em>lat1</em>, <em>lon2</em>, <em>lat2</em>, <em>del_s=100.0</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.drawgreatcircle" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a great circle on the map from the longitude-latitude
pair <tt class="docutils literal"><span class="pre">lon1,lat1</span></tt> to <tt class="docutils literal"><span class="pre">lon2,lat2</span></tt></p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>del_s</td>
<td>points on great circle computed every del_s kilometers
(default 100).</td>
</tr>
<tr class="row-odd"><td>**kwargs</td>
<td>other keyword arguments are passed on to <a class="reference internal" href="#nansat.nansatmap.Nansatmap.plot" title="nansat.nansatmap.Nansatmap.plot"><tt class="xref py py-meth docutils literal"><span class="pre">plot()</span></tt></a>
method of Basemap instance.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Cannot handle situations in which the great circle intersects
the edge of the map projection domain, and then re-enters the domain.</p>
</div>
<p>Returns a matplotlib.lines.Line2D object.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.drawgrid">
<tt class="descname">drawgrid</tt><big>(</big><em>fontsize=10, lat_num=5, lon_num=5, lat_labels=[True, False, False, False], lon_labels=[False, False, True, False]</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.drawgrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw and label parallels (lat and lon lines) for values (in degrees)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fontsize</strong> : int</p>
<p><strong>lat_num</strong> : int</p>
<blockquote>
<div><p>Number of latitude lables</p>
</div></blockquote>
<p><strong>lon_num :</strong></p>
<blockquote>
<div><p>Number of longitude lables</p>
</div></blockquote>
<p><strong>lat_labels</strong> : list of Bool</p>
<blockquote>
<div><p>Location of latitude labels</p>
</div></blockquote>
<p><strong>lon_labels</strong> : list of Bool</p>
<blockquote class="last">
<div><p>Location of longitude labels</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>See also: Basemap.drawparallels(), Basemap.drawmeridians()</p>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.drawlsmask">
<tt class="descname">drawlsmask</tt><big>(</big><em>land_color='0.8'</em>, <em>ocean_color='w'</em>, <em>lsmask=None</em>, <em>lsmask_lons=None</em>, <em>lsmask_lats=None</em>, <em>lakes=True</em>, <em>resolution='l'</em>, <em>grid=5</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.drawlsmask" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw land-sea mask image.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The land-sea mask image cannot be overlaid on top
of other images, due to limitations in matplotlib image handling
(you can&#8217;t specify the zorder of an image).</p>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keywords</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>land_color</td>
<td>desired land color (color name or rgba tuple).
Default gray (&#8220;0.8&#8221;).</td>
</tr>
<tr class="row-odd"><td>ocean_color</td>
<td>desired water color (color name or rgba tuple).
Default white.</td>
</tr>
<tr class="row-even"><td>lsmask</td>
<td>An array of 0&#8217;s for ocean pixels, 1&#8217;s for
land pixels and 2&#8217;s for lake/pond pixels.
Default is None
(default 5-minute resolution land-sea mask is used).</td>
</tr>
<tr class="row-odd"><td>lakes</td>
<td>Plot lakes and ponds (Default True)</td>
</tr>
<tr class="row-even"><td>lsmask_lons</td>
<td>1d array of longitudes for lsmask (ignored
if lsmask is None). Longitudes must be ordered
from -180 W eastward.</td>
</tr>
<tr class="row-odd"><td>lsmask_lats</td>
<td>1d array of latitudes for lsmask (ignored
if lsmask is None). Latitudes must be ordered
from -90 S northward.</td>
</tr>
<tr class="row-even"><td>resolution</td>
<td>gshhs coastline resolution used to define land/sea
mask (default &#8216;l&#8217;, available &#8216;c&#8217;,&#8217;l&#8217;,&#8217;i&#8217;,&#8217;h&#8217; or &#8216;f&#8217;)</td>
</tr>
<tr class="row-odd"><td>grid</td>
<td>land/sea mask grid spacing in minutes (Default 5;
10, 2.5 and 1.25 are also available).</td>
</tr>
<tr class="row-even"><td>**kwargs</td>
<td>extra keyword arguments passed on to
<a class="reference internal" href="#nansat.nansatmap.Nansatmap.imshow" title="nansat.nansatmap.Nansatmap.imshow"><tt class="xref py py-meth docutils literal"><span class="pre">imshow()</span></tt></a></td>
</tr>
</tbody>
</table>
<p>If any of the lsmask, lsmask_lons or lsmask_lats keywords are not
set, the built in GSHHS land-sea mask datasets are used.</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>returns a matplotlib.image.AxesImage instance.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.drawmapboundary">
<tt class="descname">drawmapboundary</tt><big>(</big><em>color='k'</em>, <em>linewidth=1.0</em>, <em>fill_color=None</em>, <em>zorder=None</em>, <em>ax=None</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.drawmapboundary" title="Permalink to this definition">¶</a></dt>
<dd><p>draw boundary around map projection region, optionally
filling interior of region.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>linewidth</td>
<td>line width for boundary (default 1.)</td>
</tr>
<tr class="row-odd"><td>color</td>
<td>color of boundary line (default black)</td>
</tr>
<tr class="row-even"><td>fill_color</td>
<td>fill the map region background with this
color (default is to fill with axis
background color). If set to the string
&#8216;none&#8217;, no filling is done.</td>
</tr>
<tr class="row-odd"><td>zorder</td>
<td>sets the zorder for filling map background
(default 0).</td>
</tr>
<tr class="row-even"><td>ax</td>
<td>axes instance to use
(default None, use default axes instance).</td>
</tr>
</tbody>
</table>
<p>returns matplotlib.collections.PatchCollection representing map boundary.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.drawmapscale">
<tt class="descname">drawmapscale</tt><big>(</big><em>lon</em>, <em>lat</em>, <em>lon0</em>, <em>lat0</em>, <em>length</em>, <em>barstyle='simple'</em>, <em>units='km'</em>, <em>fontsize=9</em>, <em>yoffset=None</em>, <em>labelstyle='simple'</em>, <em>fontcolor='k'</em>, <em>fillcolor1='w'</em>, <em>fillcolor2='k'</em>, <em>ax=None</em>, <em>format='%d'</em>, <em>zorder=None</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.drawmapscale" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a map scale at <tt class="docutils literal"><span class="pre">lon,lat</span></tt> of length <tt class="docutils literal"><span class="pre">length</span></tt>
representing distance in the map
projection coordinates at <tt class="docutils literal"><span class="pre">lon0,lat0</span></tt>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keywords</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>units</td>
<td>the units of the length argument (Default km).</td>
</tr>
<tr class="row-odd"><td>barstyle</td>
<td><tt class="docutils literal"><span class="pre">simple</span></tt> or <tt class="docutils literal"><span class="pre">fancy</span></tt> (roughly corresponding
to the styles provided by Generic Mapping Tools).
Default <tt class="docutils literal"><span class="pre">simple</span></tt>.</td>
</tr>
<tr class="row-even"><td>fontsize</td>
<td>for map scale annotations, default 9.</td>
</tr>
<tr class="row-odd"><td>color</td>
<td>for map scale annotations, default black.</td>
</tr>
<tr class="row-even"><td>labelstype</td>
<td><tt class="docutils literal"><span class="pre">simple</span></tt> (default) or <tt class="docutils literal"><span class="pre">fancy</span></tt>.  For
<tt class="docutils literal"><span class="pre">fancy</span></tt> the map scale factor (ratio betwee
the actual distance and map projection distance
at lon0,lat0) and the value of lon0,lat0 are also
displayed on the top of the scale bar. For
<tt class="docutils literal"><span class="pre">simple</span></tt>, just the units are display on top
and the distance below the scale bar.
If equal to False, plot an empty label.</td>
</tr>
<tr class="row-odd"><td>format</td>
<td>a string formatter to format numeric values</td>
</tr>
<tr class="row-even"><td>yoffset</td>
<td>yoffset controls how tall the scale bar is,
and how far the annotations are offset from the
scale bar.  Default is 0.02 times the height of
the map (0.02*(self.ymax-self.ymin)).</td>
</tr>
<tr class="row-odd"><td>fillcolor1(2)</td>
<td>colors of the alternating filled regions
(default white and black).  Only relevant for
&#8216;fancy&#8217; barstyle.</td>
</tr>
<tr class="row-even"><td>zorder</td>
<td>sets the zorder for the map scale.</td>
</tr>
</tbody>
</table>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.drawmeridians">
<tt class="descname">drawmeridians</tt><big>(</big><em>meridians, color='k', linewidth=1.0, zorder=None, dashes=[1, 1], labels=[0, 0, 0, 0], labelstyle=None, fmt='%g', xoffset=None, yoffset=None, ax=None, latmax=None, **kwargs</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.drawmeridians" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw and label meridians (longitude lines) for values (in degrees)
given in the sequence <tt class="docutils literal"><span class="pre">meridians</span></tt>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>color</td>
<td>color to draw meridians (default black).</td>
</tr>
<tr class="row-odd"><td>linewidth</td>
<td>line width for meridians (default 1.)</td>
</tr>
<tr class="row-even"><td>zorder</td>
<td>sets the zorder for meridians (if not specified,
uses default zorder for matplotlib.lines.Line2D
objects).</td>
</tr>
<tr class="row-odd"><td>dashes</td>
<td>dash pattern for meridians (default [1,1], i.e.
1 pixel on, 1 pixel off).</td>
</tr>
<tr class="row-even"><td>labels</td>
<td>list of 4 values (default [0,0,0,0]) that control
whether meridians are labelled where they intersect
the left, right, top or bottom of the plot. For
example labels=[1,0,0,1] will cause meridians
to be labelled where they intersect the left and
and bottom of the plot, but not the right and top.</td>
</tr>
<tr class="row-odd"><td>labelstyle</td>
<td>if set to &#8220;+/-&#8221;, east and west longitudes are
labelled with &#8220;+&#8221; and &#8220;-&#8221;, otherwise they are
labelled with &#8220;E&#8221; and &#8220;W&#8221;.</td>
</tr>
<tr class="row-even"><td>fmt</td>
<td>a format string to format the meridian labels
(default &#8216;%g&#8217;) <strong>or</strong> a function that takes a
longitude value in degrees as it&#8217;s only argument
and returns a formatted string.</td>
</tr>
<tr class="row-odd"><td>xoffset</td>
<td>label offset from edge of map in x-direction
(default is 0.01 times width of map in map
projection coordinates).</td>
</tr>
<tr class="row-even"><td>yoffset</td>
<td>label offset from edge of map in y-direction
(default is 0.01 times height of map in map
projection coordinates).</td>
</tr>
<tr class="row-odd"><td>ax</td>
<td>axes instance (overrides default axes instance)</td>
</tr>
<tr class="row-even"><td>latmax</td>
<td>absolute value of latitude to which meridians are drawn
(default is 80).</td>
</tr>
<tr class="row-odd"><td>**kwargs</td>
<td>additional keyword arguments controlling text
for labels that are passed on to
the text method of the axes instance (see
matplotlib.pyplot.text documentation).</td>
</tr>
</tbody>
</table>
<p>returns a dictionary whose keys are the meridian values, and
whose values are tuples containing lists of the
matplotlib.lines.Line2D and matplotlib.text.Text instances
associated with each meridian. Deleting an item from the
dictionary removes the correpsonding meridian from the plot.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.drawparallels">
<tt class="descname">drawparallels</tt><big>(</big><em>circles, color='k', linewidth=1.0, zorder=None, dashes=[1, 1], labels=[0, 0, 0, 0], labelstyle=None, fmt='%g', xoffset=None, yoffset=None, ax=None, latmax=None, **kwargs</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.drawparallels" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw and label parallels (latitude lines) for values (in degrees)
given in the sequence <tt class="docutils literal"><span class="pre">circles</span></tt>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>color</td>
<td>color to draw parallels (default black).</td>
</tr>
<tr class="row-odd"><td>linewidth</td>
<td>line width for parallels (default 1.)</td>
</tr>
<tr class="row-even"><td>zorder</td>
<td>sets the zorder for parallels (if not specified,
uses default zorder for matplotlib.lines.Line2D
objects).</td>
</tr>
<tr class="row-odd"><td>dashes</td>
<td>dash pattern for parallels (default [1,1], i.e.
1 pixel on, 1 pixel off).</td>
</tr>
<tr class="row-even"><td>labels</td>
<td>list of 4 values (default [0,0,0,0]) that control
whether parallels are labelled where they intersect
the left, right, top or bottom of the plot. For
example labels=[1,0,0,1] will cause parallels
to be labelled where they intersect the left and
and bottom of the plot, but not the right and top.</td>
</tr>
<tr class="row-odd"><td>labelstyle</td>
<td>if set to &#8220;+/-&#8221;, north and south latitudes are
labelled with &#8220;+&#8221; and &#8220;-&#8221;, otherwise they are
labelled with &#8220;N&#8221; and &#8220;S&#8221;.</td>
</tr>
<tr class="row-even"><td>fmt</td>
<td>a format string to format the parallel labels
(default &#8216;%g&#8217;) <strong>or</strong> a function that takes a
latitude value in degrees as it&#8217;s only argument
and returns a formatted string.</td>
</tr>
<tr class="row-odd"><td>xoffset</td>
<td>label offset from edge of map in x-direction
(default is 0.01 times width of map in map
projection coordinates).</td>
</tr>
<tr class="row-even"><td>yoffset</td>
<td>label offset from edge of map in y-direction
(default is 0.01 times height of map in map
projection coordinates).</td>
</tr>
<tr class="row-odd"><td>ax</td>
<td>axes instance (overrides default axes instance)</td>
</tr>
<tr class="row-even"><td>latmax</td>
<td>absolute value of latitude to which meridians are drawn
(default is 80).</td>
</tr>
<tr class="row-odd"><td>**kwargs</td>
<td>additional keyword arguments controlling text
for labels that are passed on to
the text method of the axes instance (see
matplotlib.pyplot.text documentation).</td>
</tr>
</tbody>
</table>
<p>returns a dictionary whose keys are the parallel values, and
whose values are tuples containing lists of the
matplotlib.lines.Line2D and matplotlib.text.Text instances
associated with each parallel. Deleting an item from the
dictionary removes the corresponding parallel from the plot.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.drawrivers">
<tt class="descname">drawrivers</tt><big>(</big><em>linewidth=0.5</em>, <em>linestyle='solid'</em>, <em>color='k'</em>, <em>antialiased=1</em>, <em>ax=None</em>, <em>zorder=None</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.drawrivers" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw major rivers.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>linewidth</td>
<td>river boundary line width (default 0.5)</td>
</tr>
<tr class="row-odd"><td>linestyle</td>
<td>coastline linestyle (default solid)</td>
</tr>
<tr class="row-even"><td>color</td>
<td>river boundary line color (default black)</td>
</tr>
<tr class="row-odd"><td>antialiased</td>
<td>antialiasing switch for river boundaries (default
True).</td>
</tr>
<tr class="row-even"><td>ax</td>
<td>axes instance (overrides default axes instance)</td>
</tr>
<tr class="row-odd"><td>zorder</td>
<td>sets the zorder for the rivers (if not
specified uses default zorder for
matplotlib.patches.LineCollections).</td>
</tr>
</tbody>
</table>
<p>returns a matplotlib.patches.LineCollection object.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.drawstates">
<tt class="descname">drawstates</tt><big>(</big><em>linewidth=0.5</em>, <em>linestyle='solid'</em>, <em>color='k'</em>, <em>antialiased=1</em>, <em>ax=None</em>, <em>zorder=None</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.drawstates" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw state boundaries in Americas.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>linewidth</td>
<td>state boundary line width (default 0.5)</td>
</tr>
<tr class="row-odd"><td>linestyle</td>
<td>coastline linestyle (default solid)</td>
</tr>
<tr class="row-even"><td>color</td>
<td>state boundary line color (default black)</td>
</tr>
<tr class="row-odd"><td>antialiased</td>
<td>antialiasing switch for state boundaries
(default True).</td>
</tr>
<tr class="row-even"><td>ax</td>
<td>axes instance (overrides default axes instance)</td>
</tr>
<tr class="row-odd"><td>zorder</td>
<td>sets the zorder for the state boundaries (if not
specified, uses default zorder for
matplotlib.patches.LineCollections).</td>
</tr>
</tbody>
</table>
<p>returns a matplotlib.patches.LineCollection object.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.etopo">
<tt class="descname">etopo</tt><big>(</big><em>ax=None</em>, <em>scale=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.etopo" title="Permalink to this definition">¶</a></dt>
<dd><p>display etopo relief image (from
<a class="reference external" href="http://www.ngdc.noaa.gov/mgg/global/global.html">http://www.ngdc.noaa.gov/mgg/global/global.html</a>)
as map background.
Default image size is 5400x2700, which can be quite slow and
use quite a bit of memory.  The <tt class="docutils literal"><span class="pre">scale</span></tt> keyword can be used
to downsample the image (<tt class="docutils literal"><span class="pre">scale=0.5</span></tt> downsamples to 5400x2700).</p>
<p>**kwargs passed on to <a class="reference internal" href="#nansat.nansatmap.Nansatmap.imshow" title="nansat.nansatmap.Nansatmap.imshow"><tt class="xref py py-meth docutils literal"><span class="pre">imshow()</span></tt></a>.</p>
<p>returns a matplotlib.image.AxesImage instance.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.fillcontinents">
<tt class="descname">fillcontinents</tt><big>(</big><em>color='0.8'</em>, <em>lake_color=None</em>, <em>ax=None</em>, <em>zorder=None</em>, <em>alpha=None</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.fillcontinents" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill continents.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>color</td>
<td>color to fill continents (default gray).</td>
</tr>
<tr class="row-odd"><td>lake_color</td>
<td>color to fill inland lakes (default axes background).</td>
</tr>
<tr class="row-even"><td>ax</td>
<td>axes instance (overrides default axes instance).</td>
</tr>
<tr class="row-odd"><td>zorder</td>
<td>sets the zorder for the continent polygons (if not
specified, uses default zorder for a Polygon patch).
Set to zero if you want to paint over the filled
continents).</td>
</tr>
<tr class="row-even"><td>alpha</td>
<td>sets alpha transparency for continent polygons</td>
</tr>
</tbody>
</table>
<p>After filling continents, lakes are re-filled with
axis background color.</p>
<p>returns a list of matplotlib.patches.Polygon objects.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.gcpoints">
<tt class="descname">gcpoints</tt><big>(</big><em>lon1</em>, <em>lat1</em>, <em>lon2</em>, <em>lat2</em>, <em>npoints</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.gcpoints" title="Permalink to this definition">¶</a></dt>
<dd><p>compute <tt class="docutils literal"><span class="pre">points</span></tt> points along a great circle with endpoints
<tt class="docutils literal"><span class="pre">(lon1,lat1)</span></tt> and <tt class="docutils literal"><span class="pre">(lon2,lat2)</span></tt>.</p>
<p>Returns arrays x,y with map projection coordinates.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.hexbin">
<tt class="descname">hexbin</tt><big>(</big><em>x</em>, <em>y</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.hexbin" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a hexagonal binning plot of x versus y, where x, y are 1-D
sequences of the same length, N. If C is None (the default), this is a
histogram of the number of occurences of the observations at
(x[i],y[i]).</p>
<p>If C is specified, it specifies values at the coordinate (x[i],y[i]).
These values are accumulated for each hexagonal bin and then reduced
according to reduce_C_function, which defaults to the numpy mean function
(np.mean). (If C is specified, it must also be a 1-D sequence of the
same length as x and y.)</p>
<p>x, y and/or C may be masked arrays, in which case only unmasked points
will be plotted.</p>
<p>(see matplotlib.pyplot.hexbin documentation).</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>Other **kwargs passed on to matplotlib.pyplot.hexbin</p>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.imshow">
<tt class="descname">imshow</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.imshow" title="Permalink to this definition">¶</a></dt>
<dd><p>Display an image over the map
(see matplotlib.pyplot.imshow documentation).</p>
<p><tt class="docutils literal"><span class="pre">extent</span></tt> and <tt class="docutils literal"><span class="pre">origin</span></tt> keywords set automatically so image
will be drawn over map region.</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>Other **kwargs passed on to matplotlib.pyplot.plot.</p>
<p>returns an matplotlib.image.AxesImage instance.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.is_land">
<tt class="descname">is_land</tt><big>(</big><em>xpt</em>, <em>ypt</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.is_land" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the given x,y point (in projection coordinates) is
over land, False otherwise.  The definition of land is based upon
the GSHHS coastline polygons associated with the class instance.
Points over lakes inside land regions are not counted as land points.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.makegrid">
<tt class="descname">makegrid</tt><big>(</big><em>nx</em>, <em>ny</em>, <em>returnxy=False</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.makegrid" title="Permalink to this definition">¶</a></dt>
<dd><p>return arrays of shape (ny,nx) containing lon,lat coordinates of
an equally spaced native projection grid.</p>
<p>If <tt class="docutils literal"><span class="pre">returnxy</span> <span class="pre">=</span> <span class="pre">True</span></tt>, the x,y values of the grid are returned also.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.nightshade">
<tt class="descname">nightshade</tt><big>(</big><em>date</em>, <em>color='k'</em>, <em>delta=0.25</em>, <em>alpha=0.5</em>, <em>ax=None</em>, <em>zorder=2</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.nightshade" title="Permalink to this definition">¶</a></dt>
<dd><p>Shade the regions of the map that are in darkness at the time
specifed by <tt class="docutils literal"><span class="pre">date</span></tt>.  <tt class="docutils literal"><span class="pre">date</span></tt> is a datetime instance,
assumed to be UTC.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keywords</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>color</td>
<td>color to shade night regions (default black).</td>
</tr>
<tr class="row-odd"><td>delta</td>
<td>day/night terminator is computed with a
a resolution of <tt class="docutils literal"><span class="pre">delta</span></tt> degrees (default 0.25).</td>
</tr>
<tr class="row-even"><td>alpha</td>
<td>alpha transparency for shading (default 0.5, so
map background shows through).</td>
</tr>
<tr class="row-odd"><td>zorder</td>
<td>zorder for shading (default 2).</td>
</tr>
</tbody>
</table>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>returns a matplotlib.contour.ContourSet instance.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.pcolor">
<tt class="descname">pcolor</tt><big>(</big><em>x</em>, <em>y</em>, <em>data</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.pcolor" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a pseudo-color plot over the map
(see matplotlib.pyplot.pcolor documentation).</p>
<p>If <tt class="docutils literal"><span class="pre">latlon</span></tt> keyword is set to True, x,y are intrepreted as
longitude and latitude in degrees.  Data and longitudes are
automatically shifted to match map projection region for cylindrical
and pseudocylindrical projections, and x,y are transformed to map
projection coordinates. If <tt class="docutils literal"><span class="pre">latlon</span></tt> is False (default), x and y
are assumed to be map projection coordinates.</p>
<p>If x or y are outside projection limb (i.e. they have values &gt; 1.e20)
they will be convert to masked arrays with those values masked.
As a result, those values will not be plotted.</p>
<p>If <tt class="docutils literal"><span class="pre">tri</span></tt> is set to <tt class="docutils literal"><span class="pre">True</span></tt>, an unstructured grid is assumed
(x,y,data must be 1-d) and matplotlib.pyplot.tricolor is used.</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>Other **kwargs passed on to matplotlib.pyplot.pcolor (or tricolor if
<tt class="docutils literal"><span class="pre">tri=True</span></tt>).</p>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.pcolormesh">
<tt class="descname">pcolormesh</tt><big>(</big><em>data</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.pcolormesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a pseudo-color plot over the map</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : numpy 2D array</p>
<blockquote>
<div><p>Input data</p>
</div></blockquote>
<p><strong>**kwargs: dictionary</strong></p>
<blockquote>
<div><p>Parameters for Basemap.pcolormesh (e.g. vmin, vmax)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.mpl</strong> : list</p>
<blockquote class="last">
<div><p>append matplotlib.collections.QuadMesh object</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.plot">
<tt class="descname">plot</tt><big>(</big><em>x</em>, <em>y</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw lines and/or markers on the map
(see matplotlib.pyplot.plot documentation).</p>
<p>If <tt class="docutils literal"><span class="pre">latlon</span></tt> keyword is set to True, x,y are intrepreted as
longitude and latitude in degrees.  Data and longitudes are
automatically shifted to match map projection region for cylindrical
and pseudocylindrical projections, and x,y are transformed to map
projection coordinates. If <tt class="docutils literal"><span class="pre">latlon</span></tt> is False (default), x and y
are assumed to be map projection coordinates.</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>Other **kwargs passed on to matplotlib.pyplot.plot.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.quiver">
<tt class="descname">quiver</tt><big>(</big><em>dataX</em>, <em>dataY</em>, <em>step=None</em>, <em>quivectors=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.quiver" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw quiver plots</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dataX</strong> :  numpy array</p>
<blockquote>
<div><p>Input data with X-component</p>
</div></blockquote>
<p><strong>dataY</strong> :  numpy array</p>
<blockquote>
<div><p>Input data with Y-component</p>
</div></blockquote>
<p><strong>step</strong> : int or (int, int)</p>
<blockquote>
<div><p>Skip &lt;step&gt; pixels along both dimentions(alternative to quivectors)</p>
</div></blockquote>
<p><strong>quivectors</strong> : int or (int,int)</p>
<blockquote>
<div><p>Number of vectors along both dimentions</p>
</div></blockquote>
<p><strong>**kwargs: dictionary</strong></p>
<blockquote>
<div><p>Parameters for Basemap.quiver()</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modifies:</th><td class="field-body"><p class="first"><strong>self.mpl</strong> : list</p>
<blockquote class="last">
<div><p>append matplotlib.quiver.Quiver instance</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.readshapefile">
<tt class="descname">readshapefile</tt><big>(</big><em>shapefile</em>, <em>name</em>, <em>drawbounds=True</em>, <em>zorder=None</em>, <em>linewidth=0.5</em>, <em>color='k'</em>, <em>antialiased=1</em>, <em>ax=None</em>, <em>default_encoding='utf-8'</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.readshapefile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read in shape file, optionally draw boundaries on map.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>Assumes shapes are 2D</li>
<li>only works for Point, MultiPoint, Polyline and Polygon shapes.</li>
<li>vertices/points must be in geographic (lat/lon) coordinates.</li>
</ul>
</div>
<p>Mandatory Arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Argument</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>shapefile</td>
<td>path to shapefile components.  Example:
shapefile=&#8217;/home/jeff/esri/world_borders&#8217; assumes
that world_borders.shp, world_borders.shx and
world_borders.dbf live in /home/jeff/esri.</td>
</tr>
<tr class="row-odd"><td>name</td>
<td>name for Basemap attribute to hold the shapefile
vertices or points in map projection
coordinates. Class attribute name+&#8217;_info&#8217; is a list
of dictionaries, one for each shape, containing
attributes of each shape from dbf file, For
example, if name=&#8217;counties&#8217;, self.counties
will be a list of x,y vertices for each shape in
map projection  coordinates and self.counties_info
will be a list of dictionaries with shape
attributes.  Rings in individual Polygon
shapes are split out into separate polygons, and
additional keys &#8216;RINGNUM&#8217; and &#8216;SHAPENUM&#8217; are added
to the shape attribute dictionary.</td>
</tr>
</tbody>
</table>
<p>The following optional keyword arguments are only relevant for Polyline
and Polygon shape types, for Point and MultiPoint shapes they are
ignored.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>drawbounds</td>
<td>draw boundaries of shapes (default True).</td>
</tr>
<tr class="row-odd"><td>zorder</td>
<td>shape boundary zorder (if not specified,
default for mathplotlib.lines.LineCollection
is used).</td>
</tr>
<tr class="row-even"><td>linewidth</td>
<td>shape boundary line width (default 0.5)</td>
</tr>
<tr class="row-odd"><td>color</td>
<td>shape boundary line color (default black)</td>
</tr>
<tr class="row-even"><td>antialiased</td>
<td>antialiasing switch for shape boundaries
(default True).</td>
</tr>
<tr class="row-odd"><td>ax</td>
<td>axes instance (overrides default axes instance)</td>
</tr>
</tbody>
</table>
<p>A tuple (num_shapes, type, min, max) containing shape file info
is returned.
num_shapes is the number of shapes, type is the type code (one of
the SHPT* constants defined in the shapelib module, see
<a class="reference external" href="http://shapelib.maptools.org/shp_api.html">http://shapelib.maptools.org/shp_api.html</a>) and min and
max are 4-element lists with the minimum and maximum values of the
vertices. If <tt class="docutils literal"><span class="pre">drawbounds=True</span></tt> a
matplotlib.patches.LineCollection object is appended to the tuple.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.rotate_vector">
<tt class="descname">rotate_vector</tt><big>(</big><em>uin</em>, <em>vin</em>, <em>lons</em>, <em>lats</em>, <em>returnxy=False</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.rotate_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate a vector field (<tt class="docutils literal"><span class="pre">uin,vin</span></tt>) on a rectilinear grid
with longitudes = <tt class="docutils literal"><span class="pre">lons</span></tt> and latitudes = <tt class="docutils literal"><span class="pre">lats</span></tt> from
geographical (lat/lon) into map projection (x/y) coordinates.</p>
<p>Differs from transform_vector in that no interpolation is done.
The vector is returned on the same grid, but rotated into
x,y coordinates.</p>
<p>The input vector field is defined in spherical coordinates (it
has eastward and northward components) while the output
vector field is rotated to map projection coordinates (relative
to x and y). The magnitude of the vector is preserved.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Arguments</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>uin, vin</td>
<td>input vector field on a lat/lon grid.</td>
</tr>
<tr class="row-odd"><td>lons, lats</td>
<td>Arrays containing longitudes and latitudes
(in degrees) of input data in increasing order.
For non-cylindrical projections (those other than
<tt class="docutils literal"><span class="pre">cyl</span></tt>, <tt class="docutils literal"><span class="pre">merc</span></tt>, <tt class="docutils literal"><span class="pre">cyl</span></tt>, <tt class="docutils literal"><span class="pre">gall</span></tt> and <tt class="docutils literal"><span class="pre">mill</span></tt>) lons
must fit within range -180 to 180.</td>
</tr>
</tbody>
</table>
<p>Returns <tt class="docutils literal"><span class="pre">uout,</span> <span class="pre">vout</span></tt> (rotated vector field).
If the optional keyword argument
<tt class="docutils literal"><span class="pre">returnxy</span></tt> is True (default is False),
returns <tt class="docutils literal"><span class="pre">uout,vout,x,y</span></tt> (where <tt class="docutils literal"><span class="pre">x,y</span></tt> are the map projection
coordinates of the grid defined by <tt class="docutils literal"><span class="pre">lons,lats</span></tt>).</p>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.save">
<tt class="descname">save</tt><big>(</big><em>fileName</em>, <em>landmask=True</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw continents and save</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : string</p>
<blockquote>
<div><p>name of outputfile</p>
</div></blockquote>
<p><strong>landmask</strong> : Boolean</p>
<blockquote>
<div><p>Draw landmask?</p>
</div></blockquote>
<p><strong>**kwargs: dictionary</strong></p>
<blockquote class="last">
<div><p>Parameters for basemap.fillcontinents</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.scatter">
<tt class="descname">scatter</tt><big>(</big><em>x</em>, <em>y</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.scatter" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot points with markers on the map
(see matplotlib.pyplot.scatter documentation).</p>
<p>If <tt class="docutils literal"><span class="pre">latlon</span></tt> keyword is set to True, x,y are intrepreted as
longitude and latitude in degrees.  Data and longitudes are
automatically shifted to match map projection region for cylindrical
and pseudocylindrical projections, and x,y are transformed to map
projection coordinates. If <tt class="docutils literal"><span class="pre">latlon</span></tt> is False (default), x and y
are assumed to be map projection coordinates.</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axes instance.</p>
<p>Other **kwargs passed on to matplotlib.pyplot.scatter.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.set_axes_limits">
<tt class="descname">set_axes_limits</tt><big>(</big><em>ax=None</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.set_axes_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Final step in Basemap method wrappers of Axes plotting methods:</p>
<p>Set axis limits, fix aspect ratio for map domain using current
or specified axes instance.  This is done only once per axes
instance.</p>
<p>In interactive mode, this method always calls draw_if_interactive
before returning.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.shadedrelief">
<tt class="descname">shadedrelief</tt><big>(</big><em>ax=None</em>, <em>scale=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.shadedrelief" title="Permalink to this definition">¶</a></dt>
<dd><p>display shaded relief image (from <a class="reference external" href="http://www.shadedrelief.com">http://www.shadedrelief.com</a>)
as map background.
Default image size is 10800x5400, which can be quite slow and
use quite a bit of memory.  The <tt class="docutils literal"><span class="pre">scale</span></tt> keyword can be used
to downsample the image (<tt class="docutils literal"><span class="pre">scale=0.5</span></tt> downsamples to 5400x2700).</p>
<p>**kwargs passed on to <a class="reference internal" href="#nansat.nansatmap.Nansatmap.imshow" title="nansat.nansatmap.Nansatmap.imshow"><tt class="xref py py-meth docutils literal"><span class="pre">imshow()</span></tt></a>.</p>
<p>returns a matplotlib.image.AxesImage instance.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.shiftdata">
<tt class="descname">shiftdata</tt><big>(</big><em>lonsin</em>, <em>datain=None</em>, <em>lon_0=None</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.shiftdata" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift longitudes (and optionally data) so that they match map projection region.
Only valid for cylindrical/pseudo-cylindrical global projections and data
on regular lat/lon grids. longitudes and data can be 1-d or 2-d, if 2-d
it is assumed longitudes are 2nd (rightmost) dimension.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Arguments</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>lonsin</td>
<td>original 1-d or 2-d longitudes.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keywords</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>datain</td>
<td>original 1-d or 2-d data. Default None.</td>
</tr>
<tr class="row-odd"><td>lon_0</td>
<td>center of map projection region. Defaut None,
given by current map projection.</td>
</tr>
</tbody>
</table>
<p>if datain given, returns <tt class="docutils literal"><span class="pre">dataout,lonsout</span></tt> (data and longitudes shifted to fit in interval
[lon_0-180,lon_0+180]), otherwise just returns longitudes.  If
transformed longitudes lie outside map projection region, data is
masked and longitudes are set to 1.e30.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.smooth">
<tt class="descname">smooth</tt><big>(</big><em>idata</em>, <em>mode</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.smooth" title="Permalink to this definition">¶</a></dt>
<dd><p>Smooth data for contour() and contourf()</p>
<p>idata is smoothed by convolve, fourier_gaussian, spline or
gaussian (default). If contour_mode is &#8216;convolve&#8217; and weight is None,
the weight matrix is created automatically.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>idata</strong> : numpy 2D array</p>
<blockquote>
<div><p>Input data</p>
</div></blockquote>
<p><strong>mode</strong> : string</p>
<blockquote>
<div><p>&#8216;convolve&#8217;,&#8217;fourier&#8217;,&#8217;spline&#8217; or &#8216;gaussian&#8217;</p>
</div></blockquote>
<p><strong>**kwargs: dictionary</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>odata</strong> : numpy 2D array</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>see also : <a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/ndimage.html">http://docs.scipy.org/doc/scipy/reference/ndimage.html</a></p>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.streamplot">
<tt class="descname">streamplot</tt><big>(</big><em>x</em>, <em>y</em>, <em>u</em>, <em>v</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.streamplot" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws streamlines of a vector flow.
(see matplotlib.pyplot.streamplot documentation).</p>
<p>If <tt class="docutils literal"><span class="pre">latlon</span></tt> keyword is set to True, x,y are intrepreted as
longitude and latitude in degrees.  Data and longitudes are
automatically shifted to match map projection region for cylindrical
and pseudocylindrical projections, and x,y are transformed to map
projection coordinates. If <tt class="docutils literal"><span class="pre">latlon</span></tt> is False (default), x and y
are assumed to be map projection coordinates.</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>Other *args and **kwargs passed on to matplotlib.pyplot.streamplot.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.tissot">
<tt class="descname">tissot</tt><big>(</big><em>lon_0</em>, <em>lat_0</em>, <em>radius_deg</em>, <em>npts</em>, <em>ax=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.tissot" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a polygon centered at <tt class="docutils literal"><span class="pre">lon_0,lat_0</span></tt>.  The polygon
approximates a circle on the surface of the earth with radius
<tt class="docutils literal"><span class="pre">radius_deg</span></tt> degrees latitude along longitude <tt class="docutils literal"><span class="pre">lon_0</span></tt>,
made up of <tt class="docutils literal"><span class="pre">npts</span></tt> vertices.
The polygon represents a Tissot&#8217;s indicatrix
(<a class="reference external" href="http://en.wikipedia.org/wiki/Tissot's_Indicatrix">http://en.wikipedia.org/wiki/Tissot&#8217;s_Indicatrix</a>),
which when drawn on a map shows the distortion
inherent in the map projection.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Cannot handle situations in which the polygon intersects
the edge of the map projection domain, and then re-enters the domain.</p>
</div>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>Other **kwargs passed on to matplotlib.patches.Polygon.</p>
<p>returns a matplotlib.patches.Polygon object.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.transform_scalar">
<tt class="descname">transform_scalar</tt><big>(</big><em>datin</em>, <em>lons</em>, <em>lats</em>, <em>nx</em>, <em>ny</em>, <em>returnxy=False</em>, <em>checkbounds=False</em>, <em>order=1</em>, <em>masked=False</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.transform_scalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate a scalar field (<tt class="docutils literal"><span class="pre">datin</span></tt>) from a lat/lon grid with
longitudes = <tt class="docutils literal"><span class="pre">lons</span></tt> and latitudes = <tt class="docutils literal"><span class="pre">lats</span></tt> to a <tt class="docutils literal"><span class="pre">ny</span></tt> by <tt class="docutils literal"><span class="pre">nx</span></tt>
map projection grid.  Typically used to transform data to
map projection coordinates for plotting on a map with
the <a class="reference internal" href="#nansat.nansatmap.Nansatmap.imshow" title="nansat.nansatmap.Nansatmap.imshow"><tt class="xref py py-meth docutils literal"><span class="pre">imshow()</span></tt></a>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Argument</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>datin</td>
<td>input data on a lat/lon grid.</td>
</tr>
<tr class="row-odd"><td>lons, lats</td>
<td>rank-1 arrays containing longitudes and latitudes
(in degrees) of input data in increasing order.
For non-cylindrical projections (those other than
<tt class="docutils literal"><span class="pre">cyl</span></tt>, <tt class="docutils literal"><span class="pre">merc</span></tt>, <tt class="docutils literal"><span class="pre">cea</span></tt>, <tt class="docutils literal"><span class="pre">gall</span></tt> and <tt class="docutils literal"><span class="pre">mill</span></tt>) lons
must fit within range -180 to 180.</td>
</tr>
<tr class="row-even"><td>nx, ny</td>
<td>The size of the output regular grid in map
projection coordinates</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>returnxy</td>
<td>If True, the x and y values of the map
projection grid are also returned (Default False).</td>
</tr>
<tr class="row-odd"><td>checkbounds</td>
<td>If True, values of lons and lats are checked to see
that they lie within the map projection region.
Default is False, and data outside map projection
region is clipped to values on boundary.</td>
</tr>
<tr class="row-even"><td>masked</td>
<td>If True, interpolated data is returned as a masked
array with values outside map projection region
masked (Default False).</td>
</tr>
<tr class="row-odd"><td>order</td>
<td>0 for nearest-neighbor interpolation, 1 for
bilinear, 3 for cubic spline (Default 1).
Cubic spline interpolation requires scipy.ndimage.</td>
</tr>
</tbody>
</table>
<p>Returns <tt class="docutils literal"><span class="pre">datout</span></tt> (data on map projection grid).
If returnxy=True, returns <tt class="docutils literal"><span class="pre">data,x,y</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.transform_vector">
<tt class="descname">transform_vector</tt><big>(</big><em>uin</em>, <em>vin</em>, <em>lons</em>, <em>lats</em>, <em>nx</em>, <em>ny</em>, <em>returnxy=False</em>, <em>checkbounds=False</em>, <em>order=1</em>, <em>masked=False</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.transform_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate and interpolate a vector field (<tt class="docutils literal"><span class="pre">uin,vin</span></tt>) from a
lat/lon grid with longitudes = <tt class="docutils literal"><span class="pre">lons</span></tt> and latitudes = <tt class="docutils literal"><span class="pre">lats</span></tt>
to a <tt class="docutils literal"><span class="pre">ny</span></tt> by <tt class="docutils literal"><span class="pre">nx</span></tt> map projection grid.</p>
<p>The input vector field is defined in spherical coordinates (it
has eastward and northward components) while the output
vector field is rotated to map projection coordinates (relative
to x and y). The magnitude of the vector is preserved.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Arguments</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>uin, vin</td>
<td>input vector field on a lat/lon grid.</td>
</tr>
<tr class="row-odd"><td>lons, lats</td>
<td>rank-1 arrays containing longitudes and latitudes
(in degrees) of input data in increasing order.
For non-cylindrical projections (those other than
<tt class="docutils literal"><span class="pre">cyl</span></tt>, <tt class="docutils literal"><span class="pre">merc</span></tt>, <tt class="docutils literal"><span class="pre">cea</span></tt>, <tt class="docutils literal"><span class="pre">gall</span></tt> and <tt class="docutils literal"><span class="pre">mill</span></tt>) lons
must fit within range -180 to 180.</td>
</tr>
<tr class="row-even"><td>nx, ny</td>
<td>The size of the output regular grid in map
projection coordinates</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>returnxy</td>
<td>If True, the x and y values of the map
projection grid are also returned (Default False).</td>
</tr>
<tr class="row-odd"><td>checkbounds</td>
<td>If True, values of lons and lats are checked to see
that they lie within the map projection region.
Default is False, and data outside map projection
region is clipped to values on boundary.</td>
</tr>
<tr class="row-even"><td>masked</td>
<td>If True, interpolated data is returned as a masked
array with values outside map projection region
masked (Default False).</td>
</tr>
<tr class="row-odd"><td>order</td>
<td>0 for nearest-neighbor interpolation, 1 for
bilinear, 3 for cubic spline (Default 1).
Cubic spline interpolation requires scipy.ndimage.</td>
</tr>
</tbody>
</table>
<p>Returns <tt class="docutils literal"><span class="pre">uout,</span> <span class="pre">vout</span></tt> (vector field on map projection grid).
If returnxy=True, returns <tt class="docutils literal"><span class="pre">uout,vout,x,y</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.warpimage">
<tt class="descname">warpimage</tt><big>(</big><em>image='bluemarble'</em>, <em>scale=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.warpimage" title="Permalink to this definition">¶</a></dt>
<dd><p>Display an image (filename given by <tt class="docutils literal"><span class="pre">image</span></tt> keyword) as a map background.
If image is a URL (starts with &#8216;http&#8217;), it is downloaded to a temp
file using urllib.urlretrieve.</p>
<p>Default (if <tt class="docutils literal"><span class="pre">image</span></tt> not specified) is to display
&#8216;blue marble next generation&#8217; image from <a class="reference external" href="http://visibleearth.nasa.gov/">http://visibleearth.nasa.gov/</a>.</p>
<p>Specified image must have pixels covering the whole globe in a regular
lat/lon grid, starting and -180W and the South Pole.
Works with the global images from
<a class="reference external" href="http://earthobservatory.nasa.gov/Features/BlueMarble/BlueMarble_monthlies.php">http://earthobservatory.nasa.gov/Features/BlueMarble/BlueMarble_monthlies.php</a>.</p>
<p>The <tt class="docutils literal"><span class="pre">scale</span></tt> keyword can be used to downsample (rescale) the image.
Values less than 1.0 will speed things up at the expense of image
resolution.</p>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>**kwargs passed on to <a class="reference internal" href="#nansat.nansatmap.Nansatmap.imshow" title="nansat.nansatmap.Nansatmap.imshow"><tt class="xref py py-meth docutils literal"><span class="pre">imshow()</span></tt></a>.</p>
<p>returns a matplotlib.image.AxesImage instance.</p>
</dd></dl>

<dl class="method">
<dt id="nansat.nansatmap.Nansatmap.wmsimage">
<tt class="descname">wmsimage</tt><big>(</big><em>server</em>, <em>xpixels=400</em>, <em>ypixels=None</em>, <em>format='png'</em>, <em>verbose=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#nansat.nansatmap.Nansatmap.wmsimage" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve an image using from a WMS server using the
Open Geospatial Consortium (OGC) standard interface
and display on the map. Requires OWSLib
(<a class="reference external" href="http://pypi.python.org/pypi/OWSLib">http://pypi.python.org/pypi/OWSLib</a>).
In order to use this method, the Basemap instance must be
created using the <tt class="docutils literal"><span class="pre">epsg</span></tt> keyword to define the map projection, unless
the <tt class="docutils literal"><span class="pre">cyl</span></tt> projection is used (in which case the epsg code 4326 is
assumed).</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keywords</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>server</td>
<td>WMS server URL.</td>
</tr>
<tr class="row-odd"><td>xpixels</td>
<td>requested number of image pixels in x-direction
(default 400).</td>
</tr>
<tr class="row-even"><td>ypixels</td>
<td>requested number of image pixels in y-direction.
Default (None) is to infer the number from
from xpixels and the aspect ratio of the
map projection region.</td>
</tr>
<tr class="row-odd"><td>format</td>
<td>desired image format (default &#8216;png&#8217;)</td>
</tr>
<tr class="row-even"><td>verbose</td>
<td>if True, print WMS server info (default
False).</td>
</tr>
<tr class="row-odd"><td>**kwargs</td>
<td>extra keyword arguments passed on to
OWSLib.wms.WebMapService.getmap.</td>
</tr>
</tbody>
</table>
<p>Extra keyword <tt class="docutils literal"><span class="pre">ax</span></tt> can be used to override the default axis instance.</p>
<p>returns a matplotlib.image.AxesImage instance.</p>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>

    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2013, Nansen Center.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.3.
      </li>
    </ul>
    </div>
    </div>
    </div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-43252602-1', 'nansencenter.github.io');
  ga('send', 'pageview');

</script>

  </body>
</html>